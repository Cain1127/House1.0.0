// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qschat.proto

#ifndef PROTOBUF_qschat_2eproto__INCLUDED
#define PROTOBUF_qschat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace QSChat {
    
    // Internal implementation detail -- do not call these.
    void  protobuf_AddDesc_qschat_2eproto();
    void protobuf_AssignDesc_qschat_2eproto();
    void protobuf_ShutdownFile_qschat_2eproto();
    
    class QuestionOnline;
    class QuestionOffline;
    class QuestionSendedAnswerBack;
    class QuestionHistory;
    class QuestionWord;
    class QuestionPic;
    class QuestionVideo;
    class QuestionRecommendHouse;
    class AnswerWord;
    class AnswerPic;
    class AnswerVideo;
    class AnswerRecommendHouse;
    class AnswerRecHouse;
    class Finfo;
    class AnswerOffline;
    class AnswerSpecial;
    class AnswerSystem;
    
    enum QSChatMessageType {
        QSCHAT_WORD = 9000,
        QSCHAT_PIC = 9001,
        QSCHAT_VIDEO = 9002,
        QSCHAT_ONLINE = 9003,
        QSCHAT_OFFLINE = 9004,
        QSCHAT_SPECIAL = 9005,
        QSCHAT_SYSTEM = 9006,
        QSCHAT_HISTORY_WORD = 9007,
        QSCHAT_HISTORY_PIC = 9008,
        QSCHAT_HISTORY_VIDEO = 9009,
        QSCHAT_HISTORY = 9010,
        QSCHAT_HISTORY_SP = 9011,
        QSCHAT_RECOMMEND_HOUSE = 9012,
        QSCHAT_HISTORY_RECOMMEND_HOUSE = 9013,
        QSCHAT_SENDED_ANSWER_BACK = 9999
    };
    bool QSChatMessageType_IsValid(int value);
    const QSChatMessageType QSChatMessageType_MIN = QSCHAT_WORD;
    const QSChatMessageType QSChatMessageType_MAX = QSCHAT_SENDED_ANSWER_BACK;
    const int QSChatMessageType_ARRAYSIZE = QSChatMessageType_MAX + 1;
    
    const ::google::protobuf::EnumDescriptor* QSChatMessageType_descriptor();
    inline const ::std::string& QSChatMessageType_Name(QSChatMessageType value) {
        return ::google::protobuf::internal::NameOfEnum(
                                                        QSChatMessageType_descriptor(), value);
    }
    inline bool QSChatMessageType_Parse(
                                        const ::std::string& name, QSChatMessageType* value) {
        return ::google::protobuf::internal::ParseNamedEnum<QSChatMessageType>(
                                                                               QSChatMessageType_descriptor(), name, value);
    }
    enum ChatRequestType {
        ChatTypeSendPTP = 8000,
        ChatTypeSendPTG = 8001
    };
    bool ChatRequestType_IsValid(int value);
    const ChatRequestType ChatRequestType_MIN = ChatTypeSendPTP;
    const ChatRequestType ChatRequestType_MAX = ChatTypeSendPTG;
    const int ChatRequestType_ARRAYSIZE = ChatRequestType_MAX + 1;
    
    const ::google::protobuf::EnumDescriptor* ChatRequestType_descriptor();
    inline const ::std::string& ChatRequestType_Name(ChatRequestType value) {
        return ::google::protobuf::internal::NameOfEnum(
                                                        ChatRequestType_descriptor(), value);
    }
    inline bool ChatRequestType_Parse(
                                      const ::std::string& name, ChatRequestType* value) {
        return ::google::protobuf::internal::ParseNamedEnum<ChatRequestType>(
                                                                             ChatRequestType_descriptor(), name, value);
    }
    // ===================================================================
    
    class QuestionOnline : public ::google::protobuf::Message {
    public:
        QuestionOnline();
        virtual ~QuestionOnline();
        
        QuestionOnline(const QuestionOnline& from);
        
        inline QuestionOnline& operator=(const QuestionOnline& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const QuestionOnline& default_instance();
        
        void Swap(QuestionOnline* other);
        
        // implements Message ----------------------------------------------
        
        QuestionOnline* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const QuestionOnline& from);
        void MergeFrom(const QuestionOnline& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required string token = 1;
        inline bool has_token() const;
        inline void clear_token();
        static const int kTokenFieldNumber = 1;
        inline const ::std::string& token() const;
        inline void set_token(const ::std::string& value);
        inline void set_token(const char* value);
        inline void set_token(const char* value, size_t size);
        inline ::std::string* mutable_token();
        inline ::std::string* release_token();
        inline void set_allocated_token(::std::string* token);
        
        // required string user_id = 2;
        inline bool has_user_id() const;
        inline void clear_user_id();
        static const int kUserIdFieldNumber = 2;
        inline const ::std::string& user_id() const;
        inline void set_user_id(const ::std::string& value);
        inline void set_user_id(const char* value);
        inline void set_user_id(const char* value, size_t size);
        inline ::std::string* mutable_user_id();
        inline ::std::string* release_user_id();
        inline void set_allocated_user_id(::std::string* user_id);
        
        // required string device_udid = 3;
        inline bool has_device_udid() const;
        inline void clear_device_udid();
        static const int kDeviceUdidFieldNumber = 3;
        inline const ::std::string& device_udid() const;
        inline void set_device_udid(const ::std::string& value);
        inline void set_device_udid(const char* value);
        inline void set_device_udid(const char* value, size_t size);
        inline ::std::string* mutable_device_udid();
        inline ::std::string* release_device_udid();
        inline void set_allocated_device_udid(::std::string* device_udid);
        
        // required string device_info = 4;
        inline bool has_device_info() const;
        inline void clear_device_info();
        static const int kDeviceInfoFieldNumber = 4;
        inline const ::std::string& device_info() const;
        inline void set_device_info(const ::std::string& value);
        inline void set_device_info(const char* value);
        inline void set_device_info(const char* value, size_t size);
        inline ::std::string* mutable_device_info();
        inline ::std::string* release_device_info();
        inline void set_allocated_device_info(::std::string* device_info);
        
        // optional string local_info = 5;
        inline bool has_local_info() const;
        inline void clear_local_info();
        static const int kLocalInfoFieldNumber = 5;
        inline const ::std::string& local_info() const;
        inline void set_local_info(const ::std::string& value);
        inline void set_local_info(const char* value);
        inline void set_local_info(const char* value, size_t size);
        inline ::std::string* mutable_local_info();
        inline ::std::string* release_local_info();
        inline void set_allocated_local_info(::std::string* local_info);
        
        // @@protoc_insertion_point(class_scope:QSChat.QuestionOnline)
    private:
        inline void set_has_token();
        inline void clear_has_token();
        inline void set_has_user_id();
        inline void clear_has_user_id();
        inline void set_has_device_udid();
        inline void clear_has_device_udid();
        inline void set_has_device_info();
        inline void clear_has_device_info();
        inline void set_has_local_info();
        inline void clear_has_local_info();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string* token_;
        ::std::string* user_id_;
        ::std::string* device_udid_;
        ::std::string* device_info_;
        ::std::string* local_info_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static QuestionOnline* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class QuestionOffline : public ::google::protobuf::Message {
    public:
        QuestionOffline();
        virtual ~QuestionOffline();
        
        QuestionOffline(const QuestionOffline& from);
        
        inline QuestionOffline& operator=(const QuestionOffline& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const QuestionOffline& default_instance();
        
        void Swap(QuestionOffline* other);
        
        // implements Message ----------------------------------------------
        
        QuestionOffline* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const QuestionOffline& from);
        void MergeFrom(const QuestionOffline& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required string token = 1;
        inline bool has_token() const;
        inline void clear_token();
        static const int kTokenFieldNumber = 1;
        inline const ::std::string& token() const;
        inline void set_token(const ::std::string& value);
        inline void set_token(const char* value);
        inline void set_token(const char* value, size_t size);
        inline ::std::string* mutable_token();
        inline ::std::string* release_token();
        inline void set_allocated_token(::std::string* token);
        
        // required string device_udid = 2;
        inline bool has_device_udid() const;
        inline void clear_device_udid();
        static const int kDeviceUdidFieldNumber = 2;
        inline const ::std::string& device_udid() const;
        inline void set_device_udid(const ::std::string& value);
        inline void set_device_udid(const char* value);
        inline void set_device_udid(const char* value, size_t size);
        inline ::std::string* mutable_device_udid();
        inline ::std::string* release_device_udid();
        inline void set_allocated_device_udid(::std::string* device_udid);
        
        // required string device_info = 3;
        inline bool has_device_info() const;
        inline void clear_device_info();
        static const int kDeviceInfoFieldNumber = 3;
        inline const ::std::string& device_info() const;
        inline void set_device_info(const ::std::string& value);
        inline void set_device_info(const char* value);
        inline void set_device_info(const char* value, size_t size);
        inline ::std::string* mutable_device_info();
        inline ::std::string* release_device_info();
        inline void set_allocated_device_info(::std::string* device_info);
        
        // required string local_info = 4;
        inline bool has_local_info() const;
        inline void clear_local_info();
        static const int kLocalInfoFieldNumber = 4;
        inline const ::std::string& local_info() const;
        inline void set_local_info(const ::std::string& value);
        inline void set_local_info(const char* value);
        inline void set_local_info(const char* value, size_t size);
        inline ::std::string* mutable_local_info();
        inline ::std::string* release_local_info();
        inline void set_allocated_local_info(::std::string* local_info);
        
        // required string time_stamp = 5;
        inline bool has_time_stamp() const;
        inline void clear_time_stamp();
        static const int kTimeStampFieldNumber = 5;
        inline const ::std::string& time_stamp() const;
        inline void set_time_stamp(const ::std::string& value);
        inline void set_time_stamp(const char* value);
        inline void set_time_stamp(const char* value, size_t size);
        inline ::std::string* mutable_time_stamp();
        inline ::std::string* release_time_stamp();
        inline void set_allocated_time_stamp(::std::string* time_stamp);
        
        // required int64 fid = 6;
        inline bool has_fid() const;
        inline void clear_fid();
        static const int kFidFieldNumber = 6;
        inline ::google::protobuf::int64 fid() const;
        inline void set_fid(::google::protobuf::int64 value);
        
        // required string f_avatar = 7;
        inline bool has_f_avatar() const;
        inline void clear_f_avatar();
        static const int kFAvatarFieldNumber = 7;
        inline const ::std::string& f_avatar() const;
        inline void set_f_avatar(const ::std::string& value);
        inline void set_f_avatar(const char* value);
        inline void set_f_avatar(const char* value, size_t size);
        inline ::std::string* mutable_f_avatar();
        inline ::std::string* release_f_avatar();
        inline void set_allocated_f_avatar(::std::string* f_avatar);
        
        // required string f_name = 8;
        inline bool has_f_name() const;
        inline void clear_f_name();
        static const int kFNameFieldNumber = 8;
        inline const ::std::string& f_name() const;
        inline void set_f_name(const ::std::string& value);
        inline void set_f_name(const char* value);
        inline void set_f_name(const char* value, size_t size);
        inline ::std::string* mutable_f_name();
        inline ::std::string* release_f_name();
        inline void set_allocated_f_name(::std::string* f_name);
        
        // required string f_leve = 9;
        inline bool has_f_leve() const;
        inline void clear_f_leve();
        static const int kFLeveFieldNumber = 9;
        inline const ::std::string& f_leve() const;
        inline void set_f_leve(const ::std::string& value);
        inline void set_f_leve(const char* value);
        inline void set_f_leve(const char* value, size_t size);
        inline ::std::string* mutable_f_leve();
        inline ::std::string* release_f_leve();
        inline void set_allocated_f_leve(::std::string* f_leve);
        
        // required string f_user_type = 10;
        inline bool has_f_user_type() const;
        inline void clear_f_user_type();
        static const int kFUserTypeFieldNumber = 10;
        inline const ::std::string& f_user_type() const;
        inline void set_f_user_type(const ::std::string& value);
        inline void set_f_user_type(const char* value);
        inline void set_f_user_type(const char* value, size_t size);
        inline ::std::string* mutable_f_user_type();
        inline ::std::string* release_f_user_type();
        inline void set_allocated_f_user_type(::std::string* f_user_type);
        
        // @@protoc_insertion_point(class_scope:QSChat.QuestionOffline)
    private:
        inline void set_has_token();
        inline void clear_has_token();
        inline void set_has_device_udid();
        inline void clear_has_device_udid();
        inline void set_has_device_info();
        inline void clear_has_device_info();
        inline void set_has_local_info();
        inline void clear_has_local_info();
        inline void set_has_time_stamp();
        inline void clear_has_time_stamp();
        inline void set_has_fid();
        inline void clear_has_fid();
        inline void set_has_f_avatar();
        inline void clear_has_f_avatar();
        inline void set_has_f_name();
        inline void clear_has_f_name();
        inline void set_has_f_leve();
        inline void clear_has_f_leve();
        inline void set_has_f_user_type();
        inline void clear_has_f_user_type();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string* token_;
        ::std::string* device_udid_;
        ::std::string* device_info_;
        ::std::string* local_info_;
        ::std::string* time_stamp_;
        ::google::protobuf::int64 fid_;
        ::std::string* f_avatar_;
        ::std::string* f_name_;
        ::std::string* f_leve_;
        ::std::string* f_user_type_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static QuestionOffline* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class QuestionSendedAnswerBack : public ::google::protobuf::Message {
    public:
        QuestionSendedAnswerBack();
        virtual ~QuestionSendedAnswerBack();
        
        QuestionSendedAnswerBack(const QuestionSendedAnswerBack& from);
        
        inline QuestionSendedAnswerBack& operator=(const QuestionSendedAnswerBack& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const QuestionSendedAnswerBack& default_instance();
        
        void Swap(QuestionSendedAnswerBack* other);
        
        // implements Message ----------------------------------------------
        
        QuestionSendedAnswerBack* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const QuestionSendedAnswerBack& from);
        void MergeFrom(const QuestionSendedAnswerBack& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required string f_time_stamp = 1;
        inline bool has_f_time_stamp() const;
        inline void clear_f_time_stamp();
        static const int kFTimeStampFieldNumber = 1;
        inline const ::std::string& f_time_stamp() const;
        inline void set_f_time_stamp(const ::std::string& value);
        inline void set_f_time_stamp(const char* value);
        inline void set_f_time_stamp(const char* value, size_t size);
        inline ::std::string* mutable_f_time_stamp();
        inline ::std::string* release_f_time_stamp();
        inline void set_allocated_f_time_stamp(::std::string* f_time_stamp);
        
        // required string f_user_id = 2;
        inline bool has_f_user_id() const;
        inline void clear_f_user_id();
        static const int kFUserIdFieldNumber = 2;
        inline const ::std::string& f_user_id() const;
        inline void set_f_user_id(const ::std::string& value);
        inline void set_f_user_id(const char* value);
        inline void set_f_user_id(const char* value, size_t size);
        inline ::std::string* mutable_f_user_id();
        inline ::std::string* release_f_user_id();
        inline void set_allocated_f_user_id(::std::string* f_user_id);
        
        // required string f_udid = 3;
        inline bool has_f_udid() const;
        inline void clear_f_udid();
        static const int kFUdidFieldNumber = 3;
        inline const ::std::string& f_udid() const;
        inline void set_f_udid(const ::std::string& value);
        inline void set_f_udid(const char* value);
        inline void set_f_udid(const char* value, size_t size);
        inline ::std::string* mutable_f_udid();
        inline ::std::string* release_f_udid();
        inline void set_allocated_f_udid(::std::string* f_udid);
        
        // required string server_time_stamp = 4;
        inline bool has_server_time_stamp() const;
        inline void clear_server_time_stamp();
        static const int kServerTimeStampFieldNumber = 4;
        inline const ::std::string& server_time_stamp() const;
        inline void set_server_time_stamp(const ::std::string& value);
        inline void set_server_time_stamp(const char* value);
        inline void set_server_time_stamp(const char* value, size_t size);
        inline ::std::string* mutable_server_time_stamp();
        inline ::std::string* release_server_time_stamp();
        inline void set_allocated_server_time_stamp(::std::string* server_time_stamp);
        
        // @@protoc_insertion_point(class_scope:QSChat.QuestionSendedAnswerBack)
    private:
        inline void set_has_f_time_stamp();
        inline void clear_has_f_time_stamp();
        inline void set_has_f_user_id();
        inline void clear_has_f_user_id();
        inline void set_has_f_udid();
        inline void clear_has_f_udid();
        inline void set_has_server_time_stamp();
        inline void clear_has_server_time_stamp();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string* f_time_stamp_;
        ::std::string* f_user_id_;
        ::std::string* f_udid_;
        ::std::string* server_time_stamp_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static QuestionSendedAnswerBack* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class QuestionHistory : public ::google::protobuf::Message {
    public:
        QuestionHistory();
        virtual ~QuestionHistory();
        
        QuestionHistory(const QuestionHistory& from);
        
        inline QuestionHistory& operator=(const QuestionHistory& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const QuestionHistory& default_instance();
        
        void Swap(QuestionHistory* other);
        
        // implements Message ----------------------------------------------
        
        QuestionHistory* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const QuestionHistory& from);
        void MergeFrom(const QuestionHistory& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required .QSChat.ChatRequestType ctype = 1;
        inline bool has_ctype() const;
        inline void clear_ctype();
        static const int kCtypeFieldNumber = 1;
        inline ::QSChat::ChatRequestType ctype() const;
        inline void set_ctype(::QSChat::ChatRequestType value);
        
        // required string token = 2;
        inline bool has_token() const;
        inline void clear_token();
        static const int kTokenFieldNumber = 2;
        inline const ::std::string& token() const;
        inline void set_token(const ::std::string& value);
        inline void set_token(const char* value);
        inline void set_token(const char* value, size_t size);
        inline ::std::string* mutable_token();
        inline ::std::string* release_token();
        inline void set_allocated_token(::std::string* token);
        
        // required string wid = 3;
        inline bool has_wid() const;
        inline void clear_wid();
        static const int kWidFieldNumber = 3;
        inline const ::std::string& wid() const;
        inline void set_wid(const ::std::string& value);
        inline void set_wid(const char* value);
        inline void set_wid(const char* value, size_t size);
        inline ::std::string* mutable_wid();
        inline ::std::string* release_wid();
        inline void set_allocated_wid(::std::string* wid);
        
        // required string page_num = 4;
        inline bool has_page_num() const;
        inline void clear_page_num();
        static const int kPageNumFieldNumber = 4;
        inline const ::std::string& page_num() const;
        inline void set_page_num(const ::std::string& value);
        inline void set_page_num(const char* value);
        inline void set_page_num(const char* value, size_t size);
        inline ::std::string* mutable_page_num();
        inline ::std::string* release_page_num();
        inline void set_allocated_page_num(::std::string* page_num);
        
        // required string current_page = 5;
        inline bool has_current_page() const;
        inline void clear_current_page();
        static const int kCurrentPageFieldNumber = 5;
        inline const ::std::string& current_page() const;
        inline void set_current_page(const ::std::string& value);
        inline void set_current_page(const char* value);
        inline void set_current_page(const char* value, size_t size);
        inline ::std::string* mutable_current_page();
        inline ::std::string* release_current_page();
        inline void set_allocated_current_page(::std::string* current_page);
        
        // required string last_id = 6;
        inline bool has_last_id() const;
        inline void clear_last_id();
        static const int kLastIdFieldNumber = 6;
        inline const ::std::string& last_id() const;
        inline void set_last_id(const ::std::string& value);
        inline void set_last_id(const char* value);
        inline void set_last_id(const char* value, size_t size);
        inline ::std::string* mutable_last_id();
        inline ::std::string* release_last_id();
        inline void set_allocated_last_id(::std::string* last_id);
        
        // @@protoc_insertion_point(class_scope:QSChat.QuestionHistory)
    private:
        inline void set_has_ctype();
        inline void clear_has_ctype();
        inline void set_has_token();
        inline void clear_has_token();
        inline void set_has_wid();
        inline void clear_has_wid();
        inline void set_has_page_num();
        inline void clear_has_page_num();
        inline void set_has_current_page();
        inline void clear_has_current_page();
        inline void set_has_last_id();
        inline void clear_has_last_id();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string* token_;
        ::std::string* wid_;
        ::std::string* page_num_;
        ::std::string* current_page_;
        ::std::string* last_id_;
        int ctype_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static QuestionHistory* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class QuestionWord : public ::google::protobuf::Message {
    public:
        QuestionWord();
        virtual ~QuestionWord();
        
        QuestionWord(const QuestionWord& from);
        
        inline QuestionWord& operator=(const QuestionWord& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const QuestionWord& default_instance();
        
        void Swap(QuestionWord* other);
        
        // implements Message ----------------------------------------------
        
        QuestionWord* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const QuestionWord& from);
        void MergeFrom(const QuestionWord& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required int64 mid = 1;
        inline bool has_mid() const;
        inline void clear_mid();
        static const int kMidFieldNumber = 1;
        inline ::google::protobuf::int64 mid() const;
        inline void set_mid(::google::protobuf::int64 value);
        
        // required int64 tid = 2;
        inline bool has_tid() const;
        inline void clear_tid();
        static const int kTidFieldNumber = 2;
        inline ::google::protobuf::int64 tid() const;
        inline void set_tid(::google::protobuf::int64 value);
        
        // required .QSChat.ChatRequestType ctype = 3;
        inline bool has_ctype() const;
        inline void clear_ctype();
        static const int kCtypeFieldNumber = 3;
        inline ::QSChat::ChatRequestType ctype() const;
        inline void set_ctype(::QSChat::ChatRequestType value);
        
        // required string message = 4;
        inline bool has_message() const;
        inline void clear_message();
        static const int kMessageFieldNumber = 4;
        inline const ::std::string& message() const;
        inline void set_message(const ::std::string& value);
        inline void set_message(const char* value);
        inline void set_message(const char* value, size_t size);
        inline ::std::string* mutable_message();
        inline ::std::string* release_message();
        inline void set_allocated_message(::std::string* message);
        
        // required string time_stamp = 5;
        inline bool has_time_stamp() const;
        inline void clear_time_stamp();
        static const int kTimeStampFieldNumber = 5;
        inline const ::std::string& time_stamp() const;
        inline void set_time_stamp(const ::std::string& value);
        inline void set_time_stamp(const char* value);
        inline void set_time_stamp(const char* value, size_t size);
        inline ::std::string* mutable_time_stamp();
        inline ::std::string* release_time_stamp();
        inline void set_allocated_time_stamp(::std::string* time_stamp);
        
        // required string t_avatar = 6;
        inline bool has_t_avatar() const;
        inline void clear_t_avatar();
        static const int kTAvatarFieldNumber = 6;
        inline const ::std::string& t_avatar() const;
        inline void set_t_avatar(const ::std::string& value);
        inline void set_t_avatar(const char* value);
        inline void set_t_avatar(const char* value, size_t size);
        inline ::std::string* mutable_t_avatar();
        inline ::std::string* release_t_avatar();
        inline void set_allocated_t_avatar(::std::string* t_avatar);
        
        // required string t_name = 7;
        inline bool has_t_name() const;
        inline void clear_t_name();
        static const int kTNameFieldNumber = 7;
        inline const ::std::string& t_name() const;
        inline void set_t_name(const ::std::string& value);
        inline void set_t_name(const char* value);
        inline void set_t_name(const char* value, size_t size);
        inline ::std::string* mutable_t_name();
        inline ::std::string* release_t_name();
        inline void set_allocated_t_name(::std::string* t_name);
        
        // required string t_leve = 8;
        inline bool has_t_leve() const;
        inline void clear_t_leve();
        static const int kTLeveFieldNumber = 8;
        inline const ::std::string& t_leve() const;
        inline void set_t_leve(const ::std::string& value);
        inline void set_t_leve(const char* value);
        inline void set_t_leve(const char* value, size_t size);
        inline ::std::string* mutable_t_leve();
        inline ::std::string* release_t_leve();
        inline void set_allocated_t_leve(::std::string* t_leve);
        
        // required string t_user_type = 9;
        inline bool has_t_user_type() const;
        inline void clear_t_user_type();
        static const int kTUserTypeFieldNumber = 9;
        inline const ::std::string& t_user_type() const;
        inline void set_t_user_type(const ::std::string& value);
        inline void set_t_user_type(const char* value);
        inline void set_t_user_type(const char* value, size_t size);
        inline ::std::string* mutable_t_user_type();
        inline ::std::string* release_t_user_type();
        inline void set_allocated_t_user_type(::std::string* t_user_type);
        
        // required string m_avatar = 10;
        inline bool has_m_avatar() const;
        inline void clear_m_avatar();
        static const int kMAvatarFieldNumber = 10;
        inline const ::std::string& m_avatar() const;
        inline void set_m_avatar(const ::std::string& value);
        inline void set_m_avatar(const char* value);
        inline void set_m_avatar(const char* value, size_t size);
        inline ::std::string* mutable_m_avatar();
        inline ::std::string* release_m_avatar();
        inline void set_allocated_m_avatar(::std::string* m_avatar);
        
        // required string m_name = 11;
        inline bool has_m_name() const;
        inline void clear_m_name();
        static const int kMNameFieldNumber = 11;
        inline const ::std::string& m_name() const;
        inline void set_m_name(const ::std::string& value);
        inline void set_m_name(const char* value);
        inline void set_m_name(const char* value, size_t size);
        inline ::std::string* mutable_m_name();
        inline ::std::string* release_m_name();
        inline void set_allocated_m_name(::std::string* m_name);
        
        // required string m_leve = 12;
        inline bool has_m_leve() const;
        inline void clear_m_leve();
        static const int kMLeveFieldNumber = 12;
        inline const ::std::string& m_leve() const;
        inline void set_m_leve(const ::std::string& value);
        inline void set_m_leve(const char* value);
        inline void set_m_leve(const char* value, size_t size);
        inline ::std::string* mutable_m_leve();
        inline ::std::string* release_m_leve();
        inline void set_allocated_m_leve(::std::string* m_leve);
        
        // required string m_user_type = 13;
        inline bool has_m_user_type() const;
        inline void clear_m_user_type();
        static const int kMUserTypeFieldNumber = 13;
        inline const ::std::string& m_user_type() const;
        inline void set_m_user_type(const ::std::string& value);
        inline void set_m_user_type(const char* value);
        inline void set_m_user_type(const char* value, size_t size);
        inline ::std::string* mutable_m_user_type();
        inline ::std::string* release_m_user_type();
        inline void set_allocated_m_user_type(::std::string* m_user_type);
        
        // optional string device_udid = 14;
        inline bool has_device_udid() const;
        inline void clear_device_udid();
        static const int kDeviceUdidFieldNumber = 14;
        inline const ::std::string& device_udid() const;
        inline void set_device_udid(const ::std::string& value);
        inline void set_device_udid(const char* value);
        inline void set_device_udid(const char* value, size_t size);
        inline ::std::string* mutable_device_udid();
        inline ::std::string* release_device_udid();
        inline void set_allocated_device_udid(::std::string* device_udid);
        
        // @@protoc_insertion_point(class_scope:QSChat.QuestionWord)
    private:
        inline void set_has_mid();
        inline void clear_has_mid();
        inline void set_has_tid();
        inline void clear_has_tid();
        inline void set_has_ctype();
        inline void clear_has_ctype();
        inline void set_has_message();
        inline void clear_has_message();
        inline void set_has_time_stamp();
        inline void clear_has_time_stamp();
        inline void set_has_t_avatar();
        inline void clear_has_t_avatar();
        inline void set_has_t_name();
        inline void clear_has_t_name();
        inline void set_has_t_leve();
        inline void clear_has_t_leve();
        inline void set_has_t_user_type();
        inline void clear_has_t_user_type();
        inline void set_has_m_avatar();
        inline void clear_has_m_avatar();
        inline void set_has_m_name();
        inline void clear_has_m_name();
        inline void set_has_m_leve();
        inline void clear_has_m_leve();
        inline void set_has_m_user_type();
        inline void clear_has_m_user_type();
        inline void set_has_device_udid();
        inline void clear_has_device_udid();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int64 mid_;
        ::google::protobuf::int64 tid_;
        ::std::string* message_;
        ::std::string* time_stamp_;
        ::std::string* t_avatar_;
        ::std::string* t_name_;
        ::std::string* t_leve_;
        ::std::string* t_user_type_;
        ::std::string* m_avatar_;
        ::std::string* m_name_;
        ::std::string* m_leve_;
        ::std::string* m_user_type_;
        ::std::string* device_udid_;
        int ctype_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static QuestionWord* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class QuestionPic : public ::google::protobuf::Message {
    public:
        QuestionPic();
        virtual ~QuestionPic();
        
        QuestionPic(const QuestionPic& from);
        
        inline QuestionPic& operator=(const QuestionPic& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const QuestionPic& default_instance();
        
        void Swap(QuestionPic* other);
        
        // implements Message ----------------------------------------------
        
        QuestionPic* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const QuestionPic& from);
        void MergeFrom(const QuestionPic& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required int64 mid = 1;
        inline bool has_mid() const;
        inline void clear_mid();
        static const int kMidFieldNumber = 1;
        inline ::google::protobuf::int64 mid() const;
        inline void set_mid(::google::protobuf::int64 value);
        
        // required int64 tid = 2;
        inline bool has_tid() const;
        inline void clear_tid();
        static const int kTidFieldNumber = 2;
        inline ::google::protobuf::int64 tid() const;
        inline void set_tid(::google::protobuf::int64 value);
        
        // required .QSChat.ChatRequestType ctype = 3;
        inline bool has_ctype() const;
        inline void clear_ctype();
        static const int kCtypeFieldNumber = 3;
        inline ::QSChat::ChatRequestType ctype() const;
        inline void set_ctype(::QSChat::ChatRequestType value);
        
        // required bytes pic = 4;
        inline bool has_pic() const;
        inline void clear_pic();
        static const int kPicFieldNumber = 4;
        inline const ::std::string& pic() const;
        inline void set_pic(const ::std::string& value);
        inline void set_pic(const char* value);
        inline void set_pic(const void* value, size_t size);
        inline ::std::string* mutable_pic();
        inline ::std::string* release_pic();
        inline void set_allocated_pic(::std::string* pic);
        
        // required string time_stamp = 5;
        inline bool has_time_stamp() const;
        inline void clear_time_stamp();
        static const int kTimeStampFieldNumber = 5;
        inline const ::std::string& time_stamp() const;
        inline void set_time_stamp(const ::std::string& value);
        inline void set_time_stamp(const char* value);
        inline void set_time_stamp(const char* value, size_t size);
        inline ::std::string* mutable_time_stamp();
        inline ::std::string* release_time_stamp();
        inline void set_allocated_time_stamp(::std::string* time_stamp);
        
        // required string t_avatar = 6;
        inline bool has_t_avatar() const;
        inline void clear_t_avatar();
        static const int kTAvatarFieldNumber = 6;
        inline const ::std::string& t_avatar() const;
        inline void set_t_avatar(const ::std::string& value);
        inline void set_t_avatar(const char* value);
        inline void set_t_avatar(const char* value, size_t size);
        inline ::std::string* mutable_t_avatar();
        inline ::std::string* release_t_avatar();
        inline void set_allocated_t_avatar(::std::string* t_avatar);
        
        // required string t_name = 7;
        inline bool has_t_name() const;
        inline void clear_t_name();
        static const int kTNameFieldNumber = 7;
        inline const ::std::string& t_name() const;
        inline void set_t_name(const ::std::string& value);
        inline void set_t_name(const char* value);
        inline void set_t_name(const char* value, size_t size);
        inline ::std::string* mutable_t_name();
        inline ::std::string* release_t_name();
        inline void set_allocated_t_name(::std::string* t_name);
        
        // required string t_leve = 8;
        inline bool has_t_leve() const;
        inline void clear_t_leve();
        static const int kTLeveFieldNumber = 8;
        inline const ::std::string& t_leve() const;
        inline void set_t_leve(const ::std::string& value);
        inline void set_t_leve(const char* value);
        inline void set_t_leve(const char* value, size_t size);
        inline ::std::string* mutable_t_leve();
        inline ::std::string* release_t_leve();
        inline void set_allocated_t_leve(::std::string* t_leve);
        
        // required string t_user_type = 9;
        inline bool has_t_user_type() const;
        inline void clear_t_user_type();
        static const int kTUserTypeFieldNumber = 9;
        inline const ::std::string& t_user_type() const;
        inline void set_t_user_type(const ::std::string& value);
        inline void set_t_user_type(const char* value);
        inline void set_t_user_type(const char* value, size_t size);
        inline ::std::string* mutable_t_user_type();
        inline ::std::string* release_t_user_type();
        inline void set_allocated_t_user_type(::std::string* t_user_type);
        
        // required string m_avatar = 10;
        inline bool has_m_avatar() const;
        inline void clear_m_avatar();
        static const int kMAvatarFieldNumber = 10;
        inline const ::std::string& m_avatar() const;
        inline void set_m_avatar(const ::std::string& value);
        inline void set_m_avatar(const char* value);
        inline void set_m_avatar(const char* value, size_t size);
        inline ::std::string* mutable_m_avatar();
        inline ::std::string* release_m_avatar();
        inline void set_allocated_m_avatar(::std::string* m_avatar);
        
        // required string m_name = 11;
        inline bool has_m_name() const;
        inline void clear_m_name();
        static const int kMNameFieldNumber = 11;
        inline const ::std::string& m_name() const;
        inline void set_m_name(const ::std::string& value);
        inline void set_m_name(const char* value);
        inline void set_m_name(const char* value, size_t size);
        inline ::std::string* mutable_m_name();
        inline ::std::string* release_m_name();
        inline void set_allocated_m_name(::std::string* m_name);
        
        // required string m_leve = 12;
        inline bool has_m_leve() const;
        inline void clear_m_leve();
        static const int kMLeveFieldNumber = 12;
        inline const ::std::string& m_leve() const;
        inline void set_m_leve(const ::std::string& value);
        inline void set_m_leve(const char* value);
        inline void set_m_leve(const char* value, size_t size);
        inline ::std::string* mutable_m_leve();
        inline ::std::string* release_m_leve();
        inline void set_allocated_m_leve(::std::string* m_leve);
        
        // required string m_user_type = 13;
        inline bool has_m_user_type() const;
        inline void clear_m_user_type();
        static const int kMUserTypeFieldNumber = 13;
        inline const ::std::string& m_user_type() const;
        inline void set_m_user_type(const ::std::string& value);
        inline void set_m_user_type(const char* value);
        inline void set_m_user_type(const char* value, size_t size);
        inline ::std::string* mutable_m_user_type();
        inline ::std::string* release_m_user_type();
        inline void set_allocated_m_user_type(::std::string* m_user_type);
        
        // optional string device_udid = 14;
        inline bool has_device_udid() const;
        inline void clear_device_udid();
        static const int kDeviceUdidFieldNumber = 14;
        inline const ::std::string& device_udid() const;
        inline void set_device_udid(const ::std::string& value);
        inline void set_device_udid(const char* value);
        inline void set_device_udid(const char* value, size_t size);
        inline ::std::string* mutable_device_udid();
        inline ::std::string* release_device_udid();
        inline void set_allocated_device_udid(::std::string* device_udid);
        
        // @@protoc_insertion_point(class_scope:QSChat.QuestionPic)
    private:
        inline void set_has_mid();
        inline void clear_has_mid();
        inline void set_has_tid();
        inline void clear_has_tid();
        inline void set_has_ctype();
        inline void clear_has_ctype();
        inline void set_has_pic();
        inline void clear_has_pic();
        inline void set_has_time_stamp();
        inline void clear_has_time_stamp();
        inline void set_has_t_avatar();
        inline void clear_has_t_avatar();
        inline void set_has_t_name();
        inline void clear_has_t_name();
        inline void set_has_t_leve();
        inline void clear_has_t_leve();
        inline void set_has_t_user_type();
        inline void clear_has_t_user_type();
        inline void set_has_m_avatar();
        inline void clear_has_m_avatar();
        inline void set_has_m_name();
        inline void clear_has_m_name();
        inline void set_has_m_leve();
        inline void clear_has_m_leve();
        inline void set_has_m_user_type();
        inline void clear_has_m_user_type();
        inline void set_has_device_udid();
        inline void clear_has_device_udid();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int64 mid_;
        ::google::protobuf::int64 tid_;
        ::std::string* pic_;
        ::std::string* time_stamp_;
        ::std::string* t_avatar_;
        ::std::string* t_name_;
        ::std::string* t_leve_;
        ::std::string* t_user_type_;
        ::std::string* m_avatar_;
        ::std::string* m_name_;
        ::std::string* m_leve_;
        ::std::string* m_user_type_;
        ::std::string* device_udid_;
        int ctype_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static QuestionPic* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class QuestionVideo : public ::google::protobuf::Message {
    public:
        QuestionVideo();
        virtual ~QuestionVideo();
        
        QuestionVideo(const QuestionVideo& from);
        
        inline QuestionVideo& operator=(const QuestionVideo& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const QuestionVideo& default_instance();
        
        void Swap(QuestionVideo* other);
        
        // implements Message ----------------------------------------------
        
        QuestionVideo* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const QuestionVideo& from);
        void MergeFrom(const QuestionVideo& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required int64 mid = 1;
        inline bool has_mid() const;
        inline void clear_mid();
        static const int kMidFieldNumber = 1;
        inline ::google::protobuf::int64 mid() const;
        inline void set_mid(::google::protobuf::int64 value);
        
        // required int64 tid = 2;
        inline bool has_tid() const;
        inline void clear_tid();
        static const int kTidFieldNumber = 2;
        inline ::google::protobuf::int64 tid() const;
        inline void set_tid(::google::protobuf::int64 value);
        
        // required .QSChat.ChatRequestType ctype = 3;
        inline bool has_ctype() const;
        inline void clear_ctype();
        static const int kCtypeFieldNumber = 3;
        inline ::QSChat::ChatRequestType ctype() const;
        inline void set_ctype(::QSChat::ChatRequestType value);
        
        // required bytes video = 4;
        inline bool has_video() const;
        inline void clear_video();
        static const int kVideoFieldNumber = 4;
        inline const ::std::string& video() const;
        inline void set_video(const ::std::string& value);
        inline void set_video(const char* value);
        inline void set_video(const void* value, size_t size);
        inline ::std::string* mutable_video();
        inline ::std::string* release_video();
        inline void set_allocated_video(::std::string* video);
        
        // required string time_stamp = 5;
        inline bool has_time_stamp() const;
        inline void clear_time_stamp();
        static const int kTimeStampFieldNumber = 5;
        inline const ::std::string& time_stamp() const;
        inline void set_time_stamp(const ::std::string& value);
        inline void set_time_stamp(const char* value);
        inline void set_time_stamp(const char* value, size_t size);
        inline ::std::string* mutable_time_stamp();
        inline ::std::string* release_time_stamp();
        inline void set_allocated_time_stamp(::std::string* time_stamp);
        
        // required string t_avatar = 6;
        inline bool has_t_avatar() const;
        inline void clear_t_avatar();
        static const int kTAvatarFieldNumber = 6;
        inline const ::std::string& t_avatar() const;
        inline void set_t_avatar(const ::std::string& value);
        inline void set_t_avatar(const char* value);
        inline void set_t_avatar(const char* value, size_t size);
        inline ::std::string* mutable_t_avatar();
        inline ::std::string* release_t_avatar();
        inline void set_allocated_t_avatar(::std::string* t_avatar);
        
        // required string t_name = 7;
        inline bool has_t_name() const;
        inline void clear_t_name();
        static const int kTNameFieldNumber = 7;
        inline const ::std::string& t_name() const;
        inline void set_t_name(const ::std::string& value);
        inline void set_t_name(const char* value);
        inline void set_t_name(const char* value, size_t size);
        inline ::std::string* mutable_t_name();
        inline ::std::string* release_t_name();
        inline void set_allocated_t_name(::std::string* t_name);
        
        // required string t_leve = 8;
        inline bool has_t_leve() const;
        inline void clear_t_leve();
        static const int kTLeveFieldNumber = 8;
        inline const ::std::string& t_leve() const;
        inline void set_t_leve(const ::std::string& value);
        inline void set_t_leve(const char* value);
        inline void set_t_leve(const char* value, size_t size);
        inline ::std::string* mutable_t_leve();
        inline ::std::string* release_t_leve();
        inline void set_allocated_t_leve(::std::string* t_leve);
        
        // required string t_user_type = 9;
        inline bool has_t_user_type() const;
        inline void clear_t_user_type();
        static const int kTUserTypeFieldNumber = 9;
        inline const ::std::string& t_user_type() const;
        inline void set_t_user_type(const ::std::string& value);
        inline void set_t_user_type(const char* value);
        inline void set_t_user_type(const char* value, size_t size);
        inline ::std::string* mutable_t_user_type();
        inline ::std::string* release_t_user_type();
        inline void set_allocated_t_user_type(::std::string* t_user_type);
        
        // required string m_avatar = 10;
        inline bool has_m_avatar() const;
        inline void clear_m_avatar();
        static const int kMAvatarFieldNumber = 10;
        inline const ::std::string& m_avatar() const;
        inline void set_m_avatar(const ::std::string& value);
        inline void set_m_avatar(const char* value);
        inline void set_m_avatar(const char* value, size_t size);
        inline ::std::string* mutable_m_avatar();
        inline ::std::string* release_m_avatar();
        inline void set_allocated_m_avatar(::std::string* m_avatar);
        
        // required string m_name = 11;
        inline bool has_m_name() const;
        inline void clear_m_name();
        static const int kMNameFieldNumber = 11;
        inline const ::std::string& m_name() const;
        inline void set_m_name(const ::std::string& value);
        inline void set_m_name(const char* value);
        inline void set_m_name(const char* value, size_t size);
        inline ::std::string* mutable_m_name();
        inline ::std::string* release_m_name();
        inline void set_allocated_m_name(::std::string* m_name);
        
        // required string m_leve = 12;
        inline bool has_m_leve() const;
        inline void clear_m_leve();
        static const int kMLeveFieldNumber = 12;
        inline const ::std::string& m_leve() const;
        inline void set_m_leve(const ::std::string& value);
        inline void set_m_leve(const char* value);
        inline void set_m_leve(const char* value, size_t size);
        inline ::std::string* mutable_m_leve();
        inline ::std::string* release_m_leve();
        inline void set_allocated_m_leve(::std::string* m_leve);
        
        // required string m_user_type = 13;
        inline bool has_m_user_type() const;
        inline void clear_m_user_type();
        static const int kMUserTypeFieldNumber = 13;
        inline const ::std::string& m_user_type() const;
        inline void set_m_user_type(const ::std::string& value);
        inline void set_m_user_type(const char* value);
        inline void set_m_user_type(const char* value, size_t size);
        inline ::std::string* mutable_m_user_type();
        inline ::std::string* release_m_user_type();
        inline void set_allocated_m_user_type(::std::string* m_user_type);
        
        // optional string device_udid = 14;
        inline bool has_device_udid() const;
        inline void clear_device_udid();
        static const int kDeviceUdidFieldNumber = 14;
        inline const ::std::string& device_udid() const;
        inline void set_device_udid(const ::std::string& value);
        inline void set_device_udid(const char* value);
        inline void set_device_udid(const char* value, size_t size);
        inline ::std::string* mutable_device_udid();
        inline ::std::string* release_device_udid();
        inline void set_allocated_device_udid(::std::string* device_udid);
        
        // @@protoc_insertion_point(class_scope:QSChat.QuestionVideo)
    private:
        inline void set_has_mid();
        inline void clear_has_mid();
        inline void set_has_tid();
        inline void clear_has_tid();
        inline void set_has_ctype();
        inline void clear_has_ctype();
        inline void set_has_video();
        inline void clear_has_video();
        inline void set_has_time_stamp();
        inline void clear_has_time_stamp();
        inline void set_has_t_avatar();
        inline void clear_has_t_avatar();
        inline void set_has_t_name();
        inline void clear_has_t_name();
        inline void set_has_t_leve();
        inline void clear_has_t_leve();
        inline void set_has_t_user_type();
        inline void clear_has_t_user_type();
        inline void set_has_m_avatar();
        inline void clear_has_m_avatar();
        inline void set_has_m_name();
        inline void clear_has_m_name();
        inline void set_has_m_leve();
        inline void clear_has_m_leve();
        inline void set_has_m_user_type();
        inline void clear_has_m_user_type();
        inline void set_has_device_udid();
        inline void clear_has_device_udid();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int64 mid_;
        ::google::protobuf::int64 tid_;
        ::std::string* video_;
        ::std::string* time_stamp_;
        ::std::string* t_avatar_;
        ::std::string* t_name_;
        ::std::string* t_leve_;
        ::std::string* t_user_type_;
        ::std::string* m_avatar_;
        ::std::string* m_name_;
        ::std::string* m_leve_;
        ::std::string* m_user_type_;
        ::std::string* device_udid_;
        int ctype_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static QuestionVideo* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class QuestionRecommendHouse : public ::google::protobuf::Message {
    public:
        QuestionRecommendHouse();
        virtual ~QuestionRecommendHouse();
        
        QuestionRecommendHouse(const QuestionRecommendHouse& from);
        
        inline QuestionRecommendHouse& operator=(const QuestionRecommendHouse& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const QuestionRecommendHouse& default_instance();
        
        void Swap(QuestionRecommendHouse* other);
        
        // implements Message ----------------------------------------------
        
        QuestionRecommendHouse* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const QuestionRecommendHouse& from);
        void MergeFrom(const QuestionRecommendHouse& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required int64 mid = 1;
        inline bool has_mid() const;
        inline void clear_mid();
        static const int kMidFieldNumber = 1;
        inline ::google::protobuf::int64 mid() const;
        inline void set_mid(::google::protobuf::int64 value);
        
        // required int64 tid = 2;
        inline bool has_tid() const;
        inline void clear_tid();
        static const int kTidFieldNumber = 2;
        inline ::google::protobuf::int64 tid() const;
        inline void set_tid(::google::protobuf::int64 value);
        
        // required .QSChat.ChatRequestType ctype = 3;
        inline bool has_ctype() const;
        inline void clear_ctype();
        static const int kCtypeFieldNumber = 3;
        inline ::QSChat::ChatRequestType ctype() const;
        inline void set_ctype(::QSChat::ChatRequestType value);
        
        // required string house_id = 4;
        inline bool has_house_id() const;
        inline void clear_house_id();
        static const int kHouseIdFieldNumber = 4;
        inline const ::std::string& house_id() const;
        inline void set_house_id(const ::std::string& value);
        inline void set_house_id(const char* value);
        inline void set_house_id(const char* value, size_t size);
        inline ::std::string* mutable_house_id();
        inline ::std::string* release_house_id();
        inline void set_allocated_house_id(::std::string* house_id);
        
        // required string building_id = 5;
        inline bool has_building_id() const;
        inline void clear_building_id();
        static const int kBuildingIdFieldNumber = 5;
        inline const ::std::string& building_id() const;
        inline void set_building_id(const ::std::string& value);
        inline void set_building_id(const char* value);
        inline void set_building_id(const char* value, size_t size);
        inline ::std::string* mutable_building_id();
        inline ::std::string* release_building_id();
        inline void set_allocated_building_id(::std::string* building_id);
        
        // required string house_type = 6;
        inline bool has_house_type() const;
        inline void clear_house_type();
        static const int kHouseTypeFieldNumber = 6;
        inline const ::std::string& house_type() const;
        inline void set_house_type(const ::std::string& value);
        inline void set_house_type(const char* value);
        inline void set_house_type(const char* value, size_t size);
        inline ::std::string* mutable_house_type();
        inline ::std::string* release_house_type();
        inline void set_allocated_house_type(::std::string* house_type);
        
        // required string attach_file = 7;
        inline bool has_attach_file() const;
        inline void clear_attach_file();
        static const int kAttachFileFieldNumber = 7;
        inline const ::std::string& attach_file() const;
        inline void set_attach_file(const ::std::string& value);
        inline void set_attach_file(const char* value);
        inline void set_attach_file(const char* value, size_t size);
        inline ::std::string* mutable_attach_file();
        inline ::std::string* release_attach_file();
        inline void set_allocated_attach_file(::std::string* attach_file);
        
        // required string attach_thumb = 8;
        inline bool has_attach_thumb() const;
        inline void clear_attach_thumb();
        static const int kAttachThumbFieldNumber = 8;
        inline const ::std::string& attach_thumb() const;
        inline void set_attach_thumb(const ::std::string& value);
        inline void set_attach_thumb(const char* value);
        inline void set_attach_thumb(const char* value, size_t size);
        inline ::std::string* mutable_attach_thumb();
        inline ::std::string* release_attach_thumb();
        inline void set_allocated_attach_thumb(::std::string* attach_thumb);
        
        // required string areaid = 9;
        inline bool has_areaid() const;
        inline void clear_areaid();
        static const int kAreaidFieldNumber = 9;
        inline const ::std::string& areaid() const;
        inline void set_areaid(const ::std::string& value);
        inline void set_areaid(const char* value);
        inline void set_areaid(const char* value, size_t size);
        inline ::std::string* mutable_areaid();
        inline ::std::string* release_areaid();
        inline void set_allocated_areaid(::std::string* areaid);
        
        // required string area_val = 10;
        inline bool has_area_val() const;
        inline void clear_area_val();
        static const int kAreaValFieldNumber = 10;
        inline const ::std::string& area_val() const;
        inline void set_area_val(const ::std::string& value);
        inline void set_area_val(const char* value);
        inline void set_area_val(const char* value, size_t size);
        inline ::std::string* mutable_area_val();
        inline ::std::string* release_area_val();
        inline void set_allocated_area_val(::std::string* area_val);
        
        // required string streetid = 11;
        inline bool has_streetid() const;
        inline void clear_streetid();
        static const int kStreetidFieldNumber = 11;
        inline const ::std::string& streetid() const;
        inline void set_streetid(const ::std::string& value);
        inline void set_streetid(const char* value);
        inline void set_streetid(const char* value, size_t size);
        inline ::std::string* mutable_streetid();
        inline ::std::string* release_streetid();
        inline void set_allocated_streetid(::std::string* streetid);
        
        // required string street_val = 12;
        inline bool has_street_val() const;
        inline void clear_street_val();
        static const int kStreetValFieldNumber = 12;
        inline const ::std::string& street_val() const;
        inline void set_street_val(const ::std::string& value);
        inline void set_street_val(const char* value);
        inline void set_street_val(const char* value, size_t size);
        inline ::std::string* mutable_street_val();
        inline ::std::string* release_street_val();
        inline void set_allocated_street_val(::std::string* street_val);
        
        // required string house_shi = 13;
        inline bool has_house_shi() const;
        inline void clear_house_shi();
        static const int kHouseShiFieldNumber = 13;
        inline const ::std::string& house_shi() const;
        inline void set_house_shi(const ::std::string& value);
        inline void set_house_shi(const char* value);
        inline void set_house_shi(const char* value, size_t size);
        inline ::std::string* mutable_house_shi();
        inline ::std::string* release_house_shi();
        inline void set_allocated_house_shi(::std::string* house_shi);
        
        // required string house_ting = 14;
        inline bool has_house_ting() const;
        inline void clear_house_ting();
        static const int kHouseTingFieldNumber = 14;
        inline const ::std::string& house_ting() const;
        inline void set_house_ting(const ::std::string& value);
        inline void set_house_ting(const char* value);
        inline void set_house_ting(const char* value, size_t size);
        inline ::std::string* mutable_house_ting();
        inline ::std::string* release_house_ting();
        inline void set_allocated_house_ting(::std::string* house_ting);
        
        // required string house_area = 15;
        inline bool has_house_area() const;
        inline void clear_house_area();
        static const int kHouseAreaFieldNumber = 15;
        inline const ::std::string& house_area() const;
        inline void set_house_area(const ::std::string& value);
        inline void set_house_area(const char* value);
        inline void set_house_area(const char* value, size_t size);
        inline ::std::string* mutable_house_area();
        inline ::std::string* release_house_area();
        inline void set_allocated_house_area(::std::string* house_area);
        
        // required string house_price = 16;
        inline bool has_house_price() const;
        inline void clear_house_price();
        static const int kHousePriceFieldNumber = 16;
        inline const ::std::string& house_price() const;
        inline void set_house_price(const ::std::string& value);
        inline void set_house_price(const char* value);
        inline void set_house_price(const char* value, size_t size);
        inline ::std::string* mutable_house_price();
        inline ::std::string* release_house_price();
        inline void set_allocated_house_price(::std::string* house_price);
        
        // required string rent_price = 17;
        inline bool has_rent_price() const;
        inline void clear_rent_price();
        static const int kRentPriceFieldNumber = 17;
        inline const ::std::string& rent_price() const;
        inline void set_rent_price(const ::std::string& value);
        inline void set_rent_price(const char* value);
        inline void set_rent_price(const char* value, size_t size);
        inline ::std::string* mutable_rent_price();
        inline ::std::string* release_rent_price();
        inline void set_allocated_rent_price(::std::string* rent_price);
        
        // required string title = 18;
        inline bool has_title() const;
        inline void clear_title();
        static const int kTitleFieldNumber = 18;
        inline const ::std::string& title() const;
        inline void set_title(const ::std::string& value);
        inline void set_title(const char* value);
        inline void set_title(const char* value, size_t size);
        inline ::std::string* mutable_title();
        inline ::std::string* release_title();
        inline void set_allocated_title(::std::string* title);
        
        // required string time_stamp = 19;
        inline bool has_time_stamp() const;
        inline void clear_time_stamp();
        static const int kTimeStampFieldNumber = 19;
        inline const ::std::string& time_stamp() const;
        inline void set_time_stamp(const ::std::string& value);
        inline void set_time_stamp(const char* value);
        inline void set_time_stamp(const char* value, size_t size);
        inline ::std::string* mutable_time_stamp();
        inline ::std::string* release_time_stamp();
        inline void set_allocated_time_stamp(::std::string* time_stamp);
        
        // required string t_avatar = 20;
        inline bool has_t_avatar() const;
        inline void clear_t_avatar();
        static const int kTAvatarFieldNumber = 20;
        inline const ::std::string& t_avatar() const;
        inline void set_t_avatar(const ::std::string& value);
        inline void set_t_avatar(const char* value);
        inline void set_t_avatar(const char* value, size_t size);
        inline ::std::string* mutable_t_avatar();
        inline ::std::string* release_t_avatar();
        inline void set_allocated_t_avatar(::std::string* t_avatar);
        
        // required string t_name = 21;
        inline bool has_t_name() const;
        inline void clear_t_name();
        static const int kTNameFieldNumber = 21;
        inline const ::std::string& t_name() const;
        inline void set_t_name(const ::std::string& value);
        inline void set_t_name(const char* value);
        inline void set_t_name(const char* value, size_t size);
        inline ::std::string* mutable_t_name();
        inline ::std::string* release_t_name();
        inline void set_allocated_t_name(::std::string* t_name);
        
        // required string t_leve = 22;
        inline bool has_t_leve() const;
        inline void clear_t_leve();
        static const int kTLeveFieldNumber = 22;
        inline const ::std::string& t_leve() const;
        inline void set_t_leve(const ::std::string& value);
        inline void set_t_leve(const char* value);
        inline void set_t_leve(const char* value, size_t size);
        inline ::std::string* mutable_t_leve();
        inline ::std::string* release_t_leve();
        inline void set_allocated_t_leve(::std::string* t_leve);
        
        // required string t_user_type = 23;
        inline bool has_t_user_type() const;
        inline void clear_t_user_type();
        static const int kTUserTypeFieldNumber = 23;
        inline const ::std::string& t_user_type() const;
        inline void set_t_user_type(const ::std::string& value);
        inline void set_t_user_type(const char* value);
        inline void set_t_user_type(const char* value, size_t size);
        inline ::std::string* mutable_t_user_type();
        inline ::std::string* release_t_user_type();
        inline void set_allocated_t_user_type(::std::string* t_user_type);
        
        // required string m_avatar = 24;
        inline bool has_m_avatar() const;
        inline void clear_m_avatar();
        static const int kMAvatarFieldNumber = 24;
        inline const ::std::string& m_avatar() const;
        inline void set_m_avatar(const ::std::string& value);
        inline void set_m_avatar(const char* value);
        inline void set_m_avatar(const char* value, size_t size);
        inline ::std::string* mutable_m_avatar();
        inline ::std::string* release_m_avatar();
        inline void set_allocated_m_avatar(::std::string* m_avatar);
        
        // required string m_name = 25;
        inline bool has_m_name() const;
        inline void clear_m_name();
        static const int kMNameFieldNumber = 25;
        inline const ::std::string& m_name() const;
        inline void set_m_name(const ::std::string& value);
        inline void set_m_name(const char* value);
        inline void set_m_name(const char* value, size_t size);
        inline ::std::string* mutable_m_name();
        inline ::std::string* release_m_name();
        inline void set_allocated_m_name(::std::string* m_name);
        
        // required string m_leve = 26;
        inline bool has_m_leve() const;
        inline void clear_m_leve();
        static const int kMLeveFieldNumber = 26;
        inline const ::std::string& m_leve() const;
        inline void set_m_leve(const ::std::string& value);
        inline void set_m_leve(const char* value);
        inline void set_m_leve(const char* value, size_t size);
        inline ::std::string* mutable_m_leve();
        inline ::std::string* release_m_leve();
        inline void set_allocated_m_leve(::std::string* m_leve);
        
        // required string m_user_type = 27;
        inline bool has_m_user_type() const;
        inline void clear_m_user_type();
        static const int kMUserTypeFieldNumber = 27;
        inline const ::std::string& m_user_type() const;
        inline void set_m_user_type(const ::std::string& value);
        inline void set_m_user_type(const char* value);
        inline void set_m_user_type(const char* value, size_t size);
        inline ::std::string* mutable_m_user_type();
        inline ::std::string* release_m_user_type();
        inline void set_allocated_m_user_type(::std::string* m_user_type);
        
        // required string device_udid = 28;
        inline bool has_device_udid() const;
        inline void clear_device_udid();
        static const int kDeviceUdidFieldNumber = 28;
        inline const ::std::string& device_udid() const;
        inline void set_device_udid(const ::std::string& value);
        inline void set_device_udid(const char* value);
        inline void set_device_udid(const char* value, size_t size);
        inline ::std::string* mutable_device_udid();
        inline ::std::string* release_device_udid();
        inline void set_allocated_device_udid(::std::string* device_udid);
        
        // @@protoc_insertion_point(class_scope:QSChat.QuestionRecommendHouse)
    private:
        inline void set_has_mid();
        inline void clear_has_mid();
        inline void set_has_tid();
        inline void clear_has_tid();
        inline void set_has_ctype();
        inline void clear_has_ctype();
        inline void set_has_house_id();
        inline void clear_has_house_id();
        inline void set_has_building_id();
        inline void clear_has_building_id();
        inline void set_has_house_type();
        inline void clear_has_house_type();
        inline void set_has_attach_file();
        inline void clear_has_attach_file();
        inline void set_has_attach_thumb();
        inline void clear_has_attach_thumb();
        inline void set_has_areaid();
        inline void clear_has_areaid();
        inline void set_has_area_val();
        inline void clear_has_area_val();
        inline void set_has_streetid();
        inline void clear_has_streetid();
        inline void set_has_street_val();
        inline void clear_has_street_val();
        inline void set_has_house_shi();
        inline void clear_has_house_shi();
        inline void set_has_house_ting();
        inline void clear_has_house_ting();
        inline void set_has_house_area();
        inline void clear_has_house_area();
        inline void set_has_house_price();
        inline void clear_has_house_price();
        inline void set_has_rent_price();
        inline void clear_has_rent_price();
        inline void set_has_title();
        inline void clear_has_title();
        inline void set_has_time_stamp();
        inline void clear_has_time_stamp();
        inline void set_has_t_avatar();
        inline void clear_has_t_avatar();
        inline void set_has_t_name();
        inline void clear_has_t_name();
        inline void set_has_t_leve();
        inline void clear_has_t_leve();
        inline void set_has_t_user_type();
        inline void clear_has_t_user_type();
        inline void set_has_m_avatar();
        inline void clear_has_m_avatar();
        inline void set_has_m_name();
        inline void clear_has_m_name();
        inline void set_has_m_leve();
        inline void clear_has_m_leve();
        inline void set_has_m_user_type();
        inline void clear_has_m_user_type();
        inline void set_has_device_udid();
        inline void clear_has_device_udid();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int64 mid_;
        ::google::protobuf::int64 tid_;
        ::std::string* house_id_;
        ::std::string* building_id_;
        ::std::string* house_type_;
        ::std::string* attach_file_;
        ::std::string* attach_thumb_;
        ::std::string* areaid_;
        ::std::string* area_val_;
        ::std::string* streetid_;
        ::std::string* street_val_;
        ::std::string* house_shi_;
        ::std::string* house_ting_;
        ::std::string* house_area_;
        ::std::string* house_price_;
        ::std::string* rent_price_;
        ::std::string* title_;
        ::std::string* time_stamp_;
        ::std::string* t_avatar_;
        ::std::string* t_name_;
        ::std::string* t_leve_;
        ::std::string* t_user_type_;
        ::std::string* m_avatar_;
        ::std::string* m_name_;
        ::std::string* m_leve_;
        ::std::string* m_user_type_;
        ::std::string* device_udid_;
        int ctype_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static QuestionRecommendHouse* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class AnswerWord : public ::google::protobuf::Message {
    public:
        AnswerWord();
        virtual ~AnswerWord();
        
        AnswerWord(const AnswerWord& from);
        
        inline AnswerWord& operator=(const AnswerWord& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const AnswerWord& default_instance();
        
        void Swap(AnswerWord* other);
        
        // implements Message ----------------------------------------------
        
        AnswerWord* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const AnswerWord& from);
        void MergeFrom(const AnswerWord& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required string result = 1;
        inline bool has_result() const;
        inline void clear_result();
        static const int kResultFieldNumber = 1;
        inline const ::std::string& result() const;
        inline void set_result(const ::std::string& value);
        inline void set_result(const char* value);
        inline void set_result(const char* value, size_t size);
        inline ::std::string* mutable_result();
        inline ::std::string* release_result();
        inline void set_allocated_result(::std::string* result);
        
        // required string message = 2;
        inline bool has_message() const;
        inline void clear_message();
        static const int kMessageFieldNumber = 2;
        inline const ::std::string& message() const;
        inline void set_message(const ::std::string& value);
        inline void set_message(const char* value);
        inline void set_message(const char* value, size_t size);
        inline ::std::string* mutable_message();
        inline ::std::string* release_message();
        inline void set_allocated_message(::std::string* message);
        
        // required string msg_id = 3;
        inline bool has_msg_id() const;
        inline void clear_msg_id();
        static const int kMsgIdFieldNumber = 3;
        inline const ::std::string& msg_id() const;
        inline void set_msg_id(const ::std::string& value);
        inline void set_msg_id(const char* value);
        inline void set_msg_id(const char* value, size_t size);
        inline ::std::string* mutable_msg_id();
        inline ::std::string* release_msg_id();
        inline void set_allocated_msg_id(::std::string* msg_id);
        
        // required string time_stamp = 4;
        inline bool has_time_stamp() const;
        inline void clear_time_stamp();
        static const int kTimeStampFieldNumber = 4;
        inline const ::std::string& time_stamp() const;
        inline void set_time_stamp(const ::std::string& value);
        inline void set_time_stamp(const char* value);
        inline void set_time_stamp(const char* value, size_t size);
        inline ::std::string* mutable_time_stamp();
        inline ::std::string* release_time_stamp();
        inline void set_allocated_time_stamp(::std::string* time_stamp);
        
        // required int64 fid = 5;
        inline bool has_fid() const;
        inline void clear_fid();
        static const int kFidFieldNumber = 5;
        inline ::google::protobuf::int64 fid() const;
        inline void set_fid(::google::protobuf::int64 value);
        
        // required string f_avatar = 6;
        inline bool has_f_avatar() const;
        inline void clear_f_avatar();
        static const int kFAvatarFieldNumber = 6;
        inline const ::std::string& f_avatar() const;
        inline void set_f_avatar(const ::std::string& value);
        inline void set_f_avatar(const char* value);
        inline void set_f_avatar(const char* value, size_t size);
        inline ::std::string* mutable_f_avatar();
        inline ::std::string* release_f_avatar();
        inline void set_allocated_f_avatar(::std::string* f_avatar);
        
        // required string f_name = 7;
        inline bool has_f_name() const;
        inline void clear_f_name();
        static const int kFNameFieldNumber = 7;
        inline const ::std::string& f_name() const;
        inline void set_f_name(const ::std::string& value);
        inline void set_f_name(const char* value);
        inline void set_f_name(const char* value, size_t size);
        inline ::std::string* mutable_f_name();
        inline ::std::string* release_f_name();
        inline void set_allocated_f_name(::std::string* f_name);
        
        // required string f_leve = 8;
        inline bool has_f_leve() const;
        inline void clear_f_leve();
        static const int kFLeveFieldNumber = 8;
        inline const ::std::string& f_leve() const;
        inline void set_f_leve(const ::std::string& value);
        inline void set_f_leve(const char* value);
        inline void set_f_leve(const char* value, size_t size);
        inline ::std::string* mutable_f_leve();
        inline ::std::string* release_f_leve();
        inline void set_allocated_f_leve(::std::string* f_leve);
        
        // required string f_user_type = 9;
        inline bool has_f_user_type() const;
        inline void clear_f_user_type();
        static const int kFUserTypeFieldNumber = 9;
        inline const ::std::string& f_user_type() const;
        inline void set_f_user_type(const ::std::string& value);
        inline void set_f_user_type(const char* value);
        inline void set_f_user_type(const char* value, size_t size);
        inline ::std::string* mutable_f_user_type();
        inline ::std::string* release_f_user_type();
        inline void set_allocated_f_user_type(::std::string* f_user_type);
        
        // required string f_unread_count = 10;
        inline bool has_f_unread_count() const;
        inline void clear_f_unread_count();
        static const int kFUnreadCountFieldNumber = 10;
        inline const ::std::string& f_unread_count() const;
        inline void set_f_unread_count(const ::std::string& value);
        inline void set_f_unread_count(const char* value);
        inline void set_f_unread_count(const char* value, size_t size);
        inline ::std::string* mutable_f_unread_count();
        inline ::std::string* release_f_unread_count();
        inline void set_allocated_f_unread_count(::std::string* f_unread_count);
        
        // required string device_udid = 11;
        inline bool has_device_udid() const;
        inline void clear_device_udid();
        static const int kDeviceUdidFieldNumber = 11;
        inline const ::std::string& device_udid() const;
        inline void set_device_udid(const ::std::string& value);
        inline void set_device_udid(const char* value);
        inline void set_device_udid(const char* value, size_t size);
        inline ::std::string* mutable_device_udid();
        inline ::std::string* release_device_udid();
        inline void set_allocated_device_udid(::std::string* device_udid);
        
        // @@protoc_insertion_point(class_scope:QSChat.AnswerWord)
    private:
        inline void set_has_result();
        inline void clear_has_result();
        inline void set_has_message();
        inline void clear_has_message();
        inline void set_has_msg_id();
        inline void clear_has_msg_id();
        inline void set_has_time_stamp();
        inline void clear_has_time_stamp();
        inline void set_has_fid();
        inline void clear_has_fid();
        inline void set_has_f_avatar();
        inline void clear_has_f_avatar();
        inline void set_has_f_name();
        inline void clear_has_f_name();
        inline void set_has_f_leve();
        inline void clear_has_f_leve();
        inline void set_has_f_user_type();
        inline void clear_has_f_user_type();
        inline void set_has_f_unread_count();
        inline void clear_has_f_unread_count();
        inline void set_has_device_udid();
        inline void clear_has_device_udid();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string* result_;
        ::std::string* message_;
        ::std::string* msg_id_;
        ::std::string* time_stamp_;
        ::google::protobuf::int64 fid_;
        ::std::string* f_avatar_;
        ::std::string* f_name_;
        ::std::string* f_leve_;
        ::std::string* f_user_type_;
        ::std::string* f_unread_count_;
        ::std::string* device_udid_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static AnswerWord* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class AnswerPic : public ::google::protobuf::Message {
    public:
        AnswerPic();
        virtual ~AnswerPic();
        
        AnswerPic(const AnswerPic& from);
        
        inline AnswerPic& operator=(const AnswerPic& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const AnswerPic& default_instance();
        
        void Swap(AnswerPic* other);
        
        // implements Message ----------------------------------------------
        
        AnswerPic* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const AnswerPic& from);
        void MergeFrom(const AnswerPic& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required string result = 1;
        inline bool has_result() const;
        inline void clear_result();
        static const int kResultFieldNumber = 1;
        inline const ::std::string& result() const;
        inline void set_result(const ::std::string& value);
        inline void set_result(const char* value);
        inline void set_result(const char* value, size_t size);
        inline ::std::string* mutable_result();
        inline ::std::string* release_result();
        inline void set_allocated_result(::std::string* result);
        
        // required bytes pic = 2;
        inline bool has_pic() const;
        inline void clear_pic();
        static const int kPicFieldNumber = 2;
        inline const ::std::string& pic() const;
        inline void set_pic(const ::std::string& value);
        inline void set_pic(const char* value);
        inline void set_pic(const void* value, size_t size);
        inline ::std::string* mutable_pic();
        inline ::std::string* release_pic();
        inline void set_allocated_pic(::std::string* pic);
        
        // required string msg_id = 3;
        inline bool has_msg_id() const;
        inline void clear_msg_id();
        static const int kMsgIdFieldNumber = 3;
        inline const ::std::string& msg_id() const;
        inline void set_msg_id(const ::std::string& value);
        inline void set_msg_id(const char* value);
        inline void set_msg_id(const char* value, size_t size);
        inline ::std::string* mutable_msg_id();
        inline ::std::string* release_msg_id();
        inline void set_allocated_msg_id(::std::string* msg_id);
        
        // required string time_stamp = 4;
        inline bool has_time_stamp() const;
        inline void clear_time_stamp();
        static const int kTimeStampFieldNumber = 4;
        inline const ::std::string& time_stamp() const;
        inline void set_time_stamp(const ::std::string& value);
        inline void set_time_stamp(const char* value);
        inline void set_time_stamp(const char* value, size_t size);
        inline ::std::string* mutable_time_stamp();
        inline ::std::string* release_time_stamp();
        inline void set_allocated_time_stamp(::std::string* time_stamp);
        
        // required int64 fid = 5;
        inline bool has_fid() const;
        inline void clear_fid();
        static const int kFidFieldNumber = 5;
        inline ::google::protobuf::int64 fid() const;
        inline void set_fid(::google::protobuf::int64 value);
        
        // required string f_avatar = 6;
        inline bool has_f_avatar() const;
        inline void clear_f_avatar();
        static const int kFAvatarFieldNumber = 6;
        inline const ::std::string& f_avatar() const;
        inline void set_f_avatar(const ::std::string& value);
        inline void set_f_avatar(const char* value);
        inline void set_f_avatar(const char* value, size_t size);
        inline ::std::string* mutable_f_avatar();
        inline ::std::string* release_f_avatar();
        inline void set_allocated_f_avatar(::std::string* f_avatar);
        
        // required string f_name = 7;
        inline bool has_f_name() const;
        inline void clear_f_name();
        static const int kFNameFieldNumber = 7;
        inline const ::std::string& f_name() const;
        inline void set_f_name(const ::std::string& value);
        inline void set_f_name(const char* value);
        inline void set_f_name(const char* value, size_t size);
        inline ::std::string* mutable_f_name();
        inline ::std::string* release_f_name();
        inline void set_allocated_f_name(::std::string* f_name);
        
        // required string f_leve = 8;
        inline bool has_f_leve() const;
        inline void clear_f_leve();
        static const int kFLeveFieldNumber = 8;
        inline const ::std::string& f_leve() const;
        inline void set_f_leve(const ::std::string& value);
        inline void set_f_leve(const char* value);
        inline void set_f_leve(const char* value, size_t size);
        inline ::std::string* mutable_f_leve();
        inline ::std::string* release_f_leve();
        inline void set_allocated_f_leve(::std::string* f_leve);
        
        // required string f_user_type = 9;
        inline bool has_f_user_type() const;
        inline void clear_f_user_type();
        static const int kFUserTypeFieldNumber = 9;
        inline const ::std::string& f_user_type() const;
        inline void set_f_user_type(const ::std::string& value);
        inline void set_f_user_type(const char* value);
        inline void set_f_user_type(const char* value, size_t size);
        inline ::std::string* mutable_f_user_type();
        inline ::std::string* release_f_user_type();
        inline void set_allocated_f_user_type(::std::string* f_user_type);
        
        // required string f_unread_count = 10;
        inline bool has_f_unread_count() const;
        inline void clear_f_unread_count();
        static const int kFUnreadCountFieldNumber = 10;
        inline const ::std::string& f_unread_count() const;
        inline void set_f_unread_count(const ::std::string& value);
        inline void set_f_unread_count(const char* value);
        inline void set_f_unread_count(const char* value, size_t size);
        inline ::std::string* mutable_f_unread_count();
        inline ::std::string* release_f_unread_count();
        inline void set_allocated_f_unread_count(::std::string* f_unread_count);
        
        // required string device_udid = 11;
        inline bool has_device_udid() const;
        inline void clear_device_udid();
        static const int kDeviceUdidFieldNumber = 11;
        inline const ::std::string& device_udid() const;
        inline void set_device_udid(const ::std::string& value);
        inline void set_device_udid(const char* value);
        inline void set_device_udid(const char* value, size_t size);
        inline ::std::string* mutable_device_udid();
        inline ::std::string* release_device_udid();
        inline void set_allocated_device_udid(::std::string* device_udid);
        
        // @@protoc_insertion_point(class_scope:QSChat.AnswerPic)
    private:
        inline void set_has_result();
        inline void clear_has_result();
        inline void set_has_pic();
        inline void clear_has_pic();
        inline void set_has_msg_id();
        inline void clear_has_msg_id();
        inline void set_has_time_stamp();
        inline void clear_has_time_stamp();
        inline void set_has_fid();
        inline void clear_has_fid();
        inline void set_has_f_avatar();
        inline void clear_has_f_avatar();
        inline void set_has_f_name();
        inline void clear_has_f_name();
        inline void set_has_f_leve();
        inline void clear_has_f_leve();
        inline void set_has_f_user_type();
        inline void clear_has_f_user_type();
        inline void set_has_f_unread_count();
        inline void clear_has_f_unread_count();
        inline void set_has_device_udid();
        inline void clear_has_device_udid();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string* result_;
        ::std::string* pic_;
        ::std::string* msg_id_;
        ::std::string* time_stamp_;
        ::google::protobuf::int64 fid_;
        ::std::string* f_avatar_;
        ::std::string* f_name_;
        ::std::string* f_leve_;
        ::std::string* f_user_type_;
        ::std::string* f_unread_count_;
        ::std::string* device_udid_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static AnswerPic* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class AnswerVideo : public ::google::protobuf::Message {
    public:
        AnswerVideo();
        virtual ~AnswerVideo();
        
        AnswerVideo(const AnswerVideo& from);
        
        inline AnswerVideo& operator=(const AnswerVideo& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const AnswerVideo& default_instance();
        
        void Swap(AnswerVideo* other);
        
        // implements Message ----------------------------------------------
        
        AnswerVideo* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const AnswerVideo& from);
        void MergeFrom(const AnswerVideo& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required string result = 1;
        inline bool has_result() const;
        inline void clear_result();
        static const int kResultFieldNumber = 1;
        inline const ::std::string& result() const;
        inline void set_result(const ::std::string& value);
        inline void set_result(const char* value);
        inline void set_result(const char* value, size_t size);
        inline ::std::string* mutable_result();
        inline ::std::string* release_result();
        inline void set_allocated_result(::std::string* result);
        
        // required bytes video = 2;
        inline bool has_video() const;
        inline void clear_video();
        static const int kVideoFieldNumber = 2;
        inline const ::std::string& video() const;
        inline void set_video(const ::std::string& value);
        inline void set_video(const char* value);
        inline void set_video(const void* value, size_t size);
        inline ::std::string* mutable_video();
        inline ::std::string* release_video();
        inline void set_allocated_video(::std::string* video);
        
        // required string msg_id = 3;
        inline bool has_msg_id() const;
        inline void clear_msg_id();
        static const int kMsgIdFieldNumber = 3;
        inline const ::std::string& msg_id() const;
        inline void set_msg_id(const ::std::string& value);
        inline void set_msg_id(const char* value);
        inline void set_msg_id(const char* value, size_t size);
        inline ::std::string* mutable_msg_id();
        inline ::std::string* release_msg_id();
        inline void set_allocated_msg_id(::std::string* msg_id);
        
        // required string time_stamp = 4;
        inline bool has_time_stamp() const;
        inline void clear_time_stamp();
        static const int kTimeStampFieldNumber = 4;
        inline const ::std::string& time_stamp() const;
        inline void set_time_stamp(const ::std::string& value);
        inline void set_time_stamp(const char* value);
        inline void set_time_stamp(const char* value, size_t size);
        inline ::std::string* mutable_time_stamp();
        inline ::std::string* release_time_stamp();
        inline void set_allocated_time_stamp(::std::string* time_stamp);
        
        // required int64 fid = 5;
        inline bool has_fid() const;
        inline void clear_fid();
        static const int kFidFieldNumber = 5;
        inline ::google::protobuf::int64 fid() const;
        inline void set_fid(::google::protobuf::int64 value);
        
        // required string f_avatar = 6;
        inline bool has_f_avatar() const;
        inline void clear_f_avatar();
        static const int kFAvatarFieldNumber = 6;
        inline const ::std::string& f_avatar() const;
        inline void set_f_avatar(const ::std::string& value);
        inline void set_f_avatar(const char* value);
        inline void set_f_avatar(const char* value, size_t size);
        inline ::std::string* mutable_f_avatar();
        inline ::std::string* release_f_avatar();
        inline void set_allocated_f_avatar(::std::string* f_avatar);
        
        // required string f_name = 7;
        inline bool has_f_name() const;
        inline void clear_f_name();
        static const int kFNameFieldNumber = 7;
        inline const ::std::string& f_name() const;
        inline void set_f_name(const ::std::string& value);
        inline void set_f_name(const char* value);
        inline void set_f_name(const char* value, size_t size);
        inline ::std::string* mutable_f_name();
        inline ::std::string* release_f_name();
        inline void set_allocated_f_name(::std::string* f_name);
        
        // required string f_leve = 8;
        inline bool has_f_leve() const;
        inline void clear_f_leve();
        static const int kFLeveFieldNumber = 8;
        inline const ::std::string& f_leve() const;
        inline void set_f_leve(const ::std::string& value);
        inline void set_f_leve(const char* value);
        inline void set_f_leve(const char* value, size_t size);
        inline ::std::string* mutable_f_leve();
        inline ::std::string* release_f_leve();
        inline void set_allocated_f_leve(::std::string* f_leve);
        
        // required string f_user_type = 9;
        inline bool has_f_user_type() const;
        inline void clear_f_user_type();
        static const int kFUserTypeFieldNumber = 9;
        inline const ::std::string& f_user_type() const;
        inline void set_f_user_type(const ::std::string& value);
        inline void set_f_user_type(const char* value);
        inline void set_f_user_type(const char* value, size_t size);
        inline ::std::string* mutable_f_user_type();
        inline ::std::string* release_f_user_type();
        inline void set_allocated_f_user_type(::std::string* f_user_type);
        
        // required string f_unread_count = 10;
        inline bool has_f_unread_count() const;
        inline void clear_f_unread_count();
        static const int kFUnreadCountFieldNumber = 10;
        inline const ::std::string& f_unread_count() const;
        inline void set_f_unread_count(const ::std::string& value);
        inline void set_f_unread_count(const char* value);
        inline void set_f_unread_count(const char* value, size_t size);
        inline ::std::string* mutable_f_unread_count();
        inline ::std::string* release_f_unread_count();
        inline void set_allocated_f_unread_count(::std::string* f_unread_count);
        
        // required string device_udid = 11;
        inline bool has_device_udid() const;
        inline void clear_device_udid();
        static const int kDeviceUdidFieldNumber = 11;
        inline const ::std::string& device_udid() const;
        inline void set_device_udid(const ::std::string& value);
        inline void set_device_udid(const char* value);
        inline void set_device_udid(const char* value, size_t size);
        inline ::std::string* mutable_device_udid();
        inline ::std::string* release_device_udid();
        inline void set_allocated_device_udid(::std::string* device_udid);
        
        // @@protoc_insertion_point(class_scope:QSChat.AnswerVideo)
    private:
        inline void set_has_result();
        inline void clear_has_result();
        inline void set_has_video();
        inline void clear_has_video();
        inline void set_has_msg_id();
        inline void clear_has_msg_id();
        inline void set_has_time_stamp();
        inline void clear_has_time_stamp();
        inline void set_has_fid();
        inline void clear_has_fid();
        inline void set_has_f_avatar();
        inline void clear_has_f_avatar();
        inline void set_has_f_name();
        inline void clear_has_f_name();
        inline void set_has_f_leve();
        inline void clear_has_f_leve();
        inline void set_has_f_user_type();
        inline void clear_has_f_user_type();
        inline void set_has_f_unread_count();
        inline void clear_has_f_unread_count();
        inline void set_has_device_udid();
        inline void clear_has_device_udid();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string* result_;
        ::std::string* video_;
        ::std::string* msg_id_;
        ::std::string* time_stamp_;
        ::google::protobuf::int64 fid_;
        ::std::string* f_avatar_;
        ::std::string* f_name_;
        ::std::string* f_leve_;
        ::std::string* f_user_type_;
        ::std::string* f_unread_count_;
        ::std::string* device_udid_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static AnswerVideo* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class AnswerRecommendHouse : public ::google::protobuf::Message {
    public:
        AnswerRecommendHouse();
        virtual ~AnswerRecommendHouse();
        
        AnswerRecommendHouse(const AnswerRecommendHouse& from);
        
        inline AnswerRecommendHouse& operator=(const AnswerRecommendHouse& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const AnswerRecommendHouse& default_instance();
        
        void Swap(AnswerRecommendHouse* other);
        
        // implements Message ----------------------------------------------
        
        AnswerRecommendHouse* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const AnswerRecommendHouse& from);
        void MergeFrom(const AnswerRecommendHouse& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required string result = 1;
        inline bool has_result() const;
        inline void clear_result();
        static const int kResultFieldNumber = 1;
        inline const ::std::string& result() const;
        inline void set_result(const ::std::string& value);
        inline void set_result(const char* value);
        inline void set_result(const char* value, size_t size);
        inline ::std::string* mutable_result();
        inline ::std::string* release_result();
        inline void set_allocated_result(::std::string* result);
        
        // required string msg_id = 2;
        inline bool has_msg_id() const;
        inline void clear_msg_id();
        static const int kMsgIdFieldNumber = 2;
        inline const ::std::string& msg_id() const;
        inline void set_msg_id(const ::std::string& value);
        inline void set_msg_id(const char* value);
        inline void set_msg_id(const char* value, size_t size);
        inline ::std::string* mutable_msg_id();
        inline ::std::string* release_msg_id();
        inline void set_allocated_msg_id(::std::string* msg_id);
        
        // required string house_id = 3;
        inline bool has_house_id() const;
        inline void clear_house_id();
        static const int kHouseIdFieldNumber = 3;
        inline const ::std::string& house_id() const;
        inline void set_house_id(const ::std::string& value);
        inline void set_house_id(const char* value);
        inline void set_house_id(const char* value, size_t size);
        inline ::std::string* mutable_house_id();
        inline ::std::string* release_house_id();
        inline void set_allocated_house_id(::std::string* house_id);
        
        // optional string building_id = 4;
        inline bool has_building_id() const;
        inline void clear_building_id();
        static const int kBuildingIdFieldNumber = 4;
        inline const ::std::string& building_id() const;
        inline void set_building_id(const ::std::string& value);
        inline void set_building_id(const char* value);
        inline void set_building_id(const char* value, size_t size);
        inline ::std::string* mutable_building_id();
        inline ::std::string* release_building_id();
        inline void set_allocated_building_id(::std::string* building_id);
        
        // required string house_type = 5;
        inline bool has_house_type() const;
        inline void clear_house_type();
        static const int kHouseTypeFieldNumber = 5;
        inline const ::std::string& house_type() const;
        inline void set_house_type(const ::std::string& value);
        inline void set_house_type(const char* value);
        inline void set_house_type(const char* value, size_t size);
        inline ::std::string* mutable_house_type();
        inline ::std::string* release_house_type();
        inline void set_allocated_house_type(::std::string* house_type);
        
        // required string attach_file = 6;
        inline bool has_attach_file() const;
        inline void clear_attach_file();
        static const int kAttachFileFieldNumber = 6;
        inline const ::std::string& attach_file() const;
        inline void set_attach_file(const ::std::string& value);
        inline void set_attach_file(const char* value);
        inline void set_attach_file(const char* value, size_t size);
        inline ::std::string* mutable_attach_file();
        inline ::std::string* release_attach_file();
        inline void set_allocated_attach_file(::std::string* attach_file);
        
        // required string attach_thumb = 7;
        inline bool has_attach_thumb() const;
        inline void clear_attach_thumb();
        static const int kAttachThumbFieldNumber = 7;
        inline const ::std::string& attach_thumb() const;
        inline void set_attach_thumb(const ::std::string& value);
        inline void set_attach_thumb(const char* value);
        inline void set_attach_thumb(const char* value, size_t size);
        inline ::std::string* mutable_attach_thumb();
        inline ::std::string* release_attach_thumb();
        inline void set_allocated_attach_thumb(::std::string* attach_thumb);
        
        // required string areaid = 8;
        inline bool has_areaid() const;
        inline void clear_areaid();
        static const int kAreaidFieldNumber = 8;
        inline const ::std::string& areaid() const;
        inline void set_areaid(const ::std::string& value);
        inline void set_areaid(const char* value);
        inline void set_areaid(const char* value, size_t size);
        inline ::std::string* mutable_areaid();
        inline ::std::string* release_areaid();
        inline void set_allocated_areaid(::std::string* areaid);
        
        // required string area_val = 9;
        inline bool has_area_val() const;
        inline void clear_area_val();
        static const int kAreaValFieldNumber = 9;
        inline const ::std::string& area_val() const;
        inline void set_area_val(const ::std::string& value);
        inline void set_area_val(const char* value);
        inline void set_area_val(const char* value, size_t size);
        inline ::std::string* mutable_area_val();
        inline ::std::string* release_area_val();
        inline void set_allocated_area_val(::std::string* area_val);
        
        // required string streetid = 10;
        inline bool has_streetid() const;
        inline void clear_streetid();
        static const int kStreetidFieldNumber = 10;
        inline const ::std::string& streetid() const;
        inline void set_streetid(const ::std::string& value);
        inline void set_streetid(const char* value);
        inline void set_streetid(const char* value, size_t size);
        inline ::std::string* mutable_streetid();
        inline ::std::string* release_streetid();
        inline void set_allocated_streetid(::std::string* streetid);
        
        // required string street_val = 11;
        inline bool has_street_val() const;
        inline void clear_street_val();
        static const int kStreetValFieldNumber = 11;
        inline const ::std::string& street_val() const;
        inline void set_street_val(const ::std::string& value);
        inline void set_street_val(const char* value);
        inline void set_street_val(const char* value, size_t size);
        inline ::std::string* mutable_street_val();
        inline ::std::string* release_street_val();
        inline void set_allocated_street_val(::std::string* street_val);
        
        // required string house_shi = 12;
        inline bool has_house_shi() const;
        inline void clear_house_shi();
        static const int kHouseShiFieldNumber = 12;
        inline const ::std::string& house_shi() const;
        inline void set_house_shi(const ::std::string& value);
        inline void set_house_shi(const char* value);
        inline void set_house_shi(const char* value, size_t size);
        inline ::std::string* mutable_house_shi();
        inline ::std::string* release_house_shi();
        inline void set_allocated_house_shi(::std::string* house_shi);
        
        // required string house_ting = 13;
        inline bool has_house_ting() const;
        inline void clear_house_ting();
        static const int kHouseTingFieldNumber = 13;
        inline const ::std::string& house_ting() const;
        inline void set_house_ting(const ::std::string& value);
        inline void set_house_ting(const char* value);
        inline void set_house_ting(const char* value, size_t size);
        inline ::std::string* mutable_house_ting();
        inline ::std::string* release_house_ting();
        inline void set_allocated_house_ting(::std::string* house_ting);
        
        // required string house_area = 14;
        inline bool has_house_area() const;
        inline void clear_house_area();
        static const int kHouseAreaFieldNumber = 14;
        inline const ::std::string& house_area() const;
        inline void set_house_area(const ::std::string& value);
        inline void set_house_area(const char* value);
        inline void set_house_area(const char* value, size_t size);
        inline ::std::string* mutable_house_area();
        inline ::std::string* release_house_area();
        inline void set_allocated_house_area(::std::string* house_area);
        
        // optional string house_price = 15;
        inline bool has_house_price() const;
        inline void clear_house_price();
        static const int kHousePriceFieldNumber = 15;
        inline const ::std::string& house_price() const;
        inline void set_house_price(const ::std::string& value);
        inline void set_house_price(const char* value);
        inline void set_house_price(const char* value, size_t size);
        inline ::std::string* mutable_house_price();
        inline ::std::string* release_house_price();
        inline void set_allocated_house_price(::std::string* house_price);
        
        // optional string rent_price = 16;
        inline bool has_rent_price() const;
        inline void clear_rent_price();
        static const int kRentPriceFieldNumber = 16;
        inline const ::std::string& rent_price() const;
        inline void set_rent_price(const ::std::string& value);
        inline void set_rent_price(const char* value);
        inline void set_rent_price(const char* value, size_t size);
        inline ::std::string* mutable_rent_price();
        inline ::std::string* release_rent_price();
        inline void set_allocated_rent_price(::std::string* rent_price);
        
        // required string title_ = 17;
        inline bool has_title_() const;
        inline void clear_title_();
        static const int kTitleFieldNumber = 17;
        inline const ::std::string& title_() const;
        inline void set_title_(const ::std::string& value);
        inline void set_title_(const char* value);
        inline void set_title_(const char* value, size_t size);
        inline ::std::string* mutable_title_();
        inline ::std::string* release_title_();
        inline void set_allocated_title_(::std::string* title_);
        
        // required int64 fid = 18;
        inline bool has_fid() const;
        inline void clear_fid();
        static const int kFidFieldNumber = 18;
        inline ::google::protobuf::int64 fid() const;
        inline void set_fid(::google::protobuf::int64 value);
        
        // required string f_avatar = 19;
        inline bool has_f_avatar() const;
        inline void clear_f_avatar();
        static const int kFAvatarFieldNumber = 19;
        inline const ::std::string& f_avatar() const;
        inline void set_f_avatar(const ::std::string& value);
        inline void set_f_avatar(const char* value);
        inline void set_f_avatar(const char* value, size_t size);
        inline ::std::string* mutable_f_avatar();
        inline ::std::string* release_f_avatar();
        inline void set_allocated_f_avatar(::std::string* f_avatar);
        
        // required string f_name = 20;
        inline bool has_f_name() const;
        inline void clear_f_name();
        static const int kFNameFieldNumber = 20;
        inline const ::std::string& f_name() const;
        inline void set_f_name(const ::std::string& value);
        inline void set_f_name(const char* value);
        inline void set_f_name(const char* value, size_t size);
        inline ::std::string* mutable_f_name();
        inline ::std::string* release_f_name();
        inline void set_allocated_f_name(::std::string* f_name);
        
        // required string f_leve = 21;
        inline bool has_f_leve() const;
        inline void clear_f_leve();
        static const int kFLeveFieldNumber = 21;
        inline const ::std::string& f_leve() const;
        inline void set_f_leve(const ::std::string& value);
        inline void set_f_leve(const char* value);
        inline void set_f_leve(const char* value, size_t size);
        inline ::std::string* mutable_f_leve();
        inline ::std::string* release_f_leve();
        inline void set_allocated_f_leve(::std::string* f_leve);
        
        // required string f_user_type = 22;
        inline bool has_f_user_type() const;
        inline void clear_f_user_type();
        static const int kFUserTypeFieldNumber = 22;
        inline const ::std::string& f_user_type() const;
        inline void set_f_user_type(const ::std::string& value);
        inline void set_f_user_type(const char* value);
        inline void set_f_user_type(const char* value, size_t size);
        inline ::std::string* mutable_f_user_type();
        inline ::std::string* release_f_user_type();
        inline void set_allocated_f_user_type(::std::string* f_user_type);
        
        // required string f_unread_count = 23;
        inline bool has_f_unread_count() const;
        inline void clear_f_unread_count();
        static const int kFUnreadCountFieldNumber = 23;
        inline const ::std::string& f_unread_count() const;
        inline void set_f_unread_count(const ::std::string& value);
        inline void set_f_unread_count(const char* value);
        inline void set_f_unread_count(const char* value, size_t size);
        inline ::std::string* mutable_f_unread_count();
        inline ::std::string* release_f_unread_count();
        inline void set_allocated_f_unread_count(::std::string* f_unread_count);
        
        // required string device_udid = 24;
        inline bool has_device_udid() const;
        inline void clear_device_udid();
        static const int kDeviceUdidFieldNumber = 24;
        inline const ::std::string& device_udid() const;
        inline void set_device_udid(const ::std::string& value);
        inline void set_device_udid(const char* value);
        inline void set_device_udid(const char* value, size_t size);
        inline ::std::string* mutable_device_udid();
        inline ::std::string* release_device_udid();
        inline void set_allocated_device_udid(::std::string* device_udid);
        
        // @@protoc_insertion_point(class_scope:QSChat.AnswerRecommendHouse)
    private:
        inline void set_has_result();
        inline void clear_has_result();
        inline void set_has_msg_id();
        inline void clear_has_msg_id();
        inline void set_has_house_id();
        inline void clear_has_house_id();
        inline void set_has_building_id();
        inline void clear_has_building_id();
        inline void set_has_house_type();
        inline void clear_has_house_type();
        inline void set_has_attach_file();
        inline void clear_has_attach_file();
        inline void set_has_attach_thumb();
        inline void clear_has_attach_thumb();
        inline void set_has_areaid();
        inline void clear_has_areaid();
        inline void set_has_area_val();
        inline void clear_has_area_val();
        inline void set_has_streetid();
        inline void clear_has_streetid();
        inline void set_has_street_val();
        inline void clear_has_street_val();
        inline void set_has_house_shi();
        inline void clear_has_house_shi();
        inline void set_has_house_ting();
        inline void clear_has_house_ting();
        inline void set_has_house_area();
        inline void clear_has_house_area();
        inline void set_has_house_price();
        inline void clear_has_house_price();
        inline void set_has_rent_price();
        inline void clear_has_rent_price();
        inline void set_has_title_();
        inline void clear_has_title_();
        inline void set_has_fid();
        inline void clear_has_fid();
        inline void set_has_f_avatar();
        inline void clear_has_f_avatar();
        inline void set_has_f_name();
        inline void clear_has_f_name();
        inline void set_has_f_leve();
        inline void clear_has_f_leve();
        inline void set_has_f_user_type();
        inline void clear_has_f_user_type();
        inline void set_has_f_unread_count();
        inline void clear_has_f_unread_count();
        inline void set_has_device_udid();
        inline void clear_has_device_udid();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string* result_;
        ::std::string* msg_id_;
        ::std::string* house_id_;
        ::std::string* building_id_;
        ::std::string* house_type_;
        ::std::string* attach_file_;
        ::std::string* attach_thumb_;
        ::std::string* areaid_;
        ::std::string* area_val_;
        ::std::string* streetid_;
        ::std::string* street_val_;
        ::std::string* house_shi_;
        ::std::string* house_ting_;
        ::std::string* house_area_;
        ::std::string* house_price_;
        ::std::string* rent_price_;
        ::std::string* title__;
        ::google::protobuf::int64 fid_;
        ::std::string* f_avatar_;
        ::std::string* f_name_;
        ::std::string* f_leve_;
        ::std::string* f_user_type_;
        ::std::string* f_unread_count_;
        ::std::string* device_udid_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static AnswerRecommendHouse* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class AnswerRecHouse : public ::google::protobuf::Message {
    public:
        AnswerRecHouse();
        virtual ~AnswerRecHouse();
        
        AnswerRecHouse(const AnswerRecHouse& from);
        
        inline AnswerRecHouse& operator=(const AnswerRecHouse& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const AnswerRecHouse& default_instance();
        
        void Swap(AnswerRecHouse* other);
        
        // implements Message ----------------------------------------------
        
        AnswerRecHouse* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const AnswerRecHouse& from);
        void MergeFrom(const AnswerRecHouse& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required string msg_id_ = 1;
        inline bool has_msg_id_() const;
        inline void clear_msg_id_();
        static const int kMsgIdFieldNumber = 1;
        inline const ::std::string& msg_id_() const;
        inline void set_msg_id_(const ::std::string& value);
        inline void set_msg_id_(const char* value);
        inline void set_msg_id_(const char* value, size_t size);
        inline ::std::string* mutable_msg_id_();
        inline ::std::string* release_msg_id_();
        inline void set_allocated_msg_id_(::std::string* msg_id_);
        
        // required .QSChat.Finfo finfo = 2;
        inline bool has_finfo() const;
        inline void clear_finfo();
        static const int kFinfoFieldNumber = 2;
        inline const ::QSChat::Finfo& finfo() const;
        inline ::QSChat::Finfo* mutable_finfo();
        inline ::QSChat::Finfo* release_finfo();
        inline void set_allocated_finfo(::QSChat::Finfo* finfo);
        
        // optional string attach_file = 3;
        inline bool has_attach_file() const;
        inline void clear_attach_file();
        static const int kAttachFileFieldNumber = 3;
        inline const ::std::string& attach_file() const;
        inline void set_attach_file(const ::std::string& value);
        inline void set_attach_file(const char* value);
        inline void set_attach_file(const char* value, size_t size);
        inline ::std::string* mutable_attach_file();
        inline ::std::string* release_attach_file();
        inline void set_allocated_attach_file(::std::string* attach_file);
        
        // optional string attach_thumb = 4;
        inline bool has_attach_thumb() const;
        inline void clear_attach_thumb();
        static const int kAttachThumbFieldNumber = 4;
        inline const ::std::string& attach_thumb() const;
        inline void set_attach_thumb(const ::std::string& value);
        inline void set_attach_thumb(const char* value);
        inline void set_attach_thumb(const char* value, size_t size);
        inline ::std::string* mutable_attach_thumb();
        inline ::std::string* release_attach_thumb();
        inline void set_allocated_attach_thumb(::std::string* attach_thumb);
        
        // optional string areaid = 5;
        inline bool has_areaid() const;
        inline void clear_areaid();
        static const int kAreaidFieldNumber = 5;
        inline const ::std::string& areaid() const;
        inline void set_areaid(const ::std::string& value);
        inline void set_areaid(const char* value);
        inline void set_areaid(const char* value, size_t size);
        inline ::std::string* mutable_areaid();
        inline ::std::string* release_areaid();
        inline void set_allocated_areaid(::std::string* areaid);
        
        // optional string area_val = 6;
        inline bool has_area_val() const;
        inline void clear_area_val();
        static const int kAreaValFieldNumber = 6;
        inline const ::std::string& area_val() const;
        inline void set_area_val(const ::std::string& value);
        inline void set_area_val(const char* value);
        inline void set_area_val(const char* value, size_t size);
        inline ::std::string* mutable_area_val();
        inline ::std::string* release_area_val();
        inline void set_allocated_area_val(::std::string* area_val);
        
        // optional string streetid = 7;
        inline bool has_streetid() const;
        inline void clear_streetid();
        static const int kStreetidFieldNumber = 7;
        inline const ::std::string& streetid() const;
        inline void set_streetid(const ::std::string& value);
        inline void set_streetid(const char* value);
        inline void set_streetid(const char* value, size_t size);
        inline ::std::string* mutable_streetid();
        inline ::std::string* release_streetid();
        inline void set_allocated_streetid(::std::string* streetid);
        
        // optional string street_val = 8;
        inline bool has_street_val() const;
        inline void clear_street_val();
        static const int kStreetValFieldNumber = 8;
        inline const ::std::string& street_val() const;
        inline void set_street_val(const ::std::string& value);
        inline void set_street_val(const char* value);
        inline void set_street_val(const char* value, size_t size);
        inline ::std::string* mutable_street_val();
        inline ::std::string* release_street_val();
        inline void set_allocated_street_val(::std::string* street_val);
        
        // optional string house_shi = 9;
        inline bool has_house_shi() const;
        inline void clear_house_shi();
        static const int kHouseShiFieldNumber = 9;
        inline const ::std::string& house_shi() const;
        inline void set_house_shi(const ::std::string& value);
        inline void set_house_shi(const char* value);
        inline void set_house_shi(const char* value, size_t size);
        inline ::std::string* mutable_house_shi();
        inline ::std::string* release_house_shi();
        inline void set_allocated_house_shi(::std::string* house_shi);
        
        // optional string house_ting = 10;
        inline bool has_house_ting() const;
        inline void clear_house_ting();
        static const int kHouseTingFieldNumber = 10;
        inline const ::std::string& house_ting() const;
        inline void set_house_ting(const ::std::string& value);
        inline void set_house_ting(const char* value);
        inline void set_house_ting(const char* value, size_t size);
        inline ::std::string* mutable_house_ting();
        inline ::std::string* release_house_ting();
        inline void set_allocated_house_ting(::std::string* house_ting);
        
        // optional string house_area = 11;
        inline bool has_house_area() const;
        inline void clear_house_area();
        static const int kHouseAreaFieldNumber = 11;
        inline const ::std::string& house_area() const;
        inline void set_house_area(const ::std::string& value);
        inline void set_house_area(const char* value);
        inline void set_house_area(const char* value, size_t size);
        inline ::std::string* mutable_house_area();
        inline ::std::string* release_house_area();
        inline void set_allocated_house_area(::std::string* house_area);
        
        // optional string house_price = 12;
        inline bool has_house_price() const;
        inline void clear_house_price();
        static const int kHousePriceFieldNumber = 12;
        inline const ::std::string& house_price() const;
        inline void set_house_price(const ::std::string& value);
        inline void set_house_price(const char* value);
        inline void set_house_price(const char* value, size_t size);
        inline ::std::string* mutable_house_price();
        inline ::std::string* release_house_price();
        inline void set_allocated_house_price(::std::string* house_price);
        
        // optional string rent_price = 13;
        inline bool has_rent_price() const;
        inline void clear_rent_price();
        static const int kRentPriceFieldNumber = 13;
        inline const ::std::string& rent_price() const;
        inline void set_rent_price(const ::std::string& value);
        inline void set_rent_price(const char* value);
        inline void set_rent_price(const char* value, size_t size);
        inline ::std::string* mutable_rent_price();
        inline ::std::string* release_rent_price();
        inline void set_allocated_rent_price(::std::string* rent_price);
        
        // optional string title_ = 14;
        inline bool has_title_() const;
        inline void clear_title_();
        static const int kTitleFieldNumber = 14;
        inline const ::std::string& title_() const;
        inline void set_title_(const ::std::string& value);
        inline void set_title_(const char* value);
        inline void set_title_(const char* value, size_t size);
        inline ::std::string* mutable_title_();
        inline ::std::string* release_title_();
        inline void set_allocated_title_(::std::string* title_);
        
        // @@protoc_insertion_point(class_scope:QSChat.AnswerRecHouse)
    private:
        inline void set_has_msg_id_();
        inline void clear_has_msg_id_();
        inline void set_has_finfo();
        inline void clear_has_finfo();
        inline void set_has_attach_file();
        inline void clear_has_attach_file();
        inline void set_has_attach_thumb();
        inline void clear_has_attach_thumb();
        inline void set_has_areaid();
        inline void clear_has_areaid();
        inline void set_has_area_val();
        inline void clear_has_area_val();
        inline void set_has_streetid();
        inline void clear_has_streetid();
        inline void set_has_street_val();
        inline void clear_has_street_val();
        inline void set_has_house_shi();
        inline void clear_has_house_shi();
        inline void set_has_house_ting();
        inline void clear_has_house_ting();
        inline void set_has_house_area();
        inline void clear_has_house_area();
        inline void set_has_house_price();
        inline void clear_has_house_price();
        inline void set_has_rent_price();
        inline void clear_has_rent_price();
        inline void set_has_title_();
        inline void clear_has_title_();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string* msg_id__;
        ::QSChat::Finfo* finfo_;
        ::std::string* attach_file_;
        ::std::string* attach_thumb_;
        ::std::string* areaid_;
        ::std::string* area_val_;
        ::std::string* streetid_;
        ::std::string* street_val_;
        ::std::string* house_shi_;
        ::std::string* house_ting_;
        ::std::string* house_area_;
        ::std::string* house_price_;
        ::std::string* rent_price_;
        ::std::string* title__;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static AnswerRecHouse* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class Finfo : public ::google::protobuf::Message {
    public:
        Finfo();
        virtual ~Finfo();
        
        Finfo(const Finfo& from);
        
        inline Finfo& operator=(const Finfo& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const Finfo& default_instance();
        
        void Swap(Finfo* other);
        
        // implements Message ----------------------------------------------
        
        Finfo* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const Finfo& from);
        void MergeFrom(const Finfo& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required int64 fid = 1;
        inline bool has_fid() const;
        inline void clear_fid();
        static const int kFidFieldNumber = 1;
        inline ::google::protobuf::int64 fid() const;
        inline void set_fid(::google::protobuf::int64 value);
        
        // required string f_avatar = 2;
        inline bool has_f_avatar() const;
        inline void clear_f_avatar();
        static const int kFAvatarFieldNumber = 2;
        inline const ::std::string& f_avatar() const;
        inline void set_f_avatar(const ::std::string& value);
        inline void set_f_avatar(const char* value);
        inline void set_f_avatar(const char* value, size_t size);
        inline ::std::string* mutable_f_avatar();
        inline ::std::string* release_f_avatar();
        inline void set_allocated_f_avatar(::std::string* f_avatar);
        
        // required string f_name = 3;
        inline bool has_f_name() const;
        inline void clear_f_name();
        static const int kFNameFieldNumber = 3;
        inline const ::std::string& f_name() const;
        inline void set_f_name(const ::std::string& value);
        inline void set_f_name(const char* value);
        inline void set_f_name(const char* value, size_t size);
        inline ::std::string* mutable_f_name();
        inline ::std::string* release_f_name();
        inline void set_allocated_f_name(::std::string* f_name);
        
        // required string f_leve = 4;
        inline bool has_f_leve() const;
        inline void clear_f_leve();
        static const int kFLeveFieldNumber = 4;
        inline const ::std::string& f_leve() const;
        inline void set_f_leve(const ::std::string& value);
        inline void set_f_leve(const char* value);
        inline void set_f_leve(const char* value, size_t size);
        inline ::std::string* mutable_f_leve();
        inline ::std::string* release_f_leve();
        inline void set_allocated_f_leve(::std::string* f_leve);
        
        // required string f_user_type = 5;
        inline bool has_f_user_type() const;
        inline void clear_f_user_type();
        static const int kFUserTypeFieldNumber = 5;
        inline const ::std::string& f_user_type() const;
        inline void set_f_user_type(const ::std::string& value);
        inline void set_f_user_type(const char* value);
        inline void set_f_user_type(const char* value, size_t size);
        inline ::std::string* mutable_f_user_type();
        inline ::std::string* release_f_user_type();
        inline void set_allocated_f_user_type(::std::string* f_user_type);
        
        // required string f_unread_count = 6;
        inline bool has_f_unread_count() const;
        inline void clear_f_unread_count();
        static const int kFUnreadCountFieldNumber = 6;
        inline const ::std::string& f_unread_count() const;
        inline void set_f_unread_count(const ::std::string& value);
        inline void set_f_unread_count(const char* value);
        inline void set_f_unread_count(const char* value, size_t size);
        inline ::std::string* mutable_f_unread_count();
        inline ::std::string* release_f_unread_count();
        inline void set_allocated_f_unread_count(::std::string* f_unread_count);
        
        // required string house_id = 7;
        inline bool has_house_id() const;
        inline void clear_house_id();
        static const int kHouseIdFieldNumber = 7;
        inline const ::std::string& house_id() const;
        inline void set_house_id(const ::std::string& value);
        inline void set_house_id(const char* value);
        inline void set_house_id(const char* value, size_t size);
        inline ::std::string* mutable_house_id();
        inline ::std::string* release_house_id();
        inline void set_allocated_house_id(::std::string* house_id);
        
        // required string building_id = 8;
        inline bool has_building_id() const;
        inline void clear_building_id();
        static const int kBuildingIdFieldNumber = 8;
        inline const ::std::string& building_id() const;
        inline void set_building_id(const ::std::string& value);
        inline void set_building_id(const char* value);
        inline void set_building_id(const char* value, size_t size);
        inline ::std::string* mutable_building_id();
        inline ::std::string* release_building_id();
        inline void set_allocated_building_id(::std::string* building_id);
        
        // required string house_type = 9;
        inline bool has_house_type() const;
        inline void clear_house_type();
        static const int kHouseTypeFieldNumber = 9;
        inline const ::std::string& house_type() const;
        inline void set_house_type(const ::std::string& value);
        inline void set_house_type(const char* value);
        inline void set_house_type(const char* value, size_t size);
        inline ::std::string* mutable_house_type();
        inline ::std::string* release_house_type();
        inline void set_allocated_house_type(::std::string* house_type);
        
        // @@protoc_insertion_point(class_scope:QSChat.Finfo)
    private:
        inline void set_has_fid();
        inline void clear_has_fid();
        inline void set_has_f_avatar();
        inline void clear_has_f_avatar();
        inline void set_has_f_name();
        inline void clear_has_f_name();
        inline void set_has_f_leve();
        inline void clear_has_f_leve();
        inline void set_has_f_user_type();
        inline void clear_has_f_user_type();
        inline void set_has_f_unread_count();
        inline void clear_has_f_unread_count();
        inline void set_has_house_id();
        inline void clear_has_house_id();
        inline void set_has_building_id();
        inline void clear_has_building_id();
        inline void set_has_house_type();
        inline void clear_has_house_type();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int64 fid_;
        ::std::string* f_avatar_;
        ::std::string* f_name_;
        ::std::string* f_leve_;
        ::std::string* f_user_type_;
        ::std::string* f_unread_count_;
        ::std::string* house_id_;
        ::std::string* building_id_;
        ::std::string* house_type_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static Finfo* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class AnswerOffline : public ::google::protobuf::Message {
    public:
        AnswerOffline();
        virtual ~AnswerOffline();
        
        AnswerOffline(const AnswerOffline& from);
        
        inline AnswerOffline& operator=(const AnswerOffline& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const AnswerOffline& default_instance();
        
        void Swap(AnswerOffline* other);
        
        // implements Message ----------------------------------------------
        
        AnswerOffline* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const AnswerOffline& from);
        void MergeFrom(const AnswerOffline& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required int32 result = 1;
        inline bool has_result() const;
        inline void clear_result();
        static const int kResultFieldNumber = 1;
        inline ::google::protobuf::int32 result() const;
        inline void set_result(::google::protobuf::int32 value);
        
        // required string msg = 2;
        inline bool has_msg() const;
        inline void clear_msg();
        static const int kMsgFieldNumber = 2;
        inline const ::std::string& msg() const;
        inline void set_msg(const ::std::string& value);
        inline void set_msg(const char* value);
        inline void set_msg(const char* value, size_t size);
        inline ::std::string* mutable_msg();
        inline ::std::string* release_msg();
        inline void set_allocated_msg(::std::string* msg);
        
        // required string msg_id = 3;
        inline bool has_msg_id() const;
        inline void clear_msg_id();
        static const int kMsgIdFieldNumber = 3;
        inline const ::std::string& msg_id() const;
        inline void set_msg_id(const ::std::string& value);
        inline void set_msg_id(const char* value);
        inline void set_msg_id(const char* value, size_t size);
        inline ::std::string* mutable_msg_id();
        inline ::std::string* release_msg_id();
        inline void set_allocated_msg_id(::std::string* msg_id);
        
        // required string time_stamp = 4;
        inline bool has_time_stamp() const;
        inline void clear_time_stamp();
        static const int kTimeStampFieldNumber = 4;
        inline const ::std::string& time_stamp() const;
        inline void set_time_stamp(const ::std::string& value);
        inline void set_time_stamp(const char* value);
        inline void set_time_stamp(const char* value, size_t size);
        inline ::std::string* mutable_time_stamp();
        inline ::std::string* release_time_stamp();
        inline void set_allocated_time_stamp(::std::string* time_stamp);
        
        // required int64 fid = 5;
        inline bool has_fid() const;
        inline void clear_fid();
        static const int kFidFieldNumber = 5;
        inline ::google::protobuf::int64 fid() const;
        inline void set_fid(::google::protobuf::int64 value);
        
        // required string f_avatar = 6;
        inline bool has_f_avatar() const;
        inline void clear_f_avatar();
        static const int kFAvatarFieldNumber = 6;
        inline const ::std::string& f_avatar() const;
        inline void set_f_avatar(const ::std::string& value);
        inline void set_f_avatar(const char* value);
        inline void set_f_avatar(const char* value, size_t size);
        inline ::std::string* mutable_f_avatar();
        inline ::std::string* release_f_avatar();
        inline void set_allocated_f_avatar(::std::string* f_avatar);
        
        // required string f_name = 7;
        inline bool has_f_name() const;
        inline void clear_f_name();
        static const int kFNameFieldNumber = 7;
        inline const ::std::string& f_name() const;
        inline void set_f_name(const ::std::string& value);
        inline void set_f_name(const char* value);
        inline void set_f_name(const char* value, size_t size);
        inline ::std::string* mutable_f_name();
        inline ::std::string* release_f_name();
        inline void set_allocated_f_name(::std::string* f_name);
        
        // required string f_leve = 8;
        inline bool has_f_leve() const;
        inline void clear_f_leve();
        static const int kFLeveFieldNumber = 8;
        inline const ::std::string& f_leve() const;
        inline void set_f_leve(const ::std::string& value);
        inline void set_f_leve(const char* value);
        inline void set_f_leve(const char* value, size_t size);
        inline ::std::string* mutable_f_leve();
        inline ::std::string* release_f_leve();
        inline void set_allocated_f_leve(::std::string* f_leve);
        
        // required string f_user_type = 9;
        inline bool has_f_user_type() const;
        inline void clear_f_user_type();
        static const int kFUserTypeFieldNumber = 9;
        inline const ::std::string& f_user_type() const;
        inline void set_f_user_type(const ::std::string& value);
        inline void set_f_user_type(const char* value);
        inline void set_f_user_type(const char* value, size_t size);
        inline ::std::string* mutable_f_user_type();
        inline ::std::string* release_f_user_type();
        inline void set_allocated_f_user_type(::std::string* f_user_type);
        
        // required string f_unread_count = 10;
        inline bool has_f_unread_count() const;
        inline void clear_f_unread_count();
        static const int kFUnreadCountFieldNumber = 10;
        inline const ::std::string& f_unread_count() const;
        inline void set_f_unread_count(const ::std::string& value);
        inline void set_f_unread_count(const char* value);
        inline void set_f_unread_count(const char* value, size_t size);
        inline ::std::string* mutable_f_unread_count();
        inline ::std::string* release_f_unread_count();
        inline void set_allocated_f_unread_count(::std::string* f_unread_count);
        
        // required string device_udid = 11;
        inline bool has_device_udid() const;
        inline void clear_device_udid();
        static const int kDeviceUdidFieldNumber = 11;
        inline const ::std::string& device_udid() const;
        inline void set_device_udid(const ::std::string& value);
        inline void set_device_udid(const char* value);
        inline void set_device_udid(const char* value, size_t size);
        inline ::std::string* mutable_device_udid();
        inline ::std::string* release_device_udid();
        inline void set_allocated_device_udid(::std::string* device_udid);
        
        // @@protoc_insertion_point(class_scope:QSChat.AnswerOffline)
    private:
        inline void set_has_result();
        inline void clear_has_result();
        inline void set_has_msg();
        inline void clear_has_msg();
        inline void set_has_msg_id();
        inline void clear_has_msg_id();
        inline void set_has_time_stamp();
        inline void clear_has_time_stamp();
        inline void set_has_fid();
        inline void clear_has_fid();
        inline void set_has_f_avatar();
        inline void clear_has_f_avatar();
        inline void set_has_f_name();
        inline void clear_has_f_name();
        inline void set_has_f_leve();
        inline void clear_has_f_leve();
        inline void set_has_f_user_type();
        inline void clear_has_f_user_type();
        inline void set_has_f_unread_count();
        inline void clear_has_f_unread_count();
        inline void set_has_device_udid();
        inline void clear_has_device_udid();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string* msg_;
        ::std::string* msg_id_;
        ::std::string* time_stamp_;
        ::google::protobuf::int64 fid_;
        ::std::string* f_avatar_;
        ::std::string* f_name_;
        ::std::string* f_leve_;
        ::std::string* f_user_type_;
        ::std::string* f_unread_count_;
        ::std::string* device_udid_;
        ::google::protobuf::int32 result_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static AnswerOffline* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class AnswerSpecial : public ::google::protobuf::Message {
    public:
        AnswerSpecial();
        virtual ~AnswerSpecial();
        
        AnswerSpecial(const AnswerSpecial& from);
        
        inline AnswerSpecial& operator=(const AnswerSpecial& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const AnswerSpecial& default_instance();
        
        void Swap(AnswerSpecial* other);
        
        // implements Message ----------------------------------------------
        
        AnswerSpecial* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const AnswerSpecial& from);
        void MergeFrom(const AnswerSpecial& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required string name = 1;
        inline bool has_name() const;
        inline void clear_name();
        static const int kNameFieldNumber = 1;
        inline const ::std::string& name() const;
        inline void set_name(const ::std::string& value);
        inline void set_name(const char* value);
        inline void set_name(const char* value, size_t size);
        inline ::std::string* mutable_name();
        inline ::std::string* release_name();
        inline void set_allocated_name(::std::string* name);
        
        // required string pic = 2;
        inline bool has_pic() const;
        inline void clear_pic();
        static const int kPicFieldNumber = 2;
        inline const ::std::string& pic() const;
        inline void set_pic(const ::std::string& value);
        inline void set_pic(const char* value);
        inline void set_pic(const char* value, size_t size);
        inline ::std::string* mutable_pic();
        inline ::std::string* release_pic();
        inline void set_allocated_pic(::std::string* pic);
        
        // required string desc = 3;
        inline bool has_desc() const;
        inline void clear_desc();
        static const int kDescFieldNumber = 3;
        inline const ::std::string& desc() const;
        inline void set_desc(const ::std::string& value);
        inline void set_desc(const char* value);
        inline void set_desc(const char* value, size_t size);
        inline ::std::string* mutable_desc();
        inline ::std::string* release_desc();
        inline void set_allocated_desc(::std::string* desc);
        
        // required string fid = 4;
        inline bool has_fid() const;
        inline void clear_fid();
        static const int kFidFieldNumber = 4;
        inline const ::std::string& fid() const;
        inline void set_fid(const ::std::string& value);
        inline void set_fid(const char* value);
        inline void set_fid(const char* value, size_t size);
        inline ::std::string* mutable_fid();
        inline ::std::string* release_fid();
        inline void set_allocated_fid(::std::string* fid);
        
        // required string type = 5;
        inline bool has_type() const;
        inline void clear_type();
        static const int kTypeFieldNumber = 5;
        inline const ::std::string& type() const;
        inline void set_type(const ::std::string& value);
        inline void set_type(const char* value);
        inline void set_type(const char* value, size_t size);
        inline ::std::string* mutable_type();
        inline ::std::string* release_type();
        inline void set_allocated_type(::std::string* type);
        
        // @@protoc_insertion_point(class_scope:QSChat.AnswerSpecial)
    private:
        inline void set_has_name();
        inline void clear_has_name();
        inline void set_has_pic();
        inline void clear_has_pic();
        inline void set_has_desc();
        inline void clear_has_desc();
        inline void set_has_fid();
        inline void clear_has_fid();
        inline void set_has_type();
        inline void clear_has_type();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string* name_;
        ::std::string* pic_;
        ::std::string* desc_;
        ::std::string* fid_;
        ::std::string* type_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static AnswerSpecial* default_instance_;
    };
    // -------------------------------------------------------------------
    
    class AnswerSystem : public ::google::protobuf::Message {
    public:
        AnswerSystem();
        virtual ~AnswerSystem();
        
        AnswerSystem(const AnswerSystem& from);
        
        inline AnswerSystem& operator=(const AnswerSystem& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const AnswerSystem& default_instance();
        
        void Swap(AnswerSystem* other);
        
        // implements Message ----------------------------------------------
        
        AnswerSystem* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const AnswerSystem& from);
        void MergeFrom(const AnswerSystem& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // required string title = 1;
        inline bool has_title() const;
        inline void clear_title();
        static const int kTitleFieldNumber = 1;
        inline const ::std::string& title() const;
        inline void set_title(const ::std::string& value);
        inline void set_title(const char* value);
        inline void set_title(const char* value, size_t size);
        inline ::std::string* mutable_title();
        inline ::std::string* release_title();
        inline void set_allocated_title(::std::string* title);
        
        // required string desc = 2;
        inline bool has_desc() const;
        inline void clear_desc();
        static const int kDescFieldNumber = 2;
        inline const ::std::string& desc() const;
        inline void set_desc(const ::std::string& value);
        inline void set_desc(const char* value);
        inline void set_desc(const char* value, size_t size);
        inline ::std::string* mutable_desc();
        inline ::std::string* release_desc();
        inline void set_allocated_desc(::std::string* desc);
        
        // required string time = 3;
        inline bool has_time() const;
        inline void clear_time();
        static const int kTimeFieldNumber = 3;
        inline const ::std::string& time() const;
        inline void set_time(const ::std::string& value);
        inline void set_time(const char* value);
        inline void set_time(const char* value, size_t size);
        inline ::std::string* mutable_time();
        inline ::std::string* release_time();
        inline void set_allocated_time(::std::string* time);
        
        // required string type = 4;
        inline bool has_type() const;
        inline void clear_type();
        static const int kTypeFieldNumber = 4;
        inline const ::std::string& type() const;
        inline void set_type(const ::std::string& value);
        inline void set_type(const char* value);
        inline void set_type(const char* value, size_t size);
        inline ::std::string* mutable_type();
        inline ::std::string* release_type();
        inline void set_allocated_type(::std::string* type);
        
        // required string url = 5;
        inline bool has_url() const;
        inline void clear_url();
        static const int kUrlFieldNumber = 5;
        inline const ::std::string& url() const;
        inline void set_url(const ::std::string& value);
        inline void set_url(const char* value);
        inline void set_url(const char* value, size_t size);
        inline ::std::string* mutable_url();
        inline ::std::string* release_url();
        inline void set_allocated_url(::std::string* url);
        
        // optional string exp_1 = 6;
        inline bool has_exp_1() const;
        inline void clear_exp_1();
        static const int kExp1FieldNumber = 6;
        inline const ::std::string& exp_1() const;
        inline void set_exp_1(const ::std::string& value);
        inline void set_exp_1(const char* value);
        inline void set_exp_1(const char* value, size_t size);
        inline ::std::string* mutable_exp_1();
        inline ::std::string* release_exp_1();
        inline void set_allocated_exp_1(::std::string* exp_1);
        
        // optional string exp_2 = 7;
        inline bool has_exp_2() const;
        inline void clear_exp_2();
        static const int kExp2FieldNumber = 7;
        inline const ::std::string& exp_2() const;
        inline void set_exp_2(const ::std::string& value);
        inline void set_exp_2(const char* value);
        inline void set_exp_2(const char* value, size_t size);
        inline ::std::string* mutable_exp_2();
        inline ::std::string* release_exp_2();
        inline void set_allocated_exp_2(::std::string* exp_2);
        
        // optional string exp_3 = 8;
        inline bool has_exp_3() const;
        inline void clear_exp_3();
        static const int kExp3FieldNumber = 8;
        inline const ::std::string& exp_3() const;
        inline void set_exp_3(const ::std::string& value);
        inline void set_exp_3(const char* value);
        inline void set_exp_3(const char* value, size_t size);
        inline ::std::string* mutable_exp_3();
        inline ::std::string* release_exp_3();
        inline void set_allocated_exp_3(::std::string* exp_3);
        
        // optional string exp_4 = 9;
        inline bool has_exp_4() const;
        inline void clear_exp_4();
        static const int kExp4FieldNumber = 9;
        inline const ::std::string& exp_4() const;
        inline void set_exp_4(const ::std::string& value);
        inline void set_exp_4(const char* value);
        inline void set_exp_4(const char* value, size_t size);
        inline ::std::string* mutable_exp_4();
        inline ::std::string* release_exp_4();
        inline void set_allocated_exp_4(::std::string* exp_4);
        
        // optional string exp_5 = 10;
        inline bool has_exp_5() const;
        inline void clear_exp_5();
        static const int kExp5FieldNumber = 10;
        inline const ::std::string& exp_5() const;
        inline void set_exp_5(const ::std::string& value);
        inline void set_exp_5(const char* value);
        inline void set_exp_5(const char* value, size_t size);
        inline ::std::string* mutable_exp_5();
        inline ::std::string* release_exp_5();
        inline void set_allocated_exp_5(::std::string* exp_5);
        
        // @@protoc_insertion_point(class_scope:QSChat.AnswerSystem)
    private:
        inline void set_has_title();
        inline void clear_has_title();
        inline void set_has_desc();
        inline void clear_has_desc();
        inline void set_has_time();
        inline void clear_has_time();
        inline void set_has_type();
        inline void clear_has_type();
        inline void set_has_url();
        inline void clear_has_url();
        inline void set_has_exp_1();
        inline void clear_has_exp_1();
        inline void set_has_exp_2();
        inline void clear_has_exp_2();
        inline void set_has_exp_3();
        inline void clear_has_exp_3();
        inline void set_has_exp_4();
        inline void clear_has_exp_4();
        inline void set_has_exp_5();
        inline void clear_has_exp_5();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string* title_;
        ::std::string* desc_;
        ::std::string* time_;
        ::std::string* type_;
        ::std::string* url_;
        ::std::string* exp_1_;
        ::std::string* exp_2_;
        ::std::string* exp_3_;
        ::std::string* exp_4_;
        ::std::string* exp_5_;
        friend void  protobuf_AddDesc_qschat_2eproto();
        friend void protobuf_AssignDesc_qschat_2eproto();
        friend void protobuf_ShutdownFile_qschat_2eproto();
        
        void InitAsDefaultInstance();
        static AnswerSystem* default_instance_;
    };
    // ===================================================================
    
    
    // ===================================================================
    
    // QuestionOnline
    
    // required string token = 1;
    inline bool QuestionOnline::has_token() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void QuestionOnline::set_has_token() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void QuestionOnline::clear_has_token() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void QuestionOnline::clear_token() {
        if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_->clear();
        }
        clear_has_token();
    }
    inline const ::std::string& QuestionOnline::token() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOnline.token)
        return *token_;
    }
    inline void QuestionOnline::set_token(const ::std::string& value) {
        set_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_ = new ::std::string;
        }
        token_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOnline.token)
    }
    inline void QuestionOnline::set_token(const char* value) {
        set_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_ = new ::std::string;
        }
        token_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOnline.token)
    }
    inline void QuestionOnline::set_token(const char* value, size_t size) {
        set_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_ = new ::std::string;
        }
        token_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOnline.token)
    }
    inline ::std::string* QuestionOnline::mutable_token() {
        set_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOnline.token)
        return token_;
    }
    inline ::std::string* QuestionOnline::release_token() {
        clear_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = token_;
            token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOnline::set_allocated_token(::std::string* token) {
        if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete token_;
        }
        if (token) {
            set_has_token();
            token_ = token;
        } else {
            clear_has_token();
            token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOnline.token)
    }
    
    // required string user_id = 2;
    inline bool QuestionOnline::has_user_id() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void QuestionOnline::set_has_user_id() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void QuestionOnline::clear_has_user_id() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void QuestionOnline::clear_user_id() {
        if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            user_id_->clear();
        }
        clear_has_user_id();
    }
    inline const ::std::string& QuestionOnline::user_id() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOnline.user_id)
        return *user_id_;
    }
    inline void QuestionOnline::set_user_id(const ::std::string& value) {
        set_has_user_id();
        if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            user_id_ = new ::std::string;
        }
        user_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOnline.user_id)
    }
    inline void QuestionOnline::set_user_id(const char* value) {
        set_has_user_id();
        if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            user_id_ = new ::std::string;
        }
        user_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOnline.user_id)
    }
    inline void QuestionOnline::set_user_id(const char* value, size_t size) {
        set_has_user_id();
        if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            user_id_ = new ::std::string;
        }
        user_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOnline.user_id)
    }
    inline ::std::string* QuestionOnline::mutable_user_id() {
        set_has_user_id();
        if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            user_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOnline.user_id)
        return user_id_;
    }
    inline ::std::string* QuestionOnline::release_user_id() {
        clear_has_user_id();
        if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = user_id_;
            user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOnline::set_allocated_user_id(::std::string* user_id) {
        if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete user_id_;
        }
        if (user_id) {
            set_has_user_id();
            user_id_ = user_id;
        } else {
            clear_has_user_id();
            user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOnline.user_id)
    }
    
    // required string device_udid = 3;
    inline bool QuestionOnline::has_device_udid() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void QuestionOnline::set_has_device_udid() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void QuestionOnline::clear_has_device_udid() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void QuestionOnline::clear_device_udid() {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_->clear();
        }
        clear_has_device_udid();
    }
    inline const ::std::string& QuestionOnline::device_udid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOnline.device_udid)
        return *device_udid_;
    }
    inline void QuestionOnline::set_device_udid(const ::std::string& value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOnline.device_udid)
    }
    inline void QuestionOnline::set_device_udid(const char* value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOnline.device_udid)
    }
    inline void QuestionOnline::set_device_udid(const char* value, size_t size) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOnline.device_udid)
    }
    inline ::std::string* QuestionOnline::mutable_device_udid() {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOnline.device_udid)
        return device_udid_;
    }
    inline ::std::string* QuestionOnline::release_device_udid() {
        clear_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_udid_;
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOnline::set_allocated_device_udid(::std::string* device_udid) {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_udid_;
        }
        if (device_udid) {
            set_has_device_udid();
            device_udid_ = device_udid;
        } else {
            clear_has_device_udid();
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOnline.device_udid)
    }
    
    // required string device_info = 4;
    inline bool QuestionOnline::has_device_info() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void QuestionOnline::set_has_device_info() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void QuestionOnline::clear_has_device_info() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void QuestionOnline::clear_device_info() {
        if (device_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_info_->clear();
        }
        clear_has_device_info();
    }
    inline const ::std::string& QuestionOnline::device_info() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOnline.device_info)
        return *device_info_;
    }
    inline void QuestionOnline::set_device_info(const ::std::string& value) {
        set_has_device_info();
        if (device_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_info_ = new ::std::string;
        }
        device_info_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOnline.device_info)
    }
    inline void QuestionOnline::set_device_info(const char* value) {
        set_has_device_info();
        if (device_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_info_ = new ::std::string;
        }
        device_info_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOnline.device_info)
    }
    inline void QuestionOnline::set_device_info(const char* value, size_t size) {
        set_has_device_info();
        if (device_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_info_ = new ::std::string;
        }
        device_info_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOnline.device_info)
    }
    inline ::std::string* QuestionOnline::mutable_device_info() {
        set_has_device_info();
        if (device_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_info_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOnline.device_info)
        return device_info_;
    }
    inline ::std::string* QuestionOnline::release_device_info() {
        clear_has_device_info();
        if (device_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_info_;
            device_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOnline::set_allocated_device_info(::std::string* device_info) {
        if (device_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_info_;
        }
        if (device_info) {
            set_has_device_info();
            device_info_ = device_info;
        } else {
            clear_has_device_info();
            device_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOnline.device_info)
    }
    
    // optional string local_info = 5;
    inline bool QuestionOnline::has_local_info() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void QuestionOnline::set_has_local_info() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void QuestionOnline::clear_has_local_info() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void QuestionOnline::clear_local_info() {
        if (local_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            local_info_->clear();
        }
        clear_has_local_info();
    }
    inline const ::std::string& QuestionOnline::local_info() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOnline.local_info)
        return *local_info_;
    }
    inline void QuestionOnline::set_local_info(const ::std::string& value) {
        set_has_local_info();
        if (local_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            local_info_ = new ::std::string;
        }
        local_info_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOnline.local_info)
    }
    inline void QuestionOnline::set_local_info(const char* value) {
        set_has_local_info();
        if (local_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            local_info_ = new ::std::string;
        }
        local_info_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOnline.local_info)
    }
    inline void QuestionOnline::set_local_info(const char* value, size_t size) {
        set_has_local_info();
        if (local_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            local_info_ = new ::std::string;
        }
        local_info_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOnline.local_info)
    }
    inline ::std::string* QuestionOnline::mutable_local_info() {
        set_has_local_info();
        if (local_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            local_info_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOnline.local_info)
        return local_info_;
    }
    inline ::std::string* QuestionOnline::release_local_info() {
        clear_has_local_info();
        if (local_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = local_info_;
            local_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOnline::set_allocated_local_info(::std::string* local_info) {
        if (local_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete local_info_;
        }
        if (local_info) {
            set_has_local_info();
            local_info_ = local_info;
        } else {
            clear_has_local_info();
            local_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOnline.local_info)
    }
    
    // -------------------------------------------------------------------
    
    // QuestionOffline
    
    // required string token = 1;
    inline bool QuestionOffline::has_token() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void QuestionOffline::set_has_token() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void QuestionOffline::clear_has_token() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void QuestionOffline::clear_token() {
        if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_->clear();
        }
        clear_has_token();
    }
    inline const ::std::string& QuestionOffline::token() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOffline.token)
        return *token_;
    }
    inline void QuestionOffline::set_token(const ::std::string& value) {
        set_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_ = new ::std::string;
        }
        token_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOffline.token)
    }
    inline void QuestionOffline::set_token(const char* value) {
        set_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_ = new ::std::string;
        }
        token_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOffline.token)
    }
    inline void QuestionOffline::set_token(const char* value, size_t size) {
        set_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_ = new ::std::string;
        }
        token_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOffline.token)
    }
    inline ::std::string* QuestionOffline::mutable_token() {
        set_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOffline.token)
        return token_;
    }
    inline ::std::string* QuestionOffline::release_token() {
        clear_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = token_;
            token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOffline::set_allocated_token(::std::string* token) {
        if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete token_;
        }
        if (token) {
            set_has_token();
            token_ = token;
        } else {
            clear_has_token();
            token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOffline.token)
    }
    
    // required string device_udid = 2;
    inline bool QuestionOffline::has_device_udid() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void QuestionOffline::set_has_device_udid() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void QuestionOffline::clear_has_device_udid() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void QuestionOffline::clear_device_udid() {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_->clear();
        }
        clear_has_device_udid();
    }
    inline const ::std::string& QuestionOffline::device_udid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOffline.device_udid)
        return *device_udid_;
    }
    inline void QuestionOffline::set_device_udid(const ::std::string& value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOffline.device_udid)
    }
    inline void QuestionOffline::set_device_udid(const char* value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOffline.device_udid)
    }
    inline void QuestionOffline::set_device_udid(const char* value, size_t size) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOffline.device_udid)
    }
    inline ::std::string* QuestionOffline::mutable_device_udid() {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOffline.device_udid)
        return device_udid_;
    }
    inline ::std::string* QuestionOffline::release_device_udid() {
        clear_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_udid_;
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOffline::set_allocated_device_udid(::std::string* device_udid) {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_udid_;
        }
        if (device_udid) {
            set_has_device_udid();
            device_udid_ = device_udid;
        } else {
            clear_has_device_udid();
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOffline.device_udid)
    }
    
    // required string device_info = 3;
    inline bool QuestionOffline::has_device_info() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void QuestionOffline::set_has_device_info() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void QuestionOffline::clear_has_device_info() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void QuestionOffline::clear_device_info() {
        if (device_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_info_->clear();
        }
        clear_has_device_info();
    }
    inline const ::std::string& QuestionOffline::device_info() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOffline.device_info)
        return *device_info_;
    }
    inline void QuestionOffline::set_device_info(const ::std::string& value) {
        set_has_device_info();
        if (device_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_info_ = new ::std::string;
        }
        device_info_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOffline.device_info)
    }
    inline void QuestionOffline::set_device_info(const char* value) {
        set_has_device_info();
        if (device_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_info_ = new ::std::string;
        }
        device_info_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOffline.device_info)
    }
    inline void QuestionOffline::set_device_info(const char* value, size_t size) {
        set_has_device_info();
        if (device_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_info_ = new ::std::string;
        }
        device_info_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOffline.device_info)
    }
    inline ::std::string* QuestionOffline::mutable_device_info() {
        set_has_device_info();
        if (device_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_info_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOffline.device_info)
        return device_info_;
    }
    inline ::std::string* QuestionOffline::release_device_info() {
        clear_has_device_info();
        if (device_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_info_;
            device_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOffline::set_allocated_device_info(::std::string* device_info) {
        if (device_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_info_;
        }
        if (device_info) {
            set_has_device_info();
            device_info_ = device_info;
        } else {
            clear_has_device_info();
            device_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOffline.device_info)
    }
    
    // required string local_info = 4;
    inline bool QuestionOffline::has_local_info() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void QuestionOffline::set_has_local_info() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void QuestionOffline::clear_has_local_info() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void QuestionOffline::clear_local_info() {
        if (local_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            local_info_->clear();
        }
        clear_has_local_info();
    }
    inline const ::std::string& QuestionOffline::local_info() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOffline.local_info)
        return *local_info_;
    }
    inline void QuestionOffline::set_local_info(const ::std::string& value) {
        set_has_local_info();
        if (local_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            local_info_ = new ::std::string;
        }
        local_info_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOffline.local_info)
    }
    inline void QuestionOffline::set_local_info(const char* value) {
        set_has_local_info();
        if (local_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            local_info_ = new ::std::string;
        }
        local_info_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOffline.local_info)
    }
    inline void QuestionOffline::set_local_info(const char* value, size_t size) {
        set_has_local_info();
        if (local_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            local_info_ = new ::std::string;
        }
        local_info_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOffline.local_info)
    }
    inline ::std::string* QuestionOffline::mutable_local_info() {
        set_has_local_info();
        if (local_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            local_info_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOffline.local_info)
        return local_info_;
    }
    inline ::std::string* QuestionOffline::release_local_info() {
        clear_has_local_info();
        if (local_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = local_info_;
            local_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOffline::set_allocated_local_info(::std::string* local_info) {
        if (local_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete local_info_;
        }
        if (local_info) {
            set_has_local_info();
            local_info_ = local_info;
        } else {
            clear_has_local_info();
            local_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOffline.local_info)
    }
    
    // required string time_stamp = 5;
    inline bool QuestionOffline::has_time_stamp() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void QuestionOffline::set_has_time_stamp() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void QuestionOffline::clear_has_time_stamp() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void QuestionOffline::clear_time_stamp() {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_->clear();
        }
        clear_has_time_stamp();
    }
    inline const ::std::string& QuestionOffline::time_stamp() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOffline.time_stamp)
        return *time_stamp_;
    }
    inline void QuestionOffline::set_time_stamp(const ::std::string& value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOffline.time_stamp)
    }
    inline void QuestionOffline::set_time_stamp(const char* value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOffline.time_stamp)
    }
    inline void QuestionOffline::set_time_stamp(const char* value, size_t size) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOffline.time_stamp)
    }
    inline ::std::string* QuestionOffline::mutable_time_stamp() {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOffline.time_stamp)
        return time_stamp_;
    }
    inline ::std::string* QuestionOffline::release_time_stamp() {
        clear_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = time_stamp_;
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOffline::set_allocated_time_stamp(::std::string* time_stamp) {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete time_stamp_;
        }
        if (time_stamp) {
            set_has_time_stamp();
            time_stamp_ = time_stamp;
        } else {
            clear_has_time_stamp();
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOffline.time_stamp)
    }
    
    // required int64 fid = 6;
    inline bool QuestionOffline::has_fid() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void QuestionOffline::set_has_fid() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void QuestionOffline::clear_has_fid() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void QuestionOffline::clear_fid() {
        fid_ = GOOGLE_LONGLONG(0);
        clear_has_fid();
    }
    inline ::google::protobuf::int64 QuestionOffline::fid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOffline.fid)
        return fid_;
    }
    inline void QuestionOffline::set_fid(::google::protobuf::int64 value) {
        set_has_fid();
        fid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionOffline.fid)
    }
    
    // required string f_avatar = 7;
    inline bool QuestionOffline::has_f_avatar() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void QuestionOffline::set_has_f_avatar() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void QuestionOffline::clear_has_f_avatar() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void QuestionOffline::clear_f_avatar() {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_->clear();
        }
        clear_has_f_avatar();
    }
    inline const ::std::string& QuestionOffline::f_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOffline.f_avatar)
        return *f_avatar_;
    }
    inline void QuestionOffline::set_f_avatar(const ::std::string& value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOffline.f_avatar)
    }
    inline void QuestionOffline::set_f_avatar(const char* value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOffline.f_avatar)
    }
    inline void QuestionOffline::set_f_avatar(const char* value, size_t size) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOffline.f_avatar)
    }
    inline ::std::string* QuestionOffline::mutable_f_avatar() {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOffline.f_avatar)
        return f_avatar_;
    }
    inline ::std::string* QuestionOffline::release_f_avatar() {
        clear_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_avatar_;
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOffline::set_allocated_f_avatar(::std::string* f_avatar) {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_avatar_;
        }
        if (f_avatar) {
            set_has_f_avatar();
            f_avatar_ = f_avatar;
        } else {
            clear_has_f_avatar();
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOffline.f_avatar)
    }
    
    // required string f_name = 8;
    inline bool QuestionOffline::has_f_name() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void QuestionOffline::set_has_f_name() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void QuestionOffline::clear_has_f_name() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void QuestionOffline::clear_f_name() {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_->clear();
        }
        clear_has_f_name();
    }
    inline const ::std::string& QuestionOffline::f_name() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOffline.f_name)
        return *f_name_;
    }
    inline void QuestionOffline::set_f_name(const ::std::string& value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOffline.f_name)
    }
    inline void QuestionOffline::set_f_name(const char* value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOffline.f_name)
    }
    inline void QuestionOffline::set_f_name(const char* value, size_t size) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOffline.f_name)
    }
    inline ::std::string* QuestionOffline::mutable_f_name() {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOffline.f_name)
        return f_name_;
    }
    inline ::std::string* QuestionOffline::release_f_name() {
        clear_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_name_;
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOffline::set_allocated_f_name(::std::string* f_name) {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_name_;
        }
        if (f_name) {
            set_has_f_name();
            f_name_ = f_name;
        } else {
            clear_has_f_name();
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOffline.f_name)
    }
    
    // required string f_leve = 9;
    inline bool QuestionOffline::has_f_leve() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void QuestionOffline::set_has_f_leve() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void QuestionOffline::clear_has_f_leve() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void QuestionOffline::clear_f_leve() {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_->clear();
        }
        clear_has_f_leve();
    }
    inline const ::std::string& QuestionOffline::f_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOffline.f_leve)
        return *f_leve_;
    }
    inline void QuestionOffline::set_f_leve(const ::std::string& value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOffline.f_leve)
    }
    inline void QuestionOffline::set_f_leve(const char* value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOffline.f_leve)
    }
    inline void QuestionOffline::set_f_leve(const char* value, size_t size) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOffline.f_leve)
    }
    inline ::std::string* QuestionOffline::mutable_f_leve() {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOffline.f_leve)
        return f_leve_;
    }
    inline ::std::string* QuestionOffline::release_f_leve() {
        clear_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_leve_;
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOffline::set_allocated_f_leve(::std::string* f_leve) {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_leve_;
        }
        if (f_leve) {
            set_has_f_leve();
            f_leve_ = f_leve;
        } else {
            clear_has_f_leve();
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOffline.f_leve)
    }
    
    // required string f_user_type = 10;
    inline bool QuestionOffline::has_f_user_type() const {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void QuestionOffline::set_has_f_user_type() {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void QuestionOffline::clear_has_f_user_type() {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void QuestionOffline::clear_f_user_type() {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_->clear();
        }
        clear_has_f_user_type();
    }
    inline const ::std::string& QuestionOffline::f_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionOffline.f_user_type)
        return *f_user_type_;
    }
    inline void QuestionOffline::set_f_user_type(const ::std::string& value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionOffline.f_user_type)
    }
    inline void QuestionOffline::set_f_user_type(const char* value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionOffline.f_user_type)
    }
    inline void QuestionOffline::set_f_user_type(const char* value, size_t size) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionOffline.f_user_type)
    }
    inline ::std::string* QuestionOffline::mutable_f_user_type() {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionOffline.f_user_type)
        return f_user_type_;
    }
    inline ::std::string* QuestionOffline::release_f_user_type() {
        clear_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_user_type_;
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionOffline::set_allocated_f_user_type(::std::string* f_user_type) {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_user_type_;
        }
        if (f_user_type) {
            set_has_f_user_type();
            f_user_type_ = f_user_type;
        } else {
            clear_has_f_user_type();
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionOffline.f_user_type)
    }
    
    // -------------------------------------------------------------------
    
    // QuestionSendedAnswerBack
    
    // required string f_time_stamp = 1;
    inline bool QuestionSendedAnswerBack::has_f_time_stamp() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void QuestionSendedAnswerBack::set_has_f_time_stamp() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void QuestionSendedAnswerBack::clear_has_f_time_stamp() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void QuestionSendedAnswerBack::clear_f_time_stamp() {
        if (f_time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_time_stamp_->clear();
        }
        clear_has_f_time_stamp();
    }
    inline const ::std::string& QuestionSendedAnswerBack::f_time_stamp() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionSendedAnswerBack.f_time_stamp)
        return *f_time_stamp_;
    }
    inline void QuestionSendedAnswerBack::set_f_time_stamp(const ::std::string& value) {
        set_has_f_time_stamp();
        if (f_time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_time_stamp_ = new ::std::string;
        }
        f_time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionSendedAnswerBack.f_time_stamp)
    }
    inline void QuestionSendedAnswerBack::set_f_time_stamp(const char* value) {
        set_has_f_time_stamp();
        if (f_time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_time_stamp_ = new ::std::string;
        }
        f_time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionSendedAnswerBack.f_time_stamp)
    }
    inline void QuestionSendedAnswerBack::set_f_time_stamp(const char* value, size_t size) {
        set_has_f_time_stamp();
        if (f_time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_time_stamp_ = new ::std::string;
        }
        f_time_stamp_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionSendedAnswerBack.f_time_stamp)
    }
    inline ::std::string* QuestionSendedAnswerBack::mutable_f_time_stamp() {
        set_has_f_time_stamp();
        if (f_time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_time_stamp_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionSendedAnswerBack.f_time_stamp)
        return f_time_stamp_;
    }
    inline ::std::string* QuestionSendedAnswerBack::release_f_time_stamp() {
        clear_has_f_time_stamp();
        if (f_time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_time_stamp_;
            f_time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionSendedAnswerBack::set_allocated_f_time_stamp(::std::string* f_time_stamp) {
        if (f_time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_time_stamp_;
        }
        if (f_time_stamp) {
            set_has_f_time_stamp();
            f_time_stamp_ = f_time_stamp;
        } else {
            clear_has_f_time_stamp();
            f_time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionSendedAnswerBack.f_time_stamp)
    }
    
    // required string f_user_id = 2;
    inline bool QuestionSendedAnswerBack::has_f_user_id() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void QuestionSendedAnswerBack::set_has_f_user_id() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void QuestionSendedAnswerBack::clear_has_f_user_id() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void QuestionSendedAnswerBack::clear_f_user_id() {
        if (f_user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_id_->clear();
        }
        clear_has_f_user_id();
    }
    inline const ::std::string& QuestionSendedAnswerBack::f_user_id() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionSendedAnswerBack.f_user_id)
        return *f_user_id_;
    }
    inline void QuestionSendedAnswerBack::set_f_user_id(const ::std::string& value) {
        set_has_f_user_id();
        if (f_user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_id_ = new ::std::string;
        }
        f_user_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionSendedAnswerBack.f_user_id)
    }
    inline void QuestionSendedAnswerBack::set_f_user_id(const char* value) {
        set_has_f_user_id();
        if (f_user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_id_ = new ::std::string;
        }
        f_user_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionSendedAnswerBack.f_user_id)
    }
    inline void QuestionSendedAnswerBack::set_f_user_id(const char* value, size_t size) {
        set_has_f_user_id();
        if (f_user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_id_ = new ::std::string;
        }
        f_user_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionSendedAnswerBack.f_user_id)
    }
    inline ::std::string* QuestionSendedAnswerBack::mutable_f_user_id() {
        set_has_f_user_id();
        if (f_user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionSendedAnswerBack.f_user_id)
        return f_user_id_;
    }
    inline ::std::string* QuestionSendedAnswerBack::release_f_user_id() {
        clear_has_f_user_id();
        if (f_user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_user_id_;
            f_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionSendedAnswerBack::set_allocated_f_user_id(::std::string* f_user_id) {
        if (f_user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_user_id_;
        }
        if (f_user_id) {
            set_has_f_user_id();
            f_user_id_ = f_user_id;
        } else {
            clear_has_f_user_id();
            f_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionSendedAnswerBack.f_user_id)
    }
    
    // required string f_udid = 3;
    inline bool QuestionSendedAnswerBack::has_f_udid() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void QuestionSendedAnswerBack::set_has_f_udid() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void QuestionSendedAnswerBack::clear_has_f_udid() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void QuestionSendedAnswerBack::clear_f_udid() {
        if (f_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_udid_->clear();
        }
        clear_has_f_udid();
    }
    inline const ::std::string& QuestionSendedAnswerBack::f_udid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionSendedAnswerBack.f_udid)
        return *f_udid_;
    }
    inline void QuestionSendedAnswerBack::set_f_udid(const ::std::string& value) {
        set_has_f_udid();
        if (f_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_udid_ = new ::std::string;
        }
        f_udid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionSendedAnswerBack.f_udid)
    }
    inline void QuestionSendedAnswerBack::set_f_udid(const char* value) {
        set_has_f_udid();
        if (f_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_udid_ = new ::std::string;
        }
        f_udid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionSendedAnswerBack.f_udid)
    }
    inline void QuestionSendedAnswerBack::set_f_udid(const char* value, size_t size) {
        set_has_f_udid();
        if (f_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_udid_ = new ::std::string;
        }
        f_udid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionSendedAnswerBack.f_udid)
    }
    inline ::std::string* QuestionSendedAnswerBack::mutable_f_udid() {
        set_has_f_udid();
        if (f_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_udid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionSendedAnswerBack.f_udid)
        return f_udid_;
    }
    inline ::std::string* QuestionSendedAnswerBack::release_f_udid() {
        clear_has_f_udid();
        if (f_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_udid_;
            f_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionSendedAnswerBack::set_allocated_f_udid(::std::string* f_udid) {
        if (f_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_udid_;
        }
        if (f_udid) {
            set_has_f_udid();
            f_udid_ = f_udid;
        } else {
            clear_has_f_udid();
            f_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionSendedAnswerBack.f_udid)
    }
    
    // required string server_time_stamp = 4;
    inline bool QuestionSendedAnswerBack::has_server_time_stamp() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void QuestionSendedAnswerBack::set_has_server_time_stamp() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void QuestionSendedAnswerBack::clear_has_server_time_stamp() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void QuestionSendedAnswerBack::clear_server_time_stamp() {
        if (server_time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            server_time_stamp_->clear();
        }
        clear_has_server_time_stamp();
    }
    inline const ::std::string& QuestionSendedAnswerBack::server_time_stamp() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionSendedAnswerBack.server_time_stamp)
        return *server_time_stamp_;
    }
    inline void QuestionSendedAnswerBack::set_server_time_stamp(const ::std::string& value) {
        set_has_server_time_stamp();
        if (server_time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            server_time_stamp_ = new ::std::string;
        }
        server_time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionSendedAnswerBack.server_time_stamp)
    }
    inline void QuestionSendedAnswerBack::set_server_time_stamp(const char* value) {
        set_has_server_time_stamp();
        if (server_time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            server_time_stamp_ = new ::std::string;
        }
        server_time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionSendedAnswerBack.server_time_stamp)
    }
    inline void QuestionSendedAnswerBack::set_server_time_stamp(const char* value, size_t size) {
        set_has_server_time_stamp();
        if (server_time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            server_time_stamp_ = new ::std::string;
        }
        server_time_stamp_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionSendedAnswerBack.server_time_stamp)
    }
    inline ::std::string* QuestionSendedAnswerBack::mutable_server_time_stamp() {
        set_has_server_time_stamp();
        if (server_time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            server_time_stamp_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionSendedAnswerBack.server_time_stamp)
        return server_time_stamp_;
    }
    inline ::std::string* QuestionSendedAnswerBack::release_server_time_stamp() {
        clear_has_server_time_stamp();
        if (server_time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = server_time_stamp_;
            server_time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionSendedAnswerBack::set_allocated_server_time_stamp(::std::string* server_time_stamp) {
        if (server_time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete server_time_stamp_;
        }
        if (server_time_stamp) {
            set_has_server_time_stamp();
            server_time_stamp_ = server_time_stamp;
        } else {
            clear_has_server_time_stamp();
            server_time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionSendedAnswerBack.server_time_stamp)
    }
    
    // -------------------------------------------------------------------
    
    // QuestionHistory
    
    // required .QSChat.ChatRequestType ctype = 1;
    inline bool QuestionHistory::has_ctype() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void QuestionHistory::set_has_ctype() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void QuestionHistory::clear_has_ctype() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void QuestionHistory::clear_ctype() {
        ctype_ = 8000;
        clear_has_ctype();
    }
    inline ::QSChat::ChatRequestType QuestionHistory::ctype() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionHistory.ctype)
        return static_cast< ::QSChat::ChatRequestType >(ctype_);
    }
    inline void QuestionHistory::set_ctype(::QSChat::ChatRequestType value) {
        assert(::QSChat::ChatRequestType_IsValid(value));
        set_has_ctype();
        ctype_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionHistory.ctype)
    }
    
    // required string token = 2;
    inline bool QuestionHistory::has_token() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void QuestionHistory::set_has_token() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void QuestionHistory::clear_has_token() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void QuestionHistory::clear_token() {
        if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_->clear();
        }
        clear_has_token();
    }
    inline const ::std::string& QuestionHistory::token() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionHistory.token)
        return *token_;
    }
    inline void QuestionHistory::set_token(const ::std::string& value) {
        set_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_ = new ::std::string;
        }
        token_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionHistory.token)
    }
    inline void QuestionHistory::set_token(const char* value) {
        set_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_ = new ::std::string;
        }
        token_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionHistory.token)
    }
    inline void QuestionHistory::set_token(const char* value, size_t size) {
        set_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_ = new ::std::string;
        }
        token_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionHistory.token)
    }
    inline ::std::string* QuestionHistory::mutable_token() {
        set_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            token_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionHistory.token)
        return token_;
    }
    inline ::std::string* QuestionHistory::release_token() {
        clear_has_token();
        if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = token_;
            token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionHistory::set_allocated_token(::std::string* token) {
        if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete token_;
        }
        if (token) {
            set_has_token();
            token_ = token;
        } else {
            clear_has_token();
            token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionHistory.token)
    }
    
    // required string wid = 3;
    inline bool QuestionHistory::has_wid() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void QuestionHistory::set_has_wid() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void QuestionHistory::clear_has_wid() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void QuestionHistory::clear_wid() {
        if (wid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            wid_->clear();
        }
        clear_has_wid();
    }
    inline const ::std::string& QuestionHistory::wid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionHistory.wid)
        return *wid_;
    }
    inline void QuestionHistory::set_wid(const ::std::string& value) {
        set_has_wid();
        if (wid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            wid_ = new ::std::string;
        }
        wid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionHistory.wid)
    }
    inline void QuestionHistory::set_wid(const char* value) {
        set_has_wid();
        if (wid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            wid_ = new ::std::string;
        }
        wid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionHistory.wid)
    }
    inline void QuestionHistory::set_wid(const char* value, size_t size) {
        set_has_wid();
        if (wid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            wid_ = new ::std::string;
        }
        wid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionHistory.wid)
    }
    inline ::std::string* QuestionHistory::mutable_wid() {
        set_has_wid();
        if (wid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            wid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionHistory.wid)
        return wid_;
    }
    inline ::std::string* QuestionHistory::release_wid() {
        clear_has_wid();
        if (wid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = wid_;
            wid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionHistory::set_allocated_wid(::std::string* wid) {
        if (wid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete wid_;
        }
        if (wid) {
            set_has_wid();
            wid_ = wid;
        } else {
            clear_has_wid();
            wid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionHistory.wid)
    }
    
    // required string page_num = 4;
    inline bool QuestionHistory::has_page_num() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void QuestionHistory::set_has_page_num() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void QuestionHistory::clear_has_page_num() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void QuestionHistory::clear_page_num() {
        if (page_num_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            page_num_->clear();
        }
        clear_has_page_num();
    }
    inline const ::std::string& QuestionHistory::page_num() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionHistory.page_num)
        return *page_num_;
    }
    inline void QuestionHistory::set_page_num(const ::std::string& value) {
        set_has_page_num();
        if (page_num_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            page_num_ = new ::std::string;
        }
        page_num_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionHistory.page_num)
    }
    inline void QuestionHistory::set_page_num(const char* value) {
        set_has_page_num();
        if (page_num_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            page_num_ = new ::std::string;
        }
        page_num_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionHistory.page_num)
    }
    inline void QuestionHistory::set_page_num(const char* value, size_t size) {
        set_has_page_num();
        if (page_num_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            page_num_ = new ::std::string;
        }
        page_num_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionHistory.page_num)
    }
    inline ::std::string* QuestionHistory::mutable_page_num() {
        set_has_page_num();
        if (page_num_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            page_num_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionHistory.page_num)
        return page_num_;
    }
    inline ::std::string* QuestionHistory::release_page_num() {
        clear_has_page_num();
        if (page_num_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = page_num_;
            page_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionHistory::set_allocated_page_num(::std::string* page_num) {
        if (page_num_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete page_num_;
        }
        if (page_num) {
            set_has_page_num();
            page_num_ = page_num;
        } else {
            clear_has_page_num();
            page_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionHistory.page_num)
    }
    
    // required string current_page = 5;
    inline bool QuestionHistory::has_current_page() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void QuestionHistory::set_has_current_page() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void QuestionHistory::clear_has_current_page() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void QuestionHistory::clear_current_page() {
        if (current_page_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            current_page_->clear();
        }
        clear_has_current_page();
    }
    inline const ::std::string& QuestionHistory::current_page() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionHistory.current_page)
        return *current_page_;
    }
    inline void QuestionHistory::set_current_page(const ::std::string& value) {
        set_has_current_page();
        if (current_page_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            current_page_ = new ::std::string;
        }
        current_page_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionHistory.current_page)
    }
    inline void QuestionHistory::set_current_page(const char* value) {
        set_has_current_page();
        if (current_page_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            current_page_ = new ::std::string;
        }
        current_page_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionHistory.current_page)
    }
    inline void QuestionHistory::set_current_page(const char* value, size_t size) {
        set_has_current_page();
        if (current_page_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            current_page_ = new ::std::string;
        }
        current_page_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionHistory.current_page)
    }
    inline ::std::string* QuestionHistory::mutable_current_page() {
        set_has_current_page();
        if (current_page_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            current_page_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionHistory.current_page)
        return current_page_;
    }
    inline ::std::string* QuestionHistory::release_current_page() {
        clear_has_current_page();
        if (current_page_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = current_page_;
            current_page_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionHistory::set_allocated_current_page(::std::string* current_page) {
        if (current_page_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete current_page_;
        }
        if (current_page) {
            set_has_current_page();
            current_page_ = current_page;
        } else {
            clear_has_current_page();
            current_page_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionHistory.current_page)
    }
    
    // required string last_id = 6;
    inline bool QuestionHistory::has_last_id() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void QuestionHistory::set_has_last_id() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void QuestionHistory::clear_has_last_id() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void QuestionHistory::clear_last_id() {
        if (last_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            last_id_->clear();
        }
        clear_has_last_id();
    }
    inline const ::std::string& QuestionHistory::last_id() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionHistory.last_id)
        return *last_id_;
    }
    inline void QuestionHistory::set_last_id(const ::std::string& value) {
        set_has_last_id();
        if (last_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            last_id_ = new ::std::string;
        }
        last_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionHistory.last_id)
    }
    inline void QuestionHistory::set_last_id(const char* value) {
        set_has_last_id();
        if (last_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            last_id_ = new ::std::string;
        }
        last_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionHistory.last_id)
    }
    inline void QuestionHistory::set_last_id(const char* value, size_t size) {
        set_has_last_id();
        if (last_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            last_id_ = new ::std::string;
        }
        last_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionHistory.last_id)
    }
    inline ::std::string* QuestionHistory::mutable_last_id() {
        set_has_last_id();
        if (last_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            last_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionHistory.last_id)
        return last_id_;
    }
    inline ::std::string* QuestionHistory::release_last_id() {
        clear_has_last_id();
        if (last_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = last_id_;
            last_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionHistory::set_allocated_last_id(::std::string* last_id) {
        if (last_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete last_id_;
        }
        if (last_id) {
            set_has_last_id();
            last_id_ = last_id;
        } else {
            clear_has_last_id();
            last_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionHistory.last_id)
    }
    
    // -------------------------------------------------------------------
    
    // QuestionWord
    
    // required int64 mid = 1;
    inline bool QuestionWord::has_mid() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void QuestionWord::set_has_mid() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void QuestionWord::clear_has_mid() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void QuestionWord::clear_mid() {
        mid_ = GOOGLE_LONGLONG(0);
        clear_has_mid();
    }
    inline ::google::protobuf::int64 QuestionWord::mid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.mid)
        return mid_;
    }
    inline void QuestionWord::set_mid(::google::protobuf::int64 value) {
        set_has_mid();
        mid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.mid)
    }
    
    // required int64 tid = 2;
    inline bool QuestionWord::has_tid() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void QuestionWord::set_has_tid() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void QuestionWord::clear_has_tid() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void QuestionWord::clear_tid() {
        tid_ = GOOGLE_LONGLONG(0);
        clear_has_tid();
    }
    inline ::google::protobuf::int64 QuestionWord::tid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.tid)
        return tid_;
    }
    inline void QuestionWord::set_tid(::google::protobuf::int64 value) {
        set_has_tid();
        tid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.tid)
    }
    
    // required .QSChat.ChatRequestType ctype = 3;
    inline bool QuestionWord::has_ctype() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void QuestionWord::set_has_ctype() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void QuestionWord::clear_has_ctype() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void QuestionWord::clear_ctype() {
        ctype_ = 8000;
        clear_has_ctype();
    }
    inline ::QSChat::ChatRequestType QuestionWord::ctype() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.ctype)
        return static_cast< ::QSChat::ChatRequestType >(ctype_);
    }
    inline void QuestionWord::set_ctype(::QSChat::ChatRequestType value) {
        assert(::QSChat::ChatRequestType_IsValid(value));
        set_has_ctype();
        ctype_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.ctype)
    }
    
    // required string message = 4;
    inline bool QuestionWord::has_message() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void QuestionWord::set_has_message() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void QuestionWord::clear_has_message() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void QuestionWord::clear_message() {
        if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            message_->clear();
        }
        clear_has_message();
    }
    inline const ::std::string& QuestionWord::message() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.message)
        return *message_;
    }
    inline void QuestionWord::set_message(const ::std::string& value) {
        set_has_message();
        if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            message_ = new ::std::string;
        }
        message_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.message)
    }
    inline void QuestionWord::set_message(const char* value) {
        set_has_message();
        if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            message_ = new ::std::string;
        }
        message_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionWord.message)
    }
    inline void QuestionWord::set_message(const char* value, size_t size) {
        set_has_message();
        if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            message_ = new ::std::string;
        }
        message_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionWord.message)
    }
    inline ::std::string* QuestionWord::mutable_message() {
        set_has_message();
        if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            message_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionWord.message)
        return message_;
    }
    inline ::std::string* QuestionWord::release_message() {
        clear_has_message();
        if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = message_;
            message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionWord::set_allocated_message(::std::string* message) {
        if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete message_;
        }
        if (message) {
            set_has_message();
            message_ = message;
        } else {
            clear_has_message();
            message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionWord.message)
    }
    
    // required string time_stamp = 5;
    inline bool QuestionWord::has_time_stamp() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void QuestionWord::set_has_time_stamp() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void QuestionWord::clear_has_time_stamp() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void QuestionWord::clear_time_stamp() {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_->clear();
        }
        clear_has_time_stamp();
    }
    inline const ::std::string& QuestionWord::time_stamp() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.time_stamp)
        return *time_stamp_;
    }
    inline void QuestionWord::set_time_stamp(const ::std::string& value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.time_stamp)
    }
    inline void QuestionWord::set_time_stamp(const char* value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionWord.time_stamp)
    }
    inline void QuestionWord::set_time_stamp(const char* value, size_t size) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionWord.time_stamp)
    }
    inline ::std::string* QuestionWord::mutable_time_stamp() {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionWord.time_stamp)
        return time_stamp_;
    }
    inline ::std::string* QuestionWord::release_time_stamp() {
        clear_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = time_stamp_;
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionWord::set_allocated_time_stamp(::std::string* time_stamp) {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete time_stamp_;
        }
        if (time_stamp) {
            set_has_time_stamp();
            time_stamp_ = time_stamp;
        } else {
            clear_has_time_stamp();
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionWord.time_stamp)
    }
    
    // required string t_avatar = 6;
    inline bool QuestionWord::has_t_avatar() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void QuestionWord::set_has_t_avatar() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void QuestionWord::clear_has_t_avatar() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void QuestionWord::clear_t_avatar() {
        if (t_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_->clear();
        }
        clear_has_t_avatar();
    }
    inline const ::std::string& QuestionWord::t_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.t_avatar)
        return *t_avatar_;
    }
    inline void QuestionWord::set_t_avatar(const ::std::string& value) {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        t_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.t_avatar)
    }
    inline void QuestionWord::set_t_avatar(const char* value) {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        t_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionWord.t_avatar)
    }
    inline void QuestionWord::set_t_avatar(const char* value, size_t size) {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        t_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionWord.t_avatar)
    }
    inline ::std::string* QuestionWord::mutable_t_avatar() {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionWord.t_avatar)
        return t_avatar_;
    }
    inline ::std::string* QuestionWord::release_t_avatar() {
        clear_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_avatar_;
            t_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionWord::set_allocated_t_avatar(::std::string* t_avatar) {
        if (t_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_avatar_;
        }
        if (t_avatar) {
            set_has_t_avatar();
            t_avatar_ = t_avatar;
        } else {
            clear_has_t_avatar();
            t_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionWord.t_avatar)
    }
    
    // required string t_name = 7;
    inline bool QuestionWord::has_t_name() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void QuestionWord::set_has_t_name() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void QuestionWord::clear_has_t_name() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void QuestionWord::clear_t_name() {
        if (t_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_->clear();
        }
        clear_has_t_name();
    }
    inline const ::std::string& QuestionWord::t_name() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.t_name)
        return *t_name_;
    }
    inline void QuestionWord::set_t_name(const ::std::string& value) {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        t_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.t_name)
    }
    inline void QuestionWord::set_t_name(const char* value) {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        t_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionWord.t_name)
    }
    inline void QuestionWord::set_t_name(const char* value, size_t size) {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        t_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionWord.t_name)
    }
    inline ::std::string* QuestionWord::mutable_t_name() {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionWord.t_name)
        return t_name_;
    }
    inline ::std::string* QuestionWord::release_t_name() {
        clear_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_name_;
            t_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionWord::set_allocated_t_name(::std::string* t_name) {
        if (t_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_name_;
        }
        if (t_name) {
            set_has_t_name();
            t_name_ = t_name;
        } else {
            clear_has_t_name();
            t_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionWord.t_name)
    }
    
    // required string t_leve = 8;
    inline bool QuestionWord::has_t_leve() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void QuestionWord::set_has_t_leve() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void QuestionWord::clear_has_t_leve() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void QuestionWord::clear_t_leve() {
        if (t_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_->clear();
        }
        clear_has_t_leve();
    }
    inline const ::std::string& QuestionWord::t_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.t_leve)
        return *t_leve_;
    }
    inline void QuestionWord::set_t_leve(const ::std::string& value) {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        t_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.t_leve)
    }
    inline void QuestionWord::set_t_leve(const char* value) {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        t_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionWord.t_leve)
    }
    inline void QuestionWord::set_t_leve(const char* value, size_t size) {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        t_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionWord.t_leve)
    }
    inline ::std::string* QuestionWord::mutable_t_leve() {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionWord.t_leve)
        return t_leve_;
    }
    inline ::std::string* QuestionWord::release_t_leve() {
        clear_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_leve_;
            t_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionWord::set_allocated_t_leve(::std::string* t_leve) {
        if (t_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_leve_;
        }
        if (t_leve) {
            set_has_t_leve();
            t_leve_ = t_leve;
        } else {
            clear_has_t_leve();
            t_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionWord.t_leve)
    }
    
    // required string t_user_type = 9;
    inline bool QuestionWord::has_t_user_type() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void QuestionWord::set_has_t_user_type() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void QuestionWord::clear_has_t_user_type() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void QuestionWord::clear_t_user_type() {
        if (t_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_->clear();
        }
        clear_has_t_user_type();
    }
    inline const ::std::string& QuestionWord::t_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.t_user_type)
        return *t_user_type_;
    }
    inline void QuestionWord::set_t_user_type(const ::std::string& value) {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        t_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.t_user_type)
    }
    inline void QuestionWord::set_t_user_type(const char* value) {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        t_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionWord.t_user_type)
    }
    inline void QuestionWord::set_t_user_type(const char* value, size_t size) {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        t_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionWord.t_user_type)
    }
    inline ::std::string* QuestionWord::mutable_t_user_type() {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionWord.t_user_type)
        return t_user_type_;
    }
    inline ::std::string* QuestionWord::release_t_user_type() {
        clear_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_user_type_;
            t_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionWord::set_allocated_t_user_type(::std::string* t_user_type) {
        if (t_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_user_type_;
        }
        if (t_user_type) {
            set_has_t_user_type();
            t_user_type_ = t_user_type;
        } else {
            clear_has_t_user_type();
            t_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionWord.t_user_type)
    }
    
    // required string m_avatar = 10;
    inline bool QuestionWord::has_m_avatar() const {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void QuestionWord::set_has_m_avatar() {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void QuestionWord::clear_has_m_avatar() {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void QuestionWord::clear_m_avatar() {
        if (m_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_->clear();
        }
        clear_has_m_avatar();
    }
    inline const ::std::string& QuestionWord::m_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.m_avatar)
        return *m_avatar_;
    }
    inline void QuestionWord::set_m_avatar(const ::std::string& value) {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        m_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.m_avatar)
    }
    inline void QuestionWord::set_m_avatar(const char* value) {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        m_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionWord.m_avatar)
    }
    inline void QuestionWord::set_m_avatar(const char* value, size_t size) {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        m_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionWord.m_avatar)
    }
    inline ::std::string* QuestionWord::mutable_m_avatar() {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionWord.m_avatar)
        return m_avatar_;
    }
    inline ::std::string* QuestionWord::release_m_avatar() {
        clear_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_avatar_;
            m_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionWord::set_allocated_m_avatar(::std::string* m_avatar) {
        if (m_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_avatar_;
        }
        if (m_avatar) {
            set_has_m_avatar();
            m_avatar_ = m_avatar;
        } else {
            clear_has_m_avatar();
            m_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionWord.m_avatar)
    }
    
    // required string m_name = 11;
    inline bool QuestionWord::has_m_name() const {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void QuestionWord::set_has_m_name() {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void QuestionWord::clear_has_m_name() {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void QuestionWord::clear_m_name() {
        if (m_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_->clear();
        }
        clear_has_m_name();
    }
    inline const ::std::string& QuestionWord::m_name() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.m_name)
        return *m_name_;
    }
    inline void QuestionWord::set_m_name(const ::std::string& value) {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        m_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.m_name)
    }
    inline void QuestionWord::set_m_name(const char* value) {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        m_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionWord.m_name)
    }
    inline void QuestionWord::set_m_name(const char* value, size_t size) {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        m_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionWord.m_name)
    }
    inline ::std::string* QuestionWord::mutable_m_name() {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionWord.m_name)
        return m_name_;
    }
    inline ::std::string* QuestionWord::release_m_name() {
        clear_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_name_;
            m_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionWord::set_allocated_m_name(::std::string* m_name) {
        if (m_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_name_;
        }
        if (m_name) {
            set_has_m_name();
            m_name_ = m_name;
        } else {
            clear_has_m_name();
            m_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionWord.m_name)
    }
    
    // required string m_leve = 12;
    inline bool QuestionWord::has_m_leve() const {
        return (_has_bits_[0] & 0x00000800u) != 0;
    }
    inline void QuestionWord::set_has_m_leve() {
        _has_bits_[0] |= 0x00000800u;
    }
    inline void QuestionWord::clear_has_m_leve() {
        _has_bits_[0] &= ~0x00000800u;
    }
    inline void QuestionWord::clear_m_leve() {
        if (m_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_->clear();
        }
        clear_has_m_leve();
    }
    inline const ::std::string& QuestionWord::m_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.m_leve)
        return *m_leve_;
    }
    inline void QuestionWord::set_m_leve(const ::std::string& value) {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        m_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.m_leve)
    }
    inline void QuestionWord::set_m_leve(const char* value) {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        m_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionWord.m_leve)
    }
    inline void QuestionWord::set_m_leve(const char* value, size_t size) {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        m_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionWord.m_leve)
    }
    inline ::std::string* QuestionWord::mutable_m_leve() {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionWord.m_leve)
        return m_leve_;
    }
    inline ::std::string* QuestionWord::release_m_leve() {
        clear_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_leve_;
            m_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionWord::set_allocated_m_leve(::std::string* m_leve) {
        if (m_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_leve_;
        }
        if (m_leve) {
            set_has_m_leve();
            m_leve_ = m_leve;
        } else {
            clear_has_m_leve();
            m_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionWord.m_leve)
    }
    
    // required string m_user_type = 13;
    inline bool QuestionWord::has_m_user_type() const {
        return (_has_bits_[0] & 0x00001000u) != 0;
    }
    inline void QuestionWord::set_has_m_user_type() {
        _has_bits_[0] |= 0x00001000u;
    }
    inline void QuestionWord::clear_has_m_user_type() {
        _has_bits_[0] &= ~0x00001000u;
    }
    inline void QuestionWord::clear_m_user_type() {
        if (m_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_->clear();
        }
        clear_has_m_user_type();
    }
    inline const ::std::string& QuestionWord::m_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.m_user_type)
        return *m_user_type_;
    }
    inline void QuestionWord::set_m_user_type(const ::std::string& value) {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        m_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.m_user_type)
    }
    inline void QuestionWord::set_m_user_type(const char* value) {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        m_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionWord.m_user_type)
    }
    inline void QuestionWord::set_m_user_type(const char* value, size_t size) {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        m_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionWord.m_user_type)
    }
    inline ::std::string* QuestionWord::mutable_m_user_type() {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionWord.m_user_type)
        return m_user_type_;
    }
    inline ::std::string* QuestionWord::release_m_user_type() {
        clear_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_user_type_;
            m_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionWord::set_allocated_m_user_type(::std::string* m_user_type) {
        if (m_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_user_type_;
        }
        if (m_user_type) {
            set_has_m_user_type();
            m_user_type_ = m_user_type;
        } else {
            clear_has_m_user_type();
            m_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionWord.m_user_type)
    }
    
    // optional string device_udid = 14;
    inline bool QuestionWord::has_device_udid() const {
        return (_has_bits_[0] & 0x00002000u) != 0;
    }
    inline void QuestionWord::set_has_device_udid() {
        _has_bits_[0] |= 0x00002000u;
    }
    inline void QuestionWord::clear_has_device_udid() {
        _has_bits_[0] &= ~0x00002000u;
    }
    inline void QuestionWord::clear_device_udid() {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_->clear();
        }
        clear_has_device_udid();
    }
    inline const ::std::string& QuestionWord::device_udid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionWord.device_udid)
        return *device_udid_;
    }
    inline void QuestionWord::set_device_udid(const ::std::string& value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionWord.device_udid)
    }
    inline void QuestionWord::set_device_udid(const char* value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionWord.device_udid)
    }
    inline void QuestionWord::set_device_udid(const char* value, size_t size) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionWord.device_udid)
    }
    inline ::std::string* QuestionWord::mutable_device_udid() {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionWord.device_udid)
        return device_udid_;
    }
    inline ::std::string* QuestionWord::release_device_udid() {
        clear_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_udid_;
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionWord::set_allocated_device_udid(::std::string* device_udid) {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_udid_;
        }
        if (device_udid) {
            set_has_device_udid();
            device_udid_ = device_udid;
        } else {
            clear_has_device_udid();
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionWord.device_udid)
    }
    
    // -------------------------------------------------------------------
    
    // QuestionPic
    
    // required int64 mid = 1;
    inline bool QuestionPic::has_mid() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void QuestionPic::set_has_mid() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void QuestionPic::clear_has_mid() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void QuestionPic::clear_mid() {
        mid_ = GOOGLE_LONGLONG(0);
        clear_has_mid();
    }
    inline ::google::protobuf::int64 QuestionPic::mid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.mid)
        return mid_;
    }
    inline void QuestionPic::set_mid(::google::protobuf::int64 value) {
        set_has_mid();
        mid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.mid)
    }
    
    // required int64 tid = 2;
    inline bool QuestionPic::has_tid() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void QuestionPic::set_has_tid() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void QuestionPic::clear_has_tid() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void QuestionPic::clear_tid() {
        tid_ = GOOGLE_LONGLONG(0);
        clear_has_tid();
    }
    inline ::google::protobuf::int64 QuestionPic::tid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.tid)
        return tid_;
    }
    inline void QuestionPic::set_tid(::google::protobuf::int64 value) {
        set_has_tid();
        tid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.tid)
    }
    
    // required .QSChat.ChatRequestType ctype = 3;
    inline bool QuestionPic::has_ctype() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void QuestionPic::set_has_ctype() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void QuestionPic::clear_has_ctype() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void QuestionPic::clear_ctype() {
        ctype_ = 8000;
        clear_has_ctype();
    }
    inline ::QSChat::ChatRequestType QuestionPic::ctype() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.ctype)
        return static_cast< ::QSChat::ChatRequestType >(ctype_);
    }
    inline void QuestionPic::set_ctype(::QSChat::ChatRequestType value) {
        assert(::QSChat::ChatRequestType_IsValid(value));
        set_has_ctype();
        ctype_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.ctype)
    }
    
    // required bytes pic = 4;
    inline bool QuestionPic::has_pic() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void QuestionPic::set_has_pic() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void QuestionPic::clear_has_pic() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void QuestionPic::clear_pic() {
        if (pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_->clear();
        }
        clear_has_pic();
    }
    inline const ::std::string& QuestionPic::pic() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.pic)
        return *pic_;
    }
    inline void QuestionPic::set_pic(const ::std::string& value) {
        set_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_ = new ::std::string;
        }
        pic_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.pic)
    }
    inline void QuestionPic::set_pic(const char* value) {
        set_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_ = new ::std::string;
        }
        pic_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionPic.pic)
    }
    inline void QuestionPic::set_pic(const void* value, size_t size) {
        set_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_ = new ::std::string;
        }
        pic_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionPic.pic)
    }
    inline ::std::string* QuestionPic::mutable_pic() {
        set_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionPic.pic)
        return pic_;
    }
    inline ::std::string* QuestionPic::release_pic() {
        clear_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = pic_;
            pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionPic::set_allocated_pic(::std::string* pic) {
        if (pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete pic_;
        }
        if (pic) {
            set_has_pic();
            pic_ = pic;
        } else {
            clear_has_pic();
            pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionPic.pic)
    }
    
    // required string time_stamp = 5;
    inline bool QuestionPic::has_time_stamp() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void QuestionPic::set_has_time_stamp() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void QuestionPic::clear_has_time_stamp() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void QuestionPic::clear_time_stamp() {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_->clear();
        }
        clear_has_time_stamp();
    }
    inline const ::std::string& QuestionPic::time_stamp() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.time_stamp)
        return *time_stamp_;
    }
    inline void QuestionPic::set_time_stamp(const ::std::string& value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.time_stamp)
    }
    inline void QuestionPic::set_time_stamp(const char* value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionPic.time_stamp)
    }
    inline void QuestionPic::set_time_stamp(const char* value, size_t size) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionPic.time_stamp)
    }
    inline ::std::string* QuestionPic::mutable_time_stamp() {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionPic.time_stamp)
        return time_stamp_;
    }
    inline ::std::string* QuestionPic::release_time_stamp() {
        clear_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = time_stamp_;
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionPic::set_allocated_time_stamp(::std::string* time_stamp) {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete time_stamp_;
        }
        if (time_stamp) {
            set_has_time_stamp();
            time_stamp_ = time_stamp;
        } else {
            clear_has_time_stamp();
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionPic.time_stamp)
    }
    
    // required string t_avatar = 6;
    inline bool QuestionPic::has_t_avatar() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void QuestionPic::set_has_t_avatar() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void QuestionPic::clear_has_t_avatar() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void QuestionPic::clear_t_avatar() {
        if (t_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_->clear();
        }
        clear_has_t_avatar();
    }
    inline const ::std::string& QuestionPic::t_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.t_avatar)
        return *t_avatar_;
    }
    inline void QuestionPic::set_t_avatar(const ::std::string& value) {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        t_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.t_avatar)
    }
    inline void QuestionPic::set_t_avatar(const char* value) {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        t_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionPic.t_avatar)
    }
    inline void QuestionPic::set_t_avatar(const char* value, size_t size) {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        t_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionPic.t_avatar)
    }
    inline ::std::string* QuestionPic::mutable_t_avatar() {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionPic.t_avatar)
        return t_avatar_;
    }
    inline ::std::string* QuestionPic::release_t_avatar() {
        clear_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_avatar_;
            t_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionPic::set_allocated_t_avatar(::std::string* t_avatar) {
        if (t_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_avatar_;
        }
        if (t_avatar) {
            set_has_t_avatar();
            t_avatar_ = t_avatar;
        } else {
            clear_has_t_avatar();
            t_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionPic.t_avatar)
    }
    
    // required string t_name = 7;
    inline bool QuestionPic::has_t_name() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void QuestionPic::set_has_t_name() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void QuestionPic::clear_has_t_name() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void QuestionPic::clear_t_name() {
        if (t_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_->clear();
        }
        clear_has_t_name();
    }
    inline const ::std::string& QuestionPic::t_name() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.t_name)
        return *t_name_;
    }
    inline void QuestionPic::set_t_name(const ::std::string& value) {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        t_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.t_name)
    }
    inline void QuestionPic::set_t_name(const char* value) {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        t_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionPic.t_name)
    }
    inline void QuestionPic::set_t_name(const char* value, size_t size) {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        t_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionPic.t_name)
    }
    inline ::std::string* QuestionPic::mutable_t_name() {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionPic.t_name)
        return t_name_;
    }
    inline ::std::string* QuestionPic::release_t_name() {
        clear_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_name_;
            t_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionPic::set_allocated_t_name(::std::string* t_name) {
        if (t_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_name_;
        }
        if (t_name) {
            set_has_t_name();
            t_name_ = t_name;
        } else {
            clear_has_t_name();
            t_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionPic.t_name)
    }
    
    // required string t_leve = 8;
    inline bool QuestionPic::has_t_leve() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void QuestionPic::set_has_t_leve() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void QuestionPic::clear_has_t_leve() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void QuestionPic::clear_t_leve() {
        if (t_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_->clear();
        }
        clear_has_t_leve();
    }
    inline const ::std::string& QuestionPic::t_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.t_leve)
        return *t_leve_;
    }
    inline void QuestionPic::set_t_leve(const ::std::string& value) {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        t_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.t_leve)
    }
    inline void QuestionPic::set_t_leve(const char* value) {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        t_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionPic.t_leve)
    }
    inline void QuestionPic::set_t_leve(const char* value, size_t size) {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        t_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionPic.t_leve)
    }
    inline ::std::string* QuestionPic::mutable_t_leve() {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionPic.t_leve)
        return t_leve_;
    }
    inline ::std::string* QuestionPic::release_t_leve() {
        clear_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_leve_;
            t_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionPic::set_allocated_t_leve(::std::string* t_leve) {
        if (t_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_leve_;
        }
        if (t_leve) {
            set_has_t_leve();
            t_leve_ = t_leve;
        } else {
            clear_has_t_leve();
            t_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionPic.t_leve)
    }
    
    // required string t_user_type = 9;
    inline bool QuestionPic::has_t_user_type() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void QuestionPic::set_has_t_user_type() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void QuestionPic::clear_has_t_user_type() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void QuestionPic::clear_t_user_type() {
        if (t_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_->clear();
        }
        clear_has_t_user_type();
    }
    inline const ::std::string& QuestionPic::t_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.t_user_type)
        return *t_user_type_;
    }
    inline void QuestionPic::set_t_user_type(const ::std::string& value) {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        t_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.t_user_type)
    }
    inline void QuestionPic::set_t_user_type(const char* value) {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        t_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionPic.t_user_type)
    }
    inline void QuestionPic::set_t_user_type(const char* value, size_t size) {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        t_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionPic.t_user_type)
    }
    inline ::std::string* QuestionPic::mutable_t_user_type() {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionPic.t_user_type)
        return t_user_type_;
    }
    inline ::std::string* QuestionPic::release_t_user_type() {
        clear_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_user_type_;
            t_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionPic::set_allocated_t_user_type(::std::string* t_user_type) {
        if (t_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_user_type_;
        }
        if (t_user_type) {
            set_has_t_user_type();
            t_user_type_ = t_user_type;
        } else {
            clear_has_t_user_type();
            t_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionPic.t_user_type)
    }
    
    // required string m_avatar = 10;
    inline bool QuestionPic::has_m_avatar() const {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void QuestionPic::set_has_m_avatar() {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void QuestionPic::clear_has_m_avatar() {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void QuestionPic::clear_m_avatar() {
        if (m_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_->clear();
        }
        clear_has_m_avatar();
    }
    inline const ::std::string& QuestionPic::m_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.m_avatar)
        return *m_avatar_;
    }
    inline void QuestionPic::set_m_avatar(const ::std::string& value) {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        m_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.m_avatar)
    }
    inline void QuestionPic::set_m_avatar(const char* value) {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        m_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionPic.m_avatar)
    }
    inline void QuestionPic::set_m_avatar(const char* value, size_t size) {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        m_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionPic.m_avatar)
    }
    inline ::std::string* QuestionPic::mutable_m_avatar() {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionPic.m_avatar)
        return m_avatar_;
    }
    inline ::std::string* QuestionPic::release_m_avatar() {
        clear_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_avatar_;
            m_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionPic::set_allocated_m_avatar(::std::string* m_avatar) {
        if (m_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_avatar_;
        }
        if (m_avatar) {
            set_has_m_avatar();
            m_avatar_ = m_avatar;
        } else {
            clear_has_m_avatar();
            m_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionPic.m_avatar)
    }
    
    // required string m_name = 11;
    inline bool QuestionPic::has_m_name() const {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void QuestionPic::set_has_m_name() {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void QuestionPic::clear_has_m_name() {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void QuestionPic::clear_m_name() {
        if (m_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_->clear();
        }
        clear_has_m_name();
    }
    inline const ::std::string& QuestionPic::m_name() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.m_name)
        return *m_name_;
    }
    inline void QuestionPic::set_m_name(const ::std::string& value) {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        m_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.m_name)
    }
    inline void QuestionPic::set_m_name(const char* value) {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        m_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionPic.m_name)
    }
    inline void QuestionPic::set_m_name(const char* value, size_t size) {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        m_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionPic.m_name)
    }
    inline ::std::string* QuestionPic::mutable_m_name() {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionPic.m_name)
        return m_name_;
    }
    inline ::std::string* QuestionPic::release_m_name() {
        clear_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_name_;
            m_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionPic::set_allocated_m_name(::std::string* m_name) {
        if (m_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_name_;
        }
        if (m_name) {
            set_has_m_name();
            m_name_ = m_name;
        } else {
            clear_has_m_name();
            m_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionPic.m_name)
    }
    
    // required string m_leve = 12;
    inline bool QuestionPic::has_m_leve() const {
        return (_has_bits_[0] & 0x00000800u) != 0;
    }
    inline void QuestionPic::set_has_m_leve() {
        _has_bits_[0] |= 0x00000800u;
    }
    inline void QuestionPic::clear_has_m_leve() {
        _has_bits_[0] &= ~0x00000800u;
    }
    inline void QuestionPic::clear_m_leve() {
        if (m_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_->clear();
        }
        clear_has_m_leve();
    }
    inline const ::std::string& QuestionPic::m_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.m_leve)
        return *m_leve_;
    }
    inline void QuestionPic::set_m_leve(const ::std::string& value) {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        m_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.m_leve)
    }
    inline void QuestionPic::set_m_leve(const char* value) {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        m_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionPic.m_leve)
    }
    inline void QuestionPic::set_m_leve(const char* value, size_t size) {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        m_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionPic.m_leve)
    }
    inline ::std::string* QuestionPic::mutable_m_leve() {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionPic.m_leve)
        return m_leve_;
    }
    inline ::std::string* QuestionPic::release_m_leve() {
        clear_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_leve_;
            m_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionPic::set_allocated_m_leve(::std::string* m_leve) {
        if (m_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_leve_;
        }
        if (m_leve) {
            set_has_m_leve();
            m_leve_ = m_leve;
        } else {
            clear_has_m_leve();
            m_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionPic.m_leve)
    }
    
    // required string m_user_type = 13;
    inline bool QuestionPic::has_m_user_type() const {
        return (_has_bits_[0] & 0x00001000u) != 0;
    }
    inline void QuestionPic::set_has_m_user_type() {
        _has_bits_[0] |= 0x00001000u;
    }
    inline void QuestionPic::clear_has_m_user_type() {
        _has_bits_[0] &= ~0x00001000u;
    }
    inline void QuestionPic::clear_m_user_type() {
        if (m_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_->clear();
        }
        clear_has_m_user_type();
    }
    inline const ::std::string& QuestionPic::m_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.m_user_type)
        return *m_user_type_;
    }
    inline void QuestionPic::set_m_user_type(const ::std::string& value) {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        m_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.m_user_type)
    }
    inline void QuestionPic::set_m_user_type(const char* value) {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        m_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionPic.m_user_type)
    }
    inline void QuestionPic::set_m_user_type(const char* value, size_t size) {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        m_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionPic.m_user_type)
    }
    inline ::std::string* QuestionPic::mutable_m_user_type() {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionPic.m_user_type)
        return m_user_type_;
    }
    inline ::std::string* QuestionPic::release_m_user_type() {
        clear_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_user_type_;
            m_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionPic::set_allocated_m_user_type(::std::string* m_user_type) {
        if (m_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_user_type_;
        }
        if (m_user_type) {
            set_has_m_user_type();
            m_user_type_ = m_user_type;
        } else {
            clear_has_m_user_type();
            m_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionPic.m_user_type)
    }
    
    // optional string device_udid = 14;
    inline bool QuestionPic::has_device_udid() const {
        return (_has_bits_[0] & 0x00002000u) != 0;
    }
    inline void QuestionPic::set_has_device_udid() {
        _has_bits_[0] |= 0x00002000u;
    }
    inline void QuestionPic::clear_has_device_udid() {
        _has_bits_[0] &= ~0x00002000u;
    }
    inline void QuestionPic::clear_device_udid() {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_->clear();
        }
        clear_has_device_udid();
    }
    inline const ::std::string& QuestionPic::device_udid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionPic.device_udid)
        return *device_udid_;
    }
    inline void QuestionPic::set_device_udid(const ::std::string& value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionPic.device_udid)
    }
    inline void QuestionPic::set_device_udid(const char* value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionPic.device_udid)
    }
    inline void QuestionPic::set_device_udid(const char* value, size_t size) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionPic.device_udid)
    }
    inline ::std::string* QuestionPic::mutable_device_udid() {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionPic.device_udid)
        return device_udid_;
    }
    inline ::std::string* QuestionPic::release_device_udid() {
        clear_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_udid_;
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionPic::set_allocated_device_udid(::std::string* device_udid) {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_udid_;
        }
        if (device_udid) {
            set_has_device_udid();
            device_udid_ = device_udid;
        } else {
            clear_has_device_udid();
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionPic.device_udid)
    }
    
    // -------------------------------------------------------------------
    
    // QuestionVideo
    
    // required int64 mid = 1;
    inline bool QuestionVideo::has_mid() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void QuestionVideo::set_has_mid() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void QuestionVideo::clear_has_mid() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void QuestionVideo::clear_mid() {
        mid_ = GOOGLE_LONGLONG(0);
        clear_has_mid();
    }
    inline ::google::protobuf::int64 QuestionVideo::mid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.mid)
        return mid_;
    }
    inline void QuestionVideo::set_mid(::google::protobuf::int64 value) {
        set_has_mid();
        mid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.mid)
    }
    
    // required int64 tid = 2;
    inline bool QuestionVideo::has_tid() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void QuestionVideo::set_has_tid() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void QuestionVideo::clear_has_tid() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void QuestionVideo::clear_tid() {
        tid_ = GOOGLE_LONGLONG(0);
        clear_has_tid();
    }
    inline ::google::protobuf::int64 QuestionVideo::tid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.tid)
        return tid_;
    }
    inline void QuestionVideo::set_tid(::google::protobuf::int64 value) {
        set_has_tid();
        tid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.tid)
    }
    
    // required .QSChat.ChatRequestType ctype = 3;
    inline bool QuestionVideo::has_ctype() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void QuestionVideo::set_has_ctype() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void QuestionVideo::clear_has_ctype() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void QuestionVideo::clear_ctype() {
        ctype_ = 8000;
        clear_has_ctype();
    }
    inline ::QSChat::ChatRequestType QuestionVideo::ctype() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.ctype)
        return static_cast< ::QSChat::ChatRequestType >(ctype_);
    }
    inline void QuestionVideo::set_ctype(::QSChat::ChatRequestType value) {
        assert(::QSChat::ChatRequestType_IsValid(value));
        set_has_ctype();
        ctype_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.ctype)
    }
    
    // required bytes video = 4;
    inline bool QuestionVideo::has_video() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void QuestionVideo::set_has_video() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void QuestionVideo::clear_has_video() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void QuestionVideo::clear_video() {
        if (video_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            video_->clear();
        }
        clear_has_video();
    }
    inline const ::std::string& QuestionVideo::video() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.video)
        return *video_;
    }
    inline void QuestionVideo::set_video(const ::std::string& value) {
        set_has_video();
        if (video_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            video_ = new ::std::string;
        }
        video_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.video)
    }
    inline void QuestionVideo::set_video(const char* value) {
        set_has_video();
        if (video_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            video_ = new ::std::string;
        }
        video_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionVideo.video)
    }
    inline void QuestionVideo::set_video(const void* value, size_t size) {
        set_has_video();
        if (video_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            video_ = new ::std::string;
        }
        video_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionVideo.video)
    }
    inline ::std::string* QuestionVideo::mutable_video() {
        set_has_video();
        if (video_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            video_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionVideo.video)
        return video_;
    }
    inline ::std::string* QuestionVideo::release_video() {
        clear_has_video();
        if (video_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = video_;
            video_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionVideo::set_allocated_video(::std::string* video) {
        if (video_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete video_;
        }
        if (video) {
            set_has_video();
            video_ = video;
        } else {
            clear_has_video();
            video_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionVideo.video)
    }
    
    // required string time_stamp = 5;
    inline bool QuestionVideo::has_time_stamp() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void QuestionVideo::set_has_time_stamp() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void QuestionVideo::clear_has_time_stamp() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void QuestionVideo::clear_time_stamp() {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_->clear();
        }
        clear_has_time_stamp();
    }
    inline const ::std::string& QuestionVideo::time_stamp() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.time_stamp)
        return *time_stamp_;
    }
    inline void QuestionVideo::set_time_stamp(const ::std::string& value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.time_stamp)
    }
    inline void QuestionVideo::set_time_stamp(const char* value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionVideo.time_stamp)
    }
    inline void QuestionVideo::set_time_stamp(const char* value, size_t size) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionVideo.time_stamp)
    }
    inline ::std::string* QuestionVideo::mutable_time_stamp() {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionVideo.time_stamp)
        return time_stamp_;
    }
    inline ::std::string* QuestionVideo::release_time_stamp() {
        clear_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = time_stamp_;
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionVideo::set_allocated_time_stamp(::std::string* time_stamp) {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete time_stamp_;
        }
        if (time_stamp) {
            set_has_time_stamp();
            time_stamp_ = time_stamp;
        } else {
            clear_has_time_stamp();
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionVideo.time_stamp)
    }
    
    // required string t_avatar = 6;
    inline bool QuestionVideo::has_t_avatar() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void QuestionVideo::set_has_t_avatar() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void QuestionVideo::clear_has_t_avatar() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void QuestionVideo::clear_t_avatar() {
        if (t_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_->clear();
        }
        clear_has_t_avatar();
    }
    inline const ::std::string& QuestionVideo::t_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.t_avatar)
        return *t_avatar_;
    }
    inline void QuestionVideo::set_t_avatar(const ::std::string& value) {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        t_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.t_avatar)
    }
    inline void QuestionVideo::set_t_avatar(const char* value) {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        t_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionVideo.t_avatar)
    }
    inline void QuestionVideo::set_t_avatar(const char* value, size_t size) {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        t_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionVideo.t_avatar)
    }
    inline ::std::string* QuestionVideo::mutable_t_avatar() {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionVideo.t_avatar)
        return t_avatar_;
    }
    inline ::std::string* QuestionVideo::release_t_avatar() {
        clear_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_avatar_;
            t_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionVideo::set_allocated_t_avatar(::std::string* t_avatar) {
        if (t_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_avatar_;
        }
        if (t_avatar) {
            set_has_t_avatar();
            t_avatar_ = t_avatar;
        } else {
            clear_has_t_avatar();
            t_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionVideo.t_avatar)
    }
    
    // required string t_name = 7;
    inline bool QuestionVideo::has_t_name() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void QuestionVideo::set_has_t_name() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void QuestionVideo::clear_has_t_name() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void QuestionVideo::clear_t_name() {
        if (t_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_->clear();
        }
        clear_has_t_name();
    }
    inline const ::std::string& QuestionVideo::t_name() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.t_name)
        return *t_name_;
    }
    inline void QuestionVideo::set_t_name(const ::std::string& value) {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        t_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.t_name)
    }
    inline void QuestionVideo::set_t_name(const char* value) {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        t_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionVideo.t_name)
    }
    inline void QuestionVideo::set_t_name(const char* value, size_t size) {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        t_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionVideo.t_name)
    }
    inline ::std::string* QuestionVideo::mutable_t_name() {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionVideo.t_name)
        return t_name_;
    }
    inline ::std::string* QuestionVideo::release_t_name() {
        clear_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_name_;
            t_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionVideo::set_allocated_t_name(::std::string* t_name) {
        if (t_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_name_;
        }
        if (t_name) {
            set_has_t_name();
            t_name_ = t_name;
        } else {
            clear_has_t_name();
            t_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionVideo.t_name)
    }
    
    // required string t_leve = 8;
    inline bool QuestionVideo::has_t_leve() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void QuestionVideo::set_has_t_leve() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void QuestionVideo::clear_has_t_leve() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void QuestionVideo::clear_t_leve() {
        if (t_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_->clear();
        }
        clear_has_t_leve();
    }
    inline const ::std::string& QuestionVideo::t_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.t_leve)
        return *t_leve_;
    }
    inline void QuestionVideo::set_t_leve(const ::std::string& value) {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        t_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.t_leve)
    }
    inline void QuestionVideo::set_t_leve(const char* value) {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        t_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionVideo.t_leve)
    }
    inline void QuestionVideo::set_t_leve(const char* value, size_t size) {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        t_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionVideo.t_leve)
    }
    inline ::std::string* QuestionVideo::mutable_t_leve() {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionVideo.t_leve)
        return t_leve_;
    }
    inline ::std::string* QuestionVideo::release_t_leve() {
        clear_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_leve_;
            t_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionVideo::set_allocated_t_leve(::std::string* t_leve) {
        if (t_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_leve_;
        }
        if (t_leve) {
            set_has_t_leve();
            t_leve_ = t_leve;
        } else {
            clear_has_t_leve();
            t_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionVideo.t_leve)
    }
    
    // required string t_user_type = 9;
    inline bool QuestionVideo::has_t_user_type() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void QuestionVideo::set_has_t_user_type() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void QuestionVideo::clear_has_t_user_type() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void QuestionVideo::clear_t_user_type() {
        if (t_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_->clear();
        }
        clear_has_t_user_type();
    }
    inline const ::std::string& QuestionVideo::t_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.t_user_type)
        return *t_user_type_;
    }
    inline void QuestionVideo::set_t_user_type(const ::std::string& value) {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        t_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.t_user_type)
    }
    inline void QuestionVideo::set_t_user_type(const char* value) {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        t_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionVideo.t_user_type)
    }
    inline void QuestionVideo::set_t_user_type(const char* value, size_t size) {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        t_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionVideo.t_user_type)
    }
    inline ::std::string* QuestionVideo::mutable_t_user_type() {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionVideo.t_user_type)
        return t_user_type_;
    }
    inline ::std::string* QuestionVideo::release_t_user_type() {
        clear_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_user_type_;
            t_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionVideo::set_allocated_t_user_type(::std::string* t_user_type) {
        if (t_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_user_type_;
        }
        if (t_user_type) {
            set_has_t_user_type();
            t_user_type_ = t_user_type;
        } else {
            clear_has_t_user_type();
            t_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionVideo.t_user_type)
    }
    
    // required string m_avatar = 10;
    inline bool QuestionVideo::has_m_avatar() const {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void QuestionVideo::set_has_m_avatar() {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void QuestionVideo::clear_has_m_avatar() {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void QuestionVideo::clear_m_avatar() {
        if (m_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_->clear();
        }
        clear_has_m_avatar();
    }
    inline const ::std::string& QuestionVideo::m_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.m_avatar)
        return *m_avatar_;
    }
    inline void QuestionVideo::set_m_avatar(const ::std::string& value) {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        m_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.m_avatar)
    }
    inline void QuestionVideo::set_m_avatar(const char* value) {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        m_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionVideo.m_avatar)
    }
    inline void QuestionVideo::set_m_avatar(const char* value, size_t size) {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        m_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionVideo.m_avatar)
    }
    inline ::std::string* QuestionVideo::mutable_m_avatar() {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionVideo.m_avatar)
        return m_avatar_;
    }
    inline ::std::string* QuestionVideo::release_m_avatar() {
        clear_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_avatar_;
            m_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionVideo::set_allocated_m_avatar(::std::string* m_avatar) {
        if (m_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_avatar_;
        }
        if (m_avatar) {
            set_has_m_avatar();
            m_avatar_ = m_avatar;
        } else {
            clear_has_m_avatar();
            m_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionVideo.m_avatar)
    }
    
    // required string m_name = 11;
    inline bool QuestionVideo::has_m_name() const {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void QuestionVideo::set_has_m_name() {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void QuestionVideo::clear_has_m_name() {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void QuestionVideo::clear_m_name() {
        if (m_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_->clear();
        }
        clear_has_m_name();
    }
    inline const ::std::string& QuestionVideo::m_name() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.m_name)
        return *m_name_;
    }
    inline void QuestionVideo::set_m_name(const ::std::string& value) {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        m_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.m_name)
    }
    inline void QuestionVideo::set_m_name(const char* value) {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        m_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionVideo.m_name)
    }
    inline void QuestionVideo::set_m_name(const char* value, size_t size) {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        m_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionVideo.m_name)
    }
    inline ::std::string* QuestionVideo::mutable_m_name() {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionVideo.m_name)
        return m_name_;
    }
    inline ::std::string* QuestionVideo::release_m_name() {
        clear_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_name_;
            m_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionVideo::set_allocated_m_name(::std::string* m_name) {
        if (m_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_name_;
        }
        if (m_name) {
            set_has_m_name();
            m_name_ = m_name;
        } else {
            clear_has_m_name();
            m_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionVideo.m_name)
    }
    
    // required string m_leve = 12;
    inline bool QuestionVideo::has_m_leve() const {
        return (_has_bits_[0] & 0x00000800u) != 0;
    }
    inline void QuestionVideo::set_has_m_leve() {
        _has_bits_[0] |= 0x00000800u;
    }
    inline void QuestionVideo::clear_has_m_leve() {
        _has_bits_[0] &= ~0x00000800u;
    }
    inline void QuestionVideo::clear_m_leve() {
        if (m_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_->clear();
        }
        clear_has_m_leve();
    }
    inline const ::std::string& QuestionVideo::m_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.m_leve)
        return *m_leve_;
    }
    inline void QuestionVideo::set_m_leve(const ::std::string& value) {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        m_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.m_leve)
    }
    inline void QuestionVideo::set_m_leve(const char* value) {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        m_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionVideo.m_leve)
    }
    inline void QuestionVideo::set_m_leve(const char* value, size_t size) {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        m_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionVideo.m_leve)
    }
    inline ::std::string* QuestionVideo::mutable_m_leve() {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionVideo.m_leve)
        return m_leve_;
    }
    inline ::std::string* QuestionVideo::release_m_leve() {
        clear_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_leve_;
            m_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionVideo::set_allocated_m_leve(::std::string* m_leve) {
        if (m_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_leve_;
        }
        if (m_leve) {
            set_has_m_leve();
            m_leve_ = m_leve;
        } else {
            clear_has_m_leve();
            m_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionVideo.m_leve)
    }
    
    // required string m_user_type = 13;
    inline bool QuestionVideo::has_m_user_type() const {
        return (_has_bits_[0] & 0x00001000u) != 0;
    }
    inline void QuestionVideo::set_has_m_user_type() {
        _has_bits_[0] |= 0x00001000u;
    }
    inline void QuestionVideo::clear_has_m_user_type() {
        _has_bits_[0] &= ~0x00001000u;
    }
    inline void QuestionVideo::clear_m_user_type() {
        if (m_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_->clear();
        }
        clear_has_m_user_type();
    }
    inline const ::std::string& QuestionVideo::m_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.m_user_type)
        return *m_user_type_;
    }
    inline void QuestionVideo::set_m_user_type(const ::std::string& value) {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        m_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.m_user_type)
    }
    inline void QuestionVideo::set_m_user_type(const char* value) {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        m_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionVideo.m_user_type)
    }
    inline void QuestionVideo::set_m_user_type(const char* value, size_t size) {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        m_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionVideo.m_user_type)
    }
    inline ::std::string* QuestionVideo::mutable_m_user_type() {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionVideo.m_user_type)
        return m_user_type_;
    }
    inline ::std::string* QuestionVideo::release_m_user_type() {
        clear_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_user_type_;
            m_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionVideo::set_allocated_m_user_type(::std::string* m_user_type) {
        if (m_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_user_type_;
        }
        if (m_user_type) {
            set_has_m_user_type();
            m_user_type_ = m_user_type;
        } else {
            clear_has_m_user_type();
            m_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionVideo.m_user_type)
    }
    
    // optional string device_udid = 14;
    inline bool QuestionVideo::has_device_udid() const {
        return (_has_bits_[0] & 0x00002000u) != 0;
    }
    inline void QuestionVideo::set_has_device_udid() {
        _has_bits_[0] |= 0x00002000u;
    }
    inline void QuestionVideo::clear_has_device_udid() {
        _has_bits_[0] &= ~0x00002000u;
    }
    inline void QuestionVideo::clear_device_udid() {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_->clear();
        }
        clear_has_device_udid();
    }
    inline const ::std::string& QuestionVideo::device_udid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionVideo.device_udid)
        return *device_udid_;
    }
    inline void QuestionVideo::set_device_udid(const ::std::string& value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionVideo.device_udid)
    }
    inline void QuestionVideo::set_device_udid(const char* value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionVideo.device_udid)
    }
    inline void QuestionVideo::set_device_udid(const char* value, size_t size) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionVideo.device_udid)
    }
    inline ::std::string* QuestionVideo::mutable_device_udid() {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionVideo.device_udid)
        return device_udid_;
    }
    inline ::std::string* QuestionVideo::release_device_udid() {
        clear_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_udid_;
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionVideo::set_allocated_device_udid(::std::string* device_udid) {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_udid_;
        }
        if (device_udid) {
            set_has_device_udid();
            device_udid_ = device_udid;
        } else {
            clear_has_device_udid();
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionVideo.device_udid)
    }
    
    // -------------------------------------------------------------------
    
    // QuestionRecommendHouse
    
    // required int64 mid = 1;
    inline bool QuestionRecommendHouse::has_mid() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_mid() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void QuestionRecommendHouse::clear_has_mid() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void QuestionRecommendHouse::clear_mid() {
        mid_ = GOOGLE_LONGLONG(0);
        clear_has_mid();
    }
    inline ::google::protobuf::int64 QuestionRecommendHouse::mid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.mid)
        return mid_;
    }
    inline void QuestionRecommendHouse::set_mid(::google::protobuf::int64 value) {
        set_has_mid();
        mid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.mid)
    }
    
    // required int64 tid = 2;
    inline bool QuestionRecommendHouse::has_tid() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_tid() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void QuestionRecommendHouse::clear_has_tid() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void QuestionRecommendHouse::clear_tid() {
        tid_ = GOOGLE_LONGLONG(0);
        clear_has_tid();
    }
    inline ::google::protobuf::int64 QuestionRecommendHouse::tid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.tid)
        return tid_;
    }
    inline void QuestionRecommendHouse::set_tid(::google::protobuf::int64 value) {
        set_has_tid();
        tid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.tid)
    }
    
    // required .QSChat.ChatRequestType ctype = 3;
    inline bool QuestionRecommendHouse::has_ctype() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_ctype() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void QuestionRecommendHouse::clear_has_ctype() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void QuestionRecommendHouse::clear_ctype() {
        ctype_ = 8000;
        clear_has_ctype();
    }
    inline ::QSChat::ChatRequestType QuestionRecommendHouse::ctype() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.ctype)
        return static_cast< ::QSChat::ChatRequestType >(ctype_);
    }
    inline void QuestionRecommendHouse::set_ctype(::QSChat::ChatRequestType value) {
        assert(::QSChat::ChatRequestType_IsValid(value));
        set_has_ctype();
        ctype_ = value;
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.ctype)
    }
    
    // required string house_id = 4;
    inline bool QuestionRecommendHouse::has_house_id() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_house_id() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void QuestionRecommendHouse::clear_has_house_id() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void QuestionRecommendHouse::clear_house_id() {
        if (house_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_->clear();
        }
        clear_has_house_id();
    }
    inline const ::std::string& QuestionRecommendHouse::house_id() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.house_id)
        return *house_id_;
    }
    inline void QuestionRecommendHouse::set_house_id(const ::std::string& value) {
        set_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_ = new ::std::string;
        }
        house_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.house_id)
    }
    inline void QuestionRecommendHouse::set_house_id(const char* value) {
        set_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_ = new ::std::string;
        }
        house_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.house_id)
    }
    inline void QuestionRecommendHouse::set_house_id(const char* value, size_t size) {
        set_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_ = new ::std::string;
        }
        house_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.house_id)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_house_id() {
        set_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.house_id)
        return house_id_;
    }
    inline ::std::string* QuestionRecommendHouse::release_house_id() {
        clear_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_id_;
            house_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_house_id(::std::string* house_id) {
        if (house_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_id_;
        }
        if (house_id) {
            set_has_house_id();
            house_id_ = house_id;
        } else {
            clear_has_house_id();
            house_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.house_id)
    }
    
    // required string building_id = 5;
    inline bool QuestionRecommendHouse::has_building_id() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_building_id() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void QuestionRecommendHouse::clear_has_building_id() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void QuestionRecommendHouse::clear_building_id() {
        if (building_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_->clear();
        }
        clear_has_building_id();
    }
    inline const ::std::string& QuestionRecommendHouse::building_id() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.building_id)
        return *building_id_;
    }
    inline void QuestionRecommendHouse::set_building_id(const ::std::string& value) {
        set_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_ = new ::std::string;
        }
        building_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.building_id)
    }
    inline void QuestionRecommendHouse::set_building_id(const char* value) {
        set_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_ = new ::std::string;
        }
        building_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.building_id)
    }
    inline void QuestionRecommendHouse::set_building_id(const char* value, size_t size) {
        set_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_ = new ::std::string;
        }
        building_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.building_id)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_building_id() {
        set_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.building_id)
        return building_id_;
    }
    inline ::std::string* QuestionRecommendHouse::release_building_id() {
        clear_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = building_id_;
            building_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_building_id(::std::string* building_id) {
        if (building_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete building_id_;
        }
        if (building_id) {
            set_has_building_id();
            building_id_ = building_id;
        } else {
            clear_has_building_id();
            building_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.building_id)
    }
    
    // required string house_type = 6;
    inline bool QuestionRecommendHouse::has_house_type() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_house_type() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void QuestionRecommendHouse::clear_has_house_type() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void QuestionRecommendHouse::clear_house_type() {
        if (house_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_->clear();
        }
        clear_has_house_type();
    }
    inline const ::std::string& QuestionRecommendHouse::house_type() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.house_type)
        return *house_type_;
    }
    inline void QuestionRecommendHouse::set_house_type(const ::std::string& value) {
        set_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_ = new ::std::string;
        }
        house_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.house_type)
    }
    inline void QuestionRecommendHouse::set_house_type(const char* value) {
        set_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_ = new ::std::string;
        }
        house_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.house_type)
    }
    inline void QuestionRecommendHouse::set_house_type(const char* value, size_t size) {
        set_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_ = new ::std::string;
        }
        house_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.house_type)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_house_type() {
        set_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.house_type)
        return house_type_;
    }
    inline ::std::string* QuestionRecommendHouse::release_house_type() {
        clear_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_type_;
            house_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_house_type(::std::string* house_type) {
        if (house_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_type_;
        }
        if (house_type) {
            set_has_house_type();
            house_type_ = house_type;
        } else {
            clear_has_house_type();
            house_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.house_type)
    }
    
    // required string attach_file = 7;
    inline bool QuestionRecommendHouse::has_attach_file() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_attach_file() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void QuestionRecommendHouse::clear_has_attach_file() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void QuestionRecommendHouse::clear_attach_file() {
        if (attach_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_->clear();
        }
        clear_has_attach_file();
    }
    inline const ::std::string& QuestionRecommendHouse::attach_file() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.attach_file)
        return *attach_file_;
    }
    inline void QuestionRecommendHouse::set_attach_file(const ::std::string& value) {
        set_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_ = new ::std::string;
        }
        attach_file_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.attach_file)
    }
    inline void QuestionRecommendHouse::set_attach_file(const char* value) {
        set_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_ = new ::std::string;
        }
        attach_file_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.attach_file)
    }
    inline void QuestionRecommendHouse::set_attach_file(const char* value, size_t size) {
        set_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_ = new ::std::string;
        }
        attach_file_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.attach_file)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_attach_file() {
        set_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.attach_file)
        return attach_file_;
    }
    inline ::std::string* QuestionRecommendHouse::release_attach_file() {
        clear_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = attach_file_;
            attach_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_attach_file(::std::string* attach_file) {
        if (attach_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete attach_file_;
        }
        if (attach_file) {
            set_has_attach_file();
            attach_file_ = attach_file;
        } else {
            clear_has_attach_file();
            attach_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.attach_file)
    }
    
    // required string attach_thumb = 8;
    inline bool QuestionRecommendHouse::has_attach_thumb() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_attach_thumb() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void QuestionRecommendHouse::clear_has_attach_thumb() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void QuestionRecommendHouse::clear_attach_thumb() {
        if (attach_thumb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_->clear();
        }
        clear_has_attach_thumb();
    }
    inline const ::std::string& QuestionRecommendHouse::attach_thumb() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.attach_thumb)
        return *attach_thumb_;
    }
    inline void QuestionRecommendHouse::set_attach_thumb(const ::std::string& value) {
        set_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_ = new ::std::string;
        }
        attach_thumb_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.attach_thumb)
    }
    inline void QuestionRecommendHouse::set_attach_thumb(const char* value) {
        set_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_ = new ::std::string;
        }
        attach_thumb_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.attach_thumb)
    }
    inline void QuestionRecommendHouse::set_attach_thumb(const char* value, size_t size) {
        set_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_ = new ::std::string;
        }
        attach_thumb_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.attach_thumb)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_attach_thumb() {
        set_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.attach_thumb)
        return attach_thumb_;
    }
    inline ::std::string* QuestionRecommendHouse::release_attach_thumb() {
        clear_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = attach_thumb_;
            attach_thumb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_attach_thumb(::std::string* attach_thumb) {
        if (attach_thumb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete attach_thumb_;
        }
        if (attach_thumb) {
            set_has_attach_thumb();
            attach_thumb_ = attach_thumb;
        } else {
            clear_has_attach_thumb();
            attach_thumb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.attach_thumb)
    }
    
    // required string areaid = 9;
    inline bool QuestionRecommendHouse::has_areaid() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_areaid() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void QuestionRecommendHouse::clear_has_areaid() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void QuestionRecommendHouse::clear_areaid() {
        if (areaid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_->clear();
        }
        clear_has_areaid();
    }
    inline const ::std::string& QuestionRecommendHouse::areaid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.areaid)
        return *areaid_;
    }
    inline void QuestionRecommendHouse::set_areaid(const ::std::string& value) {
        set_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_ = new ::std::string;
        }
        areaid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.areaid)
    }
    inline void QuestionRecommendHouse::set_areaid(const char* value) {
        set_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_ = new ::std::string;
        }
        areaid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.areaid)
    }
    inline void QuestionRecommendHouse::set_areaid(const char* value, size_t size) {
        set_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_ = new ::std::string;
        }
        areaid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.areaid)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_areaid() {
        set_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.areaid)
        return areaid_;
    }
    inline ::std::string* QuestionRecommendHouse::release_areaid() {
        clear_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = areaid_;
            areaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_areaid(::std::string* areaid) {
        if (areaid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete areaid_;
        }
        if (areaid) {
            set_has_areaid();
            areaid_ = areaid;
        } else {
            clear_has_areaid();
            areaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.areaid)
    }
    
    // required string area_val = 10;
    inline bool QuestionRecommendHouse::has_area_val() const {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_area_val() {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void QuestionRecommendHouse::clear_has_area_val() {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void QuestionRecommendHouse::clear_area_val() {
        if (area_val_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_->clear();
        }
        clear_has_area_val();
    }
    inline const ::std::string& QuestionRecommendHouse::area_val() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.area_val)
        return *area_val_;
    }
    inline void QuestionRecommendHouse::set_area_val(const ::std::string& value) {
        set_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_ = new ::std::string;
        }
        area_val_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.area_val)
    }
    inline void QuestionRecommendHouse::set_area_val(const char* value) {
        set_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_ = new ::std::string;
        }
        area_val_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.area_val)
    }
    inline void QuestionRecommendHouse::set_area_val(const char* value, size_t size) {
        set_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_ = new ::std::string;
        }
        area_val_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.area_val)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_area_val() {
        set_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.area_val)
        return area_val_;
    }
    inline ::std::string* QuestionRecommendHouse::release_area_val() {
        clear_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = area_val_;
            area_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_area_val(::std::string* area_val) {
        if (area_val_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete area_val_;
        }
        if (area_val) {
            set_has_area_val();
            area_val_ = area_val;
        } else {
            clear_has_area_val();
            area_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.area_val)
    }
    
    // required string streetid = 11;
    inline bool QuestionRecommendHouse::has_streetid() const {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_streetid() {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void QuestionRecommendHouse::clear_has_streetid() {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void QuestionRecommendHouse::clear_streetid() {
        if (streetid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_->clear();
        }
        clear_has_streetid();
    }
    inline const ::std::string& QuestionRecommendHouse::streetid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.streetid)
        return *streetid_;
    }
    inline void QuestionRecommendHouse::set_streetid(const ::std::string& value) {
        set_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_ = new ::std::string;
        }
        streetid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.streetid)
    }
    inline void QuestionRecommendHouse::set_streetid(const char* value) {
        set_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_ = new ::std::string;
        }
        streetid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.streetid)
    }
    inline void QuestionRecommendHouse::set_streetid(const char* value, size_t size) {
        set_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_ = new ::std::string;
        }
        streetid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.streetid)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_streetid() {
        set_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.streetid)
        return streetid_;
    }
    inline ::std::string* QuestionRecommendHouse::release_streetid() {
        clear_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = streetid_;
            streetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_streetid(::std::string* streetid) {
        if (streetid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete streetid_;
        }
        if (streetid) {
            set_has_streetid();
            streetid_ = streetid;
        } else {
            clear_has_streetid();
            streetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.streetid)
    }
    
    // required string street_val = 12;
    inline bool QuestionRecommendHouse::has_street_val() const {
        return (_has_bits_[0] & 0x00000800u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_street_val() {
        _has_bits_[0] |= 0x00000800u;
    }
    inline void QuestionRecommendHouse::clear_has_street_val() {
        _has_bits_[0] &= ~0x00000800u;
    }
    inline void QuestionRecommendHouse::clear_street_val() {
        if (street_val_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_->clear();
        }
        clear_has_street_val();
    }
    inline const ::std::string& QuestionRecommendHouse::street_val() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.street_val)
        return *street_val_;
    }
    inline void QuestionRecommendHouse::set_street_val(const ::std::string& value) {
        set_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_ = new ::std::string;
        }
        street_val_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.street_val)
    }
    inline void QuestionRecommendHouse::set_street_val(const char* value) {
        set_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_ = new ::std::string;
        }
        street_val_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.street_val)
    }
    inline void QuestionRecommendHouse::set_street_val(const char* value, size_t size) {
        set_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_ = new ::std::string;
        }
        street_val_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.street_val)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_street_val() {
        set_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.street_val)
        return street_val_;
    }
    inline ::std::string* QuestionRecommendHouse::release_street_val() {
        clear_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = street_val_;
            street_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_street_val(::std::string* street_val) {
        if (street_val_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete street_val_;
        }
        if (street_val) {
            set_has_street_val();
            street_val_ = street_val;
        } else {
            clear_has_street_val();
            street_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.street_val)
    }
    
    // required string house_shi = 13;
    inline bool QuestionRecommendHouse::has_house_shi() const {
        return (_has_bits_[0] & 0x00001000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_house_shi() {
        _has_bits_[0] |= 0x00001000u;
    }
    inline void QuestionRecommendHouse::clear_has_house_shi() {
        _has_bits_[0] &= ~0x00001000u;
    }
    inline void QuestionRecommendHouse::clear_house_shi() {
        if (house_shi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_->clear();
        }
        clear_has_house_shi();
    }
    inline const ::std::string& QuestionRecommendHouse::house_shi() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.house_shi)
        return *house_shi_;
    }
    inline void QuestionRecommendHouse::set_house_shi(const ::std::string& value) {
        set_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_ = new ::std::string;
        }
        house_shi_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.house_shi)
    }
    inline void QuestionRecommendHouse::set_house_shi(const char* value) {
        set_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_ = new ::std::string;
        }
        house_shi_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.house_shi)
    }
    inline void QuestionRecommendHouse::set_house_shi(const char* value, size_t size) {
        set_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_ = new ::std::string;
        }
        house_shi_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.house_shi)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_house_shi() {
        set_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.house_shi)
        return house_shi_;
    }
    inline ::std::string* QuestionRecommendHouse::release_house_shi() {
        clear_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_shi_;
            house_shi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_house_shi(::std::string* house_shi) {
        if (house_shi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_shi_;
        }
        if (house_shi) {
            set_has_house_shi();
            house_shi_ = house_shi;
        } else {
            clear_has_house_shi();
            house_shi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.house_shi)
    }
    
    // required string house_ting = 14;
    inline bool QuestionRecommendHouse::has_house_ting() const {
        return (_has_bits_[0] & 0x00002000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_house_ting() {
        _has_bits_[0] |= 0x00002000u;
    }
    inline void QuestionRecommendHouse::clear_has_house_ting() {
        _has_bits_[0] &= ~0x00002000u;
    }
    inline void QuestionRecommendHouse::clear_house_ting() {
        if (house_ting_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_->clear();
        }
        clear_has_house_ting();
    }
    inline const ::std::string& QuestionRecommendHouse::house_ting() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.house_ting)
        return *house_ting_;
    }
    inline void QuestionRecommendHouse::set_house_ting(const ::std::string& value) {
        set_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_ = new ::std::string;
        }
        house_ting_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.house_ting)
    }
    inline void QuestionRecommendHouse::set_house_ting(const char* value) {
        set_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_ = new ::std::string;
        }
        house_ting_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.house_ting)
    }
    inline void QuestionRecommendHouse::set_house_ting(const char* value, size_t size) {
        set_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_ = new ::std::string;
        }
        house_ting_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.house_ting)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_house_ting() {
        set_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.house_ting)
        return house_ting_;
    }
    inline ::std::string* QuestionRecommendHouse::release_house_ting() {
        clear_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_ting_;
            house_ting_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_house_ting(::std::string* house_ting) {
        if (house_ting_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_ting_;
        }
        if (house_ting) {
            set_has_house_ting();
            house_ting_ = house_ting;
        } else {
            clear_has_house_ting();
            house_ting_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.house_ting)
    }
    
    // required string house_area = 15;
    inline bool QuestionRecommendHouse::has_house_area() const {
        return (_has_bits_[0] & 0x00004000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_house_area() {
        _has_bits_[0] |= 0x00004000u;
    }
    inline void QuestionRecommendHouse::clear_has_house_area() {
        _has_bits_[0] &= ~0x00004000u;
    }
    inline void QuestionRecommendHouse::clear_house_area() {
        if (house_area_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_->clear();
        }
        clear_has_house_area();
    }
    inline const ::std::string& QuestionRecommendHouse::house_area() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.house_area)
        return *house_area_;
    }
    inline void QuestionRecommendHouse::set_house_area(const ::std::string& value) {
        set_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_ = new ::std::string;
        }
        house_area_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.house_area)
    }
    inline void QuestionRecommendHouse::set_house_area(const char* value) {
        set_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_ = new ::std::string;
        }
        house_area_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.house_area)
    }
    inline void QuestionRecommendHouse::set_house_area(const char* value, size_t size) {
        set_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_ = new ::std::string;
        }
        house_area_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.house_area)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_house_area() {
        set_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.house_area)
        return house_area_;
    }
    inline ::std::string* QuestionRecommendHouse::release_house_area() {
        clear_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_area_;
            house_area_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_house_area(::std::string* house_area) {
        if (house_area_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_area_;
        }
        if (house_area) {
            set_has_house_area();
            house_area_ = house_area;
        } else {
            clear_has_house_area();
            house_area_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.house_area)
    }
    
    // required string house_price = 16;
    inline bool QuestionRecommendHouse::has_house_price() const {
        return (_has_bits_[0] & 0x00008000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_house_price() {
        _has_bits_[0] |= 0x00008000u;
    }
    inline void QuestionRecommendHouse::clear_has_house_price() {
        _has_bits_[0] &= ~0x00008000u;
    }
    inline void QuestionRecommendHouse::clear_house_price() {
        if (house_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_->clear();
        }
        clear_has_house_price();
    }
    inline const ::std::string& QuestionRecommendHouse::house_price() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.house_price)
        return *house_price_;
    }
    inline void QuestionRecommendHouse::set_house_price(const ::std::string& value) {
        set_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_ = new ::std::string;
        }
        house_price_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.house_price)
    }
    inline void QuestionRecommendHouse::set_house_price(const char* value) {
        set_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_ = new ::std::string;
        }
        house_price_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.house_price)
    }
    inline void QuestionRecommendHouse::set_house_price(const char* value, size_t size) {
        set_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_ = new ::std::string;
        }
        house_price_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.house_price)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_house_price() {
        set_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.house_price)
        return house_price_;
    }
    inline ::std::string* QuestionRecommendHouse::release_house_price() {
        clear_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_price_;
            house_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_house_price(::std::string* house_price) {
        if (house_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_price_;
        }
        if (house_price) {
            set_has_house_price();
            house_price_ = house_price;
        } else {
            clear_has_house_price();
            house_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.house_price)
    }
    
    // required string rent_price = 17;
    inline bool QuestionRecommendHouse::has_rent_price() const {
        return (_has_bits_[0] & 0x00010000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_rent_price() {
        _has_bits_[0] |= 0x00010000u;
    }
    inline void QuestionRecommendHouse::clear_has_rent_price() {
        _has_bits_[0] &= ~0x00010000u;
    }
    inline void QuestionRecommendHouse::clear_rent_price() {
        if (rent_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_->clear();
        }
        clear_has_rent_price();
    }
    inline const ::std::string& QuestionRecommendHouse::rent_price() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.rent_price)
        return *rent_price_;
    }
    inline void QuestionRecommendHouse::set_rent_price(const ::std::string& value) {
        set_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_ = new ::std::string;
        }
        rent_price_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.rent_price)
    }
    inline void QuestionRecommendHouse::set_rent_price(const char* value) {
        set_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_ = new ::std::string;
        }
        rent_price_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.rent_price)
    }
    inline void QuestionRecommendHouse::set_rent_price(const char* value, size_t size) {
        set_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_ = new ::std::string;
        }
        rent_price_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.rent_price)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_rent_price() {
        set_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.rent_price)
        return rent_price_;
    }
    inline ::std::string* QuestionRecommendHouse::release_rent_price() {
        clear_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = rent_price_;
            rent_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_rent_price(::std::string* rent_price) {
        if (rent_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete rent_price_;
        }
        if (rent_price) {
            set_has_rent_price();
            rent_price_ = rent_price;
        } else {
            clear_has_rent_price();
            rent_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.rent_price)
    }
    
    // required string title = 18;
    inline bool QuestionRecommendHouse::has_title() const {
        return (_has_bits_[0] & 0x00020000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_title() {
        _has_bits_[0] |= 0x00020000u;
    }
    inline void QuestionRecommendHouse::clear_has_title() {
        _has_bits_[0] &= ~0x00020000u;
    }
    inline void QuestionRecommendHouse::clear_title() {
        if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title_->clear();
        }
        clear_has_title();
    }
    inline const ::std::string& QuestionRecommendHouse::title() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.title)
        return *title_;
    }
    inline void QuestionRecommendHouse::set_title(const ::std::string& value) {
        set_has_title();
        if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title_ = new ::std::string;
        }
        title_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.title)
    }
    inline void QuestionRecommendHouse::set_title(const char* value) {
        set_has_title();
        if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title_ = new ::std::string;
        }
        title_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.title)
    }
    inline void QuestionRecommendHouse::set_title(const char* value, size_t size) {
        set_has_title();
        if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title_ = new ::std::string;
        }
        title_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.title)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_title() {
        set_has_title();
        if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.title)
        return title_;
    }
    inline ::std::string* QuestionRecommendHouse::release_title() {
        clear_has_title();
        if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = title_;
            title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_title(::std::string* title) {
        if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete title_;
        }
        if (title) {
            set_has_title();
            title_ = title;
        } else {
            clear_has_title();
            title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.title)
    }
    
    // required string time_stamp = 19;
    inline bool QuestionRecommendHouse::has_time_stamp() const {
        return (_has_bits_[0] & 0x00040000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_time_stamp() {
        _has_bits_[0] |= 0x00040000u;
    }
    inline void QuestionRecommendHouse::clear_has_time_stamp() {
        _has_bits_[0] &= ~0x00040000u;
    }
    inline void QuestionRecommendHouse::clear_time_stamp() {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_->clear();
        }
        clear_has_time_stamp();
    }
    inline const ::std::string& QuestionRecommendHouse::time_stamp() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.time_stamp)
        return *time_stamp_;
    }
    inline void QuestionRecommendHouse::set_time_stamp(const ::std::string& value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.time_stamp)
    }
    inline void QuestionRecommendHouse::set_time_stamp(const char* value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.time_stamp)
    }
    inline void QuestionRecommendHouse::set_time_stamp(const char* value, size_t size) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.time_stamp)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_time_stamp() {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.time_stamp)
        return time_stamp_;
    }
    inline ::std::string* QuestionRecommendHouse::release_time_stamp() {
        clear_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = time_stamp_;
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_time_stamp(::std::string* time_stamp) {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete time_stamp_;
        }
        if (time_stamp) {
            set_has_time_stamp();
            time_stamp_ = time_stamp;
        } else {
            clear_has_time_stamp();
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.time_stamp)
    }
    
    // required string t_avatar = 20;
    inline bool QuestionRecommendHouse::has_t_avatar() const {
        return (_has_bits_[0] & 0x00080000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_t_avatar() {
        _has_bits_[0] |= 0x00080000u;
    }
    inline void QuestionRecommendHouse::clear_has_t_avatar() {
        _has_bits_[0] &= ~0x00080000u;
    }
    inline void QuestionRecommendHouse::clear_t_avatar() {
        if (t_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_->clear();
        }
        clear_has_t_avatar();
    }
    inline const ::std::string& QuestionRecommendHouse::t_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.t_avatar)
        return *t_avatar_;
    }
    inline void QuestionRecommendHouse::set_t_avatar(const ::std::string& value) {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        t_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.t_avatar)
    }
    inline void QuestionRecommendHouse::set_t_avatar(const char* value) {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        t_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.t_avatar)
    }
    inline void QuestionRecommendHouse::set_t_avatar(const char* value, size_t size) {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        t_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.t_avatar)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_t_avatar() {
        set_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.t_avatar)
        return t_avatar_;
    }
    inline ::std::string* QuestionRecommendHouse::release_t_avatar() {
        clear_has_t_avatar();
        if (t_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_avatar_;
            t_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_t_avatar(::std::string* t_avatar) {
        if (t_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_avatar_;
        }
        if (t_avatar) {
            set_has_t_avatar();
            t_avatar_ = t_avatar;
        } else {
            clear_has_t_avatar();
            t_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.t_avatar)
    }
    
    // required string t_name = 21;
    inline bool QuestionRecommendHouse::has_t_name() const {
        return (_has_bits_[0] & 0x00100000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_t_name() {
        _has_bits_[0] |= 0x00100000u;
    }
    inline void QuestionRecommendHouse::clear_has_t_name() {
        _has_bits_[0] &= ~0x00100000u;
    }
    inline void QuestionRecommendHouse::clear_t_name() {
        if (t_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_->clear();
        }
        clear_has_t_name();
    }
    inline const ::std::string& QuestionRecommendHouse::t_name() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.t_name)
        return *t_name_;
    }
    inline void QuestionRecommendHouse::set_t_name(const ::std::string& value) {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        t_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.t_name)
    }
    inline void QuestionRecommendHouse::set_t_name(const char* value) {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        t_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.t_name)
    }
    inline void QuestionRecommendHouse::set_t_name(const char* value, size_t size) {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        t_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.t_name)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_t_name() {
        set_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.t_name)
        return t_name_;
    }
    inline ::std::string* QuestionRecommendHouse::release_t_name() {
        clear_has_t_name();
        if (t_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_name_;
            t_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_t_name(::std::string* t_name) {
        if (t_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_name_;
        }
        if (t_name) {
            set_has_t_name();
            t_name_ = t_name;
        } else {
            clear_has_t_name();
            t_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.t_name)
    }
    
    // required string t_leve = 22;
    inline bool QuestionRecommendHouse::has_t_leve() const {
        return (_has_bits_[0] & 0x00200000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_t_leve() {
        _has_bits_[0] |= 0x00200000u;
    }
    inline void QuestionRecommendHouse::clear_has_t_leve() {
        _has_bits_[0] &= ~0x00200000u;
    }
    inline void QuestionRecommendHouse::clear_t_leve() {
        if (t_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_->clear();
        }
        clear_has_t_leve();
    }
    inline const ::std::string& QuestionRecommendHouse::t_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.t_leve)
        return *t_leve_;
    }
    inline void QuestionRecommendHouse::set_t_leve(const ::std::string& value) {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        t_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.t_leve)
    }
    inline void QuestionRecommendHouse::set_t_leve(const char* value) {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        t_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.t_leve)
    }
    inline void QuestionRecommendHouse::set_t_leve(const char* value, size_t size) {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        t_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.t_leve)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_t_leve() {
        set_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.t_leve)
        return t_leve_;
    }
    inline ::std::string* QuestionRecommendHouse::release_t_leve() {
        clear_has_t_leve();
        if (t_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_leve_;
            t_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_t_leve(::std::string* t_leve) {
        if (t_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_leve_;
        }
        if (t_leve) {
            set_has_t_leve();
            t_leve_ = t_leve;
        } else {
            clear_has_t_leve();
            t_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.t_leve)
    }
    
    // required string t_user_type = 23;
    inline bool QuestionRecommendHouse::has_t_user_type() const {
        return (_has_bits_[0] & 0x00400000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_t_user_type() {
        _has_bits_[0] |= 0x00400000u;
    }
    inline void QuestionRecommendHouse::clear_has_t_user_type() {
        _has_bits_[0] &= ~0x00400000u;
    }
    inline void QuestionRecommendHouse::clear_t_user_type() {
        if (t_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_->clear();
        }
        clear_has_t_user_type();
    }
    inline const ::std::string& QuestionRecommendHouse::t_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.t_user_type)
        return *t_user_type_;
    }
    inline void QuestionRecommendHouse::set_t_user_type(const ::std::string& value) {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        t_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.t_user_type)
    }
    inline void QuestionRecommendHouse::set_t_user_type(const char* value) {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        t_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.t_user_type)
    }
    inline void QuestionRecommendHouse::set_t_user_type(const char* value, size_t size) {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        t_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.t_user_type)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_t_user_type() {
        set_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            t_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.t_user_type)
        return t_user_type_;
    }
    inline ::std::string* QuestionRecommendHouse::release_t_user_type() {
        clear_has_t_user_type();
        if (t_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = t_user_type_;
            t_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_t_user_type(::std::string* t_user_type) {
        if (t_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete t_user_type_;
        }
        if (t_user_type) {
            set_has_t_user_type();
            t_user_type_ = t_user_type;
        } else {
            clear_has_t_user_type();
            t_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.t_user_type)
    }
    
    // required string m_avatar = 24;
    inline bool QuestionRecommendHouse::has_m_avatar() const {
        return (_has_bits_[0] & 0x00800000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_m_avatar() {
        _has_bits_[0] |= 0x00800000u;
    }
    inline void QuestionRecommendHouse::clear_has_m_avatar() {
        _has_bits_[0] &= ~0x00800000u;
    }
    inline void QuestionRecommendHouse::clear_m_avatar() {
        if (m_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_->clear();
        }
        clear_has_m_avatar();
    }
    inline const ::std::string& QuestionRecommendHouse::m_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.m_avatar)
        return *m_avatar_;
    }
    inline void QuestionRecommendHouse::set_m_avatar(const ::std::string& value) {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        m_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.m_avatar)
    }
    inline void QuestionRecommendHouse::set_m_avatar(const char* value) {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        m_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.m_avatar)
    }
    inline void QuestionRecommendHouse::set_m_avatar(const char* value, size_t size) {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        m_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.m_avatar)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_m_avatar() {
        set_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.m_avatar)
        return m_avatar_;
    }
    inline ::std::string* QuestionRecommendHouse::release_m_avatar() {
        clear_has_m_avatar();
        if (m_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_avatar_;
            m_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_m_avatar(::std::string* m_avatar) {
        if (m_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_avatar_;
        }
        if (m_avatar) {
            set_has_m_avatar();
            m_avatar_ = m_avatar;
        } else {
            clear_has_m_avatar();
            m_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.m_avatar)
    }
    
    // required string m_name = 25;
    inline bool QuestionRecommendHouse::has_m_name() const {
        return (_has_bits_[0] & 0x01000000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_m_name() {
        _has_bits_[0] |= 0x01000000u;
    }
    inline void QuestionRecommendHouse::clear_has_m_name() {
        _has_bits_[0] &= ~0x01000000u;
    }
    inline void QuestionRecommendHouse::clear_m_name() {
        if (m_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_->clear();
        }
        clear_has_m_name();
    }
    inline const ::std::string& QuestionRecommendHouse::m_name() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.m_name)
        return *m_name_;
    }
    inline void QuestionRecommendHouse::set_m_name(const ::std::string& value) {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        m_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.m_name)
    }
    inline void QuestionRecommendHouse::set_m_name(const char* value) {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        m_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.m_name)
    }
    inline void QuestionRecommendHouse::set_m_name(const char* value, size_t size) {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        m_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.m_name)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_m_name() {
        set_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.m_name)
        return m_name_;
    }
    inline ::std::string* QuestionRecommendHouse::release_m_name() {
        clear_has_m_name();
        if (m_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_name_;
            m_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_m_name(::std::string* m_name) {
        if (m_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_name_;
        }
        if (m_name) {
            set_has_m_name();
            m_name_ = m_name;
        } else {
            clear_has_m_name();
            m_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.m_name)
    }
    
    // required string m_leve = 26;
    inline bool QuestionRecommendHouse::has_m_leve() const {
        return (_has_bits_[0] & 0x02000000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_m_leve() {
        _has_bits_[0] |= 0x02000000u;
    }
    inline void QuestionRecommendHouse::clear_has_m_leve() {
        _has_bits_[0] &= ~0x02000000u;
    }
    inline void QuestionRecommendHouse::clear_m_leve() {
        if (m_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_->clear();
        }
        clear_has_m_leve();
    }
    inline const ::std::string& QuestionRecommendHouse::m_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.m_leve)
        return *m_leve_;
    }
    inline void QuestionRecommendHouse::set_m_leve(const ::std::string& value) {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        m_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.m_leve)
    }
    inline void QuestionRecommendHouse::set_m_leve(const char* value) {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        m_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.m_leve)
    }
    inline void QuestionRecommendHouse::set_m_leve(const char* value, size_t size) {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        m_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.m_leve)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_m_leve() {
        set_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.m_leve)
        return m_leve_;
    }
    inline ::std::string* QuestionRecommendHouse::release_m_leve() {
        clear_has_m_leve();
        if (m_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_leve_;
            m_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_m_leve(::std::string* m_leve) {
        if (m_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_leve_;
        }
        if (m_leve) {
            set_has_m_leve();
            m_leve_ = m_leve;
        } else {
            clear_has_m_leve();
            m_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.m_leve)
    }
    
    // required string m_user_type = 27;
    inline bool QuestionRecommendHouse::has_m_user_type() const {
        return (_has_bits_[0] & 0x04000000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_m_user_type() {
        _has_bits_[0] |= 0x04000000u;
    }
    inline void QuestionRecommendHouse::clear_has_m_user_type() {
        _has_bits_[0] &= ~0x04000000u;
    }
    inline void QuestionRecommendHouse::clear_m_user_type() {
        if (m_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_->clear();
        }
        clear_has_m_user_type();
    }
    inline const ::std::string& QuestionRecommendHouse::m_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.m_user_type)
        return *m_user_type_;
    }
    inline void QuestionRecommendHouse::set_m_user_type(const ::std::string& value) {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        m_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.m_user_type)
    }
    inline void QuestionRecommendHouse::set_m_user_type(const char* value) {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        m_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.m_user_type)
    }
    inline void QuestionRecommendHouse::set_m_user_type(const char* value, size_t size) {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        m_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.m_user_type)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_m_user_type() {
        set_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            m_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.m_user_type)
        return m_user_type_;
    }
    inline ::std::string* QuestionRecommendHouse::release_m_user_type() {
        clear_has_m_user_type();
        if (m_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = m_user_type_;
            m_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_m_user_type(::std::string* m_user_type) {
        if (m_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete m_user_type_;
        }
        if (m_user_type) {
            set_has_m_user_type();
            m_user_type_ = m_user_type;
        } else {
            clear_has_m_user_type();
            m_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.m_user_type)
    }
    
    // required string device_udid = 28;
    inline bool QuestionRecommendHouse::has_device_udid() const {
        return (_has_bits_[0] & 0x08000000u) != 0;
    }
    inline void QuestionRecommendHouse::set_has_device_udid() {
        _has_bits_[0] |= 0x08000000u;
    }
    inline void QuestionRecommendHouse::clear_has_device_udid() {
        _has_bits_[0] &= ~0x08000000u;
    }
    inline void QuestionRecommendHouse::clear_device_udid() {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_->clear();
        }
        clear_has_device_udid();
    }
    inline const ::std::string& QuestionRecommendHouse::device_udid() const {
        // @@protoc_insertion_point(field_get:QSChat.QuestionRecommendHouse.device_udid)
        return *device_udid_;
    }
    inline void QuestionRecommendHouse::set_device_udid(const ::std::string& value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.QuestionRecommendHouse.device_udid)
    }
    inline void QuestionRecommendHouse::set_device_udid(const char* value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.QuestionRecommendHouse.device_udid)
    }
    inline void QuestionRecommendHouse::set_device_udid(const char* value, size_t size) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.QuestionRecommendHouse.device_udid)
    }
    inline ::std::string* QuestionRecommendHouse::mutable_device_udid() {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.QuestionRecommendHouse.device_udid)
        return device_udid_;
    }
    inline ::std::string* QuestionRecommendHouse::release_device_udid() {
        clear_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_udid_;
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void QuestionRecommendHouse::set_allocated_device_udid(::std::string* device_udid) {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_udid_;
        }
        if (device_udid) {
            set_has_device_udid();
            device_udid_ = device_udid;
        } else {
            clear_has_device_udid();
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.QuestionRecommendHouse.device_udid)
    }
    
    // -------------------------------------------------------------------
    
    // AnswerWord
    
    // required string result = 1;
    inline bool AnswerWord::has_result() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void AnswerWord::set_has_result() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void AnswerWord::clear_has_result() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void AnswerWord::clear_result() {
        if (result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_->clear();
        }
        clear_has_result();
    }
    inline const ::std::string& AnswerWord::result() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerWord.result)
        return *result_;
    }
    inline void AnswerWord::set_result(const ::std::string& value) {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        result_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerWord.result)
    }
    inline void AnswerWord::set_result(const char* value) {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        result_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerWord.result)
    }
    inline void AnswerWord::set_result(const char* value, size_t size) {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        result_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerWord.result)
    }
    inline ::std::string* AnswerWord::mutable_result() {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerWord.result)
        return result_;
    }
    inline ::std::string* AnswerWord::release_result() {
        clear_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = result_;
            result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerWord::set_allocated_result(::std::string* result) {
        if (result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete result_;
        }
        if (result) {
            set_has_result();
            result_ = result;
        } else {
            clear_has_result();
            result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerWord.result)
    }
    
    // required string message = 2;
    inline bool AnswerWord::has_message() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void AnswerWord::set_has_message() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void AnswerWord::clear_has_message() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void AnswerWord::clear_message() {
        if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            message_->clear();
        }
        clear_has_message();
    }
    inline const ::std::string& AnswerWord::message() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerWord.message)
        return *message_;
    }
    inline void AnswerWord::set_message(const ::std::string& value) {
        set_has_message();
        if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            message_ = new ::std::string;
        }
        message_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerWord.message)
    }
    inline void AnswerWord::set_message(const char* value) {
        set_has_message();
        if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            message_ = new ::std::string;
        }
        message_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerWord.message)
    }
    inline void AnswerWord::set_message(const char* value, size_t size) {
        set_has_message();
        if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            message_ = new ::std::string;
        }
        message_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerWord.message)
    }
    inline ::std::string* AnswerWord::mutable_message() {
        set_has_message();
        if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            message_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerWord.message)
        return message_;
    }
    inline ::std::string* AnswerWord::release_message() {
        clear_has_message();
        if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = message_;
            message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerWord::set_allocated_message(::std::string* message) {
        if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete message_;
        }
        if (message) {
            set_has_message();
            message_ = message;
        } else {
            clear_has_message();
            message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerWord.message)
    }
    
    // required string msg_id = 3;
    inline bool AnswerWord::has_msg_id() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void AnswerWord::set_has_msg_id() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void AnswerWord::clear_has_msg_id() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void AnswerWord::clear_msg_id() {
        if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_->clear();
        }
        clear_has_msg_id();
    }
    inline const ::std::string& AnswerWord::msg_id() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerWord.msg_id)
        return *msg_id_;
    }
    inline void AnswerWord::set_msg_id(const ::std::string& value) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerWord.msg_id)
    }
    inline void AnswerWord::set_msg_id(const char* value) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerWord.msg_id)
    }
    inline void AnswerWord::set_msg_id(const char* value, size_t size) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerWord.msg_id)
    }
    inline ::std::string* AnswerWord::mutable_msg_id() {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerWord.msg_id)
        return msg_id_;
    }
    inline ::std::string* AnswerWord::release_msg_id() {
        clear_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = msg_id_;
            msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerWord::set_allocated_msg_id(::std::string* msg_id) {
        if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete msg_id_;
        }
        if (msg_id) {
            set_has_msg_id();
            msg_id_ = msg_id;
        } else {
            clear_has_msg_id();
            msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerWord.msg_id)
    }
    
    // required string time_stamp = 4;
    inline bool AnswerWord::has_time_stamp() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void AnswerWord::set_has_time_stamp() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void AnswerWord::clear_has_time_stamp() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void AnswerWord::clear_time_stamp() {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_->clear();
        }
        clear_has_time_stamp();
    }
    inline const ::std::string& AnswerWord::time_stamp() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerWord.time_stamp)
        return *time_stamp_;
    }
    inline void AnswerWord::set_time_stamp(const ::std::string& value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerWord.time_stamp)
    }
    inline void AnswerWord::set_time_stamp(const char* value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerWord.time_stamp)
    }
    inline void AnswerWord::set_time_stamp(const char* value, size_t size) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerWord.time_stamp)
    }
    inline ::std::string* AnswerWord::mutable_time_stamp() {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerWord.time_stamp)
        return time_stamp_;
    }
    inline ::std::string* AnswerWord::release_time_stamp() {
        clear_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = time_stamp_;
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerWord::set_allocated_time_stamp(::std::string* time_stamp) {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete time_stamp_;
        }
        if (time_stamp) {
            set_has_time_stamp();
            time_stamp_ = time_stamp;
        } else {
            clear_has_time_stamp();
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerWord.time_stamp)
    }
    
    // required int64 fid = 5;
    inline bool AnswerWord::has_fid() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void AnswerWord::set_has_fid() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void AnswerWord::clear_has_fid() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void AnswerWord::clear_fid() {
        fid_ = GOOGLE_LONGLONG(0);
        clear_has_fid();
    }
    inline ::google::protobuf::int64 AnswerWord::fid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerWord.fid)
        return fid_;
    }
    inline void AnswerWord::set_fid(::google::protobuf::int64 value) {
        set_has_fid();
        fid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.AnswerWord.fid)
    }
    
    // required string f_avatar = 6;
    inline bool AnswerWord::has_f_avatar() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void AnswerWord::set_has_f_avatar() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void AnswerWord::clear_has_f_avatar() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void AnswerWord::clear_f_avatar() {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_->clear();
        }
        clear_has_f_avatar();
    }
    inline const ::std::string& AnswerWord::f_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerWord.f_avatar)
        return *f_avatar_;
    }
    inline void AnswerWord::set_f_avatar(const ::std::string& value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerWord.f_avatar)
    }
    inline void AnswerWord::set_f_avatar(const char* value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerWord.f_avatar)
    }
    inline void AnswerWord::set_f_avatar(const char* value, size_t size) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerWord.f_avatar)
    }
    inline ::std::string* AnswerWord::mutable_f_avatar() {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerWord.f_avatar)
        return f_avatar_;
    }
    inline ::std::string* AnswerWord::release_f_avatar() {
        clear_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_avatar_;
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerWord::set_allocated_f_avatar(::std::string* f_avatar) {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_avatar_;
        }
        if (f_avatar) {
            set_has_f_avatar();
            f_avatar_ = f_avatar;
        } else {
            clear_has_f_avatar();
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerWord.f_avatar)
    }
    
    // required string f_name = 7;
    inline bool AnswerWord::has_f_name() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void AnswerWord::set_has_f_name() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void AnswerWord::clear_has_f_name() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void AnswerWord::clear_f_name() {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_->clear();
        }
        clear_has_f_name();
    }
    inline const ::std::string& AnswerWord::f_name() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerWord.f_name)
        return *f_name_;
    }
    inline void AnswerWord::set_f_name(const ::std::string& value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerWord.f_name)
    }
    inline void AnswerWord::set_f_name(const char* value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerWord.f_name)
    }
    inline void AnswerWord::set_f_name(const char* value, size_t size) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerWord.f_name)
    }
    inline ::std::string* AnswerWord::mutable_f_name() {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerWord.f_name)
        return f_name_;
    }
    inline ::std::string* AnswerWord::release_f_name() {
        clear_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_name_;
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerWord::set_allocated_f_name(::std::string* f_name) {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_name_;
        }
        if (f_name) {
            set_has_f_name();
            f_name_ = f_name;
        } else {
            clear_has_f_name();
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerWord.f_name)
    }
    
    // required string f_leve = 8;
    inline bool AnswerWord::has_f_leve() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void AnswerWord::set_has_f_leve() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void AnswerWord::clear_has_f_leve() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void AnswerWord::clear_f_leve() {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_->clear();
        }
        clear_has_f_leve();
    }
    inline const ::std::string& AnswerWord::f_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerWord.f_leve)
        return *f_leve_;
    }
    inline void AnswerWord::set_f_leve(const ::std::string& value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerWord.f_leve)
    }
    inline void AnswerWord::set_f_leve(const char* value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerWord.f_leve)
    }
    inline void AnswerWord::set_f_leve(const char* value, size_t size) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerWord.f_leve)
    }
    inline ::std::string* AnswerWord::mutable_f_leve() {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerWord.f_leve)
        return f_leve_;
    }
    inline ::std::string* AnswerWord::release_f_leve() {
        clear_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_leve_;
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerWord::set_allocated_f_leve(::std::string* f_leve) {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_leve_;
        }
        if (f_leve) {
            set_has_f_leve();
            f_leve_ = f_leve;
        } else {
            clear_has_f_leve();
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerWord.f_leve)
    }
    
    // required string f_user_type = 9;
    inline bool AnswerWord::has_f_user_type() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void AnswerWord::set_has_f_user_type() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void AnswerWord::clear_has_f_user_type() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void AnswerWord::clear_f_user_type() {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_->clear();
        }
        clear_has_f_user_type();
    }
    inline const ::std::string& AnswerWord::f_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerWord.f_user_type)
        return *f_user_type_;
    }
    inline void AnswerWord::set_f_user_type(const ::std::string& value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerWord.f_user_type)
    }
    inline void AnswerWord::set_f_user_type(const char* value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerWord.f_user_type)
    }
    inline void AnswerWord::set_f_user_type(const char* value, size_t size) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerWord.f_user_type)
    }
    inline ::std::string* AnswerWord::mutable_f_user_type() {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerWord.f_user_type)
        return f_user_type_;
    }
    inline ::std::string* AnswerWord::release_f_user_type() {
        clear_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_user_type_;
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerWord::set_allocated_f_user_type(::std::string* f_user_type) {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_user_type_;
        }
        if (f_user_type) {
            set_has_f_user_type();
            f_user_type_ = f_user_type;
        } else {
            clear_has_f_user_type();
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerWord.f_user_type)
    }
    
    // required string f_unread_count = 10;
    inline bool AnswerWord::has_f_unread_count() const {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void AnswerWord::set_has_f_unread_count() {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void AnswerWord::clear_has_f_unread_count() {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void AnswerWord::clear_f_unread_count() {
        if (f_unread_count_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_->clear();
        }
        clear_has_f_unread_count();
    }
    inline const ::std::string& AnswerWord::f_unread_count() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerWord.f_unread_count)
        return *f_unread_count_;
    }
    inline void AnswerWord::set_f_unread_count(const ::std::string& value) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerWord.f_unread_count)
    }
    inline void AnswerWord::set_f_unread_count(const char* value) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerWord.f_unread_count)
    }
    inline void AnswerWord::set_f_unread_count(const char* value, size_t size) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerWord.f_unread_count)
    }
    inline ::std::string* AnswerWord::mutable_f_unread_count() {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerWord.f_unread_count)
        return f_unread_count_;
    }
    inline ::std::string* AnswerWord::release_f_unread_count() {
        clear_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_unread_count_;
            f_unread_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerWord::set_allocated_f_unread_count(::std::string* f_unread_count) {
        if (f_unread_count_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_unread_count_;
        }
        if (f_unread_count) {
            set_has_f_unread_count();
            f_unread_count_ = f_unread_count;
        } else {
            clear_has_f_unread_count();
            f_unread_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerWord.f_unread_count)
    }
    
    // required string device_udid = 11;
    inline bool AnswerWord::has_device_udid() const {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void AnswerWord::set_has_device_udid() {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void AnswerWord::clear_has_device_udid() {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void AnswerWord::clear_device_udid() {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_->clear();
        }
        clear_has_device_udid();
    }
    inline const ::std::string& AnswerWord::device_udid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerWord.device_udid)
        return *device_udid_;
    }
    inline void AnswerWord::set_device_udid(const ::std::string& value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerWord.device_udid)
    }
    inline void AnswerWord::set_device_udid(const char* value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerWord.device_udid)
    }
    inline void AnswerWord::set_device_udid(const char* value, size_t size) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerWord.device_udid)
    }
    inline ::std::string* AnswerWord::mutable_device_udid() {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerWord.device_udid)
        return device_udid_;
    }
    inline ::std::string* AnswerWord::release_device_udid() {
        clear_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_udid_;
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerWord::set_allocated_device_udid(::std::string* device_udid) {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_udid_;
        }
        if (device_udid) {
            set_has_device_udid();
            device_udid_ = device_udid;
        } else {
            clear_has_device_udid();
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerWord.device_udid)
    }
    
    // -------------------------------------------------------------------
    
    // AnswerPic
    
    // required string result = 1;
    inline bool AnswerPic::has_result() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void AnswerPic::set_has_result() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void AnswerPic::clear_has_result() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void AnswerPic::clear_result() {
        if (result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_->clear();
        }
        clear_has_result();
    }
    inline const ::std::string& AnswerPic::result() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerPic.result)
        return *result_;
    }
    inline void AnswerPic::set_result(const ::std::string& value) {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        result_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerPic.result)
    }
    inline void AnswerPic::set_result(const char* value) {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        result_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerPic.result)
    }
    inline void AnswerPic::set_result(const char* value, size_t size) {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        result_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerPic.result)
    }
    inline ::std::string* AnswerPic::mutable_result() {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerPic.result)
        return result_;
    }
    inline ::std::string* AnswerPic::release_result() {
        clear_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = result_;
            result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerPic::set_allocated_result(::std::string* result) {
        if (result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete result_;
        }
        if (result) {
            set_has_result();
            result_ = result;
        } else {
            clear_has_result();
            result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerPic.result)
    }
    
    // required bytes pic = 2;
    inline bool AnswerPic::has_pic() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void AnswerPic::set_has_pic() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void AnswerPic::clear_has_pic() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void AnswerPic::clear_pic() {
        if (pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_->clear();
        }
        clear_has_pic();
    }
    inline const ::std::string& AnswerPic::pic() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerPic.pic)
        return *pic_;
    }
    inline void AnswerPic::set_pic(const ::std::string& value) {
        set_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_ = new ::std::string;
        }
        pic_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerPic.pic)
    }
    inline void AnswerPic::set_pic(const char* value) {
        set_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_ = new ::std::string;
        }
        pic_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerPic.pic)
    }
    inline void AnswerPic::set_pic(const void* value, size_t size) {
        set_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_ = new ::std::string;
        }
        pic_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerPic.pic)
    }
    inline ::std::string* AnswerPic::mutable_pic() {
        set_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerPic.pic)
        return pic_;
    }
    inline ::std::string* AnswerPic::release_pic() {
        clear_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = pic_;
            pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerPic::set_allocated_pic(::std::string* pic) {
        if (pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete pic_;
        }
        if (pic) {
            set_has_pic();
            pic_ = pic;
        } else {
            clear_has_pic();
            pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerPic.pic)
    }
    
    // required string msg_id = 3;
    inline bool AnswerPic::has_msg_id() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void AnswerPic::set_has_msg_id() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void AnswerPic::clear_has_msg_id() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void AnswerPic::clear_msg_id() {
        if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_->clear();
        }
        clear_has_msg_id();
    }
    inline const ::std::string& AnswerPic::msg_id() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerPic.msg_id)
        return *msg_id_;
    }
    inline void AnswerPic::set_msg_id(const ::std::string& value) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerPic.msg_id)
    }
    inline void AnswerPic::set_msg_id(const char* value) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerPic.msg_id)
    }
    inline void AnswerPic::set_msg_id(const char* value, size_t size) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerPic.msg_id)
    }
    inline ::std::string* AnswerPic::mutable_msg_id() {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerPic.msg_id)
        return msg_id_;
    }
    inline ::std::string* AnswerPic::release_msg_id() {
        clear_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = msg_id_;
            msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerPic::set_allocated_msg_id(::std::string* msg_id) {
        if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete msg_id_;
        }
        if (msg_id) {
            set_has_msg_id();
            msg_id_ = msg_id;
        } else {
            clear_has_msg_id();
            msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerPic.msg_id)
    }
    
    // required string time_stamp = 4;
    inline bool AnswerPic::has_time_stamp() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void AnswerPic::set_has_time_stamp() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void AnswerPic::clear_has_time_stamp() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void AnswerPic::clear_time_stamp() {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_->clear();
        }
        clear_has_time_stamp();
    }
    inline const ::std::string& AnswerPic::time_stamp() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerPic.time_stamp)
        return *time_stamp_;
    }
    inline void AnswerPic::set_time_stamp(const ::std::string& value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerPic.time_stamp)
    }
    inline void AnswerPic::set_time_stamp(const char* value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerPic.time_stamp)
    }
    inline void AnswerPic::set_time_stamp(const char* value, size_t size) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerPic.time_stamp)
    }
    inline ::std::string* AnswerPic::mutable_time_stamp() {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerPic.time_stamp)
        return time_stamp_;
    }
    inline ::std::string* AnswerPic::release_time_stamp() {
        clear_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = time_stamp_;
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerPic::set_allocated_time_stamp(::std::string* time_stamp) {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete time_stamp_;
        }
        if (time_stamp) {
            set_has_time_stamp();
            time_stamp_ = time_stamp;
        } else {
            clear_has_time_stamp();
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerPic.time_stamp)
    }
    
    // required int64 fid = 5;
    inline bool AnswerPic::has_fid() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void AnswerPic::set_has_fid() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void AnswerPic::clear_has_fid() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void AnswerPic::clear_fid() {
        fid_ = GOOGLE_LONGLONG(0);
        clear_has_fid();
    }
    inline ::google::protobuf::int64 AnswerPic::fid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerPic.fid)
        return fid_;
    }
    inline void AnswerPic::set_fid(::google::protobuf::int64 value) {
        set_has_fid();
        fid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.AnswerPic.fid)
    }
    
    // required string f_avatar = 6;
    inline bool AnswerPic::has_f_avatar() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void AnswerPic::set_has_f_avatar() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void AnswerPic::clear_has_f_avatar() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void AnswerPic::clear_f_avatar() {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_->clear();
        }
        clear_has_f_avatar();
    }
    inline const ::std::string& AnswerPic::f_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerPic.f_avatar)
        return *f_avatar_;
    }
    inline void AnswerPic::set_f_avatar(const ::std::string& value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerPic.f_avatar)
    }
    inline void AnswerPic::set_f_avatar(const char* value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerPic.f_avatar)
    }
    inline void AnswerPic::set_f_avatar(const char* value, size_t size) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerPic.f_avatar)
    }
    inline ::std::string* AnswerPic::mutable_f_avatar() {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerPic.f_avatar)
        return f_avatar_;
    }
    inline ::std::string* AnswerPic::release_f_avatar() {
        clear_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_avatar_;
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerPic::set_allocated_f_avatar(::std::string* f_avatar) {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_avatar_;
        }
        if (f_avatar) {
            set_has_f_avatar();
            f_avatar_ = f_avatar;
        } else {
            clear_has_f_avatar();
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerPic.f_avatar)
    }
    
    // required string f_name = 7;
    inline bool AnswerPic::has_f_name() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void AnswerPic::set_has_f_name() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void AnswerPic::clear_has_f_name() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void AnswerPic::clear_f_name() {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_->clear();
        }
        clear_has_f_name();
    }
    inline const ::std::string& AnswerPic::f_name() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerPic.f_name)
        return *f_name_;
    }
    inline void AnswerPic::set_f_name(const ::std::string& value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerPic.f_name)
    }
    inline void AnswerPic::set_f_name(const char* value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerPic.f_name)
    }
    inline void AnswerPic::set_f_name(const char* value, size_t size) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerPic.f_name)
    }
    inline ::std::string* AnswerPic::mutable_f_name() {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerPic.f_name)
        return f_name_;
    }
    inline ::std::string* AnswerPic::release_f_name() {
        clear_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_name_;
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerPic::set_allocated_f_name(::std::string* f_name) {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_name_;
        }
        if (f_name) {
            set_has_f_name();
            f_name_ = f_name;
        } else {
            clear_has_f_name();
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerPic.f_name)
    }
    
    // required string f_leve = 8;
    inline bool AnswerPic::has_f_leve() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void AnswerPic::set_has_f_leve() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void AnswerPic::clear_has_f_leve() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void AnswerPic::clear_f_leve() {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_->clear();
        }
        clear_has_f_leve();
    }
    inline const ::std::string& AnswerPic::f_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerPic.f_leve)
        return *f_leve_;
    }
    inline void AnswerPic::set_f_leve(const ::std::string& value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerPic.f_leve)
    }
    inline void AnswerPic::set_f_leve(const char* value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerPic.f_leve)
    }
    inline void AnswerPic::set_f_leve(const char* value, size_t size) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerPic.f_leve)
    }
    inline ::std::string* AnswerPic::mutable_f_leve() {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerPic.f_leve)
        return f_leve_;
    }
    inline ::std::string* AnswerPic::release_f_leve() {
        clear_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_leve_;
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerPic::set_allocated_f_leve(::std::string* f_leve) {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_leve_;
        }
        if (f_leve) {
            set_has_f_leve();
            f_leve_ = f_leve;
        } else {
            clear_has_f_leve();
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerPic.f_leve)
    }
    
    // required string f_user_type = 9;
    inline bool AnswerPic::has_f_user_type() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void AnswerPic::set_has_f_user_type() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void AnswerPic::clear_has_f_user_type() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void AnswerPic::clear_f_user_type() {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_->clear();
        }
        clear_has_f_user_type();
    }
    inline const ::std::string& AnswerPic::f_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerPic.f_user_type)
        return *f_user_type_;
    }
    inline void AnswerPic::set_f_user_type(const ::std::string& value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerPic.f_user_type)
    }
    inline void AnswerPic::set_f_user_type(const char* value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerPic.f_user_type)
    }
    inline void AnswerPic::set_f_user_type(const char* value, size_t size) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerPic.f_user_type)
    }
    inline ::std::string* AnswerPic::mutable_f_user_type() {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerPic.f_user_type)
        return f_user_type_;
    }
    inline ::std::string* AnswerPic::release_f_user_type() {
        clear_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_user_type_;
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerPic::set_allocated_f_user_type(::std::string* f_user_type) {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_user_type_;
        }
        if (f_user_type) {
            set_has_f_user_type();
            f_user_type_ = f_user_type;
        } else {
            clear_has_f_user_type();
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerPic.f_user_type)
    }
    
    // required string f_unread_count = 10;
    inline bool AnswerPic::has_f_unread_count() const {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void AnswerPic::set_has_f_unread_count() {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void AnswerPic::clear_has_f_unread_count() {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void AnswerPic::clear_f_unread_count() {
        if (f_unread_count_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_->clear();
        }
        clear_has_f_unread_count();
    }
    inline const ::std::string& AnswerPic::f_unread_count() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerPic.f_unread_count)
        return *f_unread_count_;
    }
    inline void AnswerPic::set_f_unread_count(const ::std::string& value) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerPic.f_unread_count)
    }
    inline void AnswerPic::set_f_unread_count(const char* value) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerPic.f_unread_count)
    }
    inline void AnswerPic::set_f_unread_count(const char* value, size_t size) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerPic.f_unread_count)
    }
    inline ::std::string* AnswerPic::mutable_f_unread_count() {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerPic.f_unread_count)
        return f_unread_count_;
    }
    inline ::std::string* AnswerPic::release_f_unread_count() {
        clear_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_unread_count_;
            f_unread_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerPic::set_allocated_f_unread_count(::std::string* f_unread_count) {
        if (f_unread_count_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_unread_count_;
        }
        if (f_unread_count) {
            set_has_f_unread_count();
            f_unread_count_ = f_unread_count;
        } else {
            clear_has_f_unread_count();
            f_unread_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerPic.f_unread_count)
    }
    
    // required string device_udid = 11;
    inline bool AnswerPic::has_device_udid() const {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void AnswerPic::set_has_device_udid() {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void AnswerPic::clear_has_device_udid() {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void AnswerPic::clear_device_udid() {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_->clear();
        }
        clear_has_device_udid();
    }
    inline const ::std::string& AnswerPic::device_udid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerPic.device_udid)
        return *device_udid_;
    }
    inline void AnswerPic::set_device_udid(const ::std::string& value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerPic.device_udid)
    }
    inline void AnswerPic::set_device_udid(const char* value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerPic.device_udid)
    }
    inline void AnswerPic::set_device_udid(const char* value, size_t size) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerPic.device_udid)
    }
    inline ::std::string* AnswerPic::mutable_device_udid() {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerPic.device_udid)
        return device_udid_;
    }
    inline ::std::string* AnswerPic::release_device_udid() {
        clear_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_udid_;
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerPic::set_allocated_device_udid(::std::string* device_udid) {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_udid_;
        }
        if (device_udid) {
            set_has_device_udid();
            device_udid_ = device_udid;
        } else {
            clear_has_device_udid();
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerPic.device_udid)
    }
    
    // -------------------------------------------------------------------
    
    // AnswerVideo
    
    // required string result = 1;
    inline bool AnswerVideo::has_result() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void AnswerVideo::set_has_result() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void AnswerVideo::clear_has_result() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void AnswerVideo::clear_result() {
        if (result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_->clear();
        }
        clear_has_result();
    }
    inline const ::std::string& AnswerVideo::result() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerVideo.result)
        return *result_;
    }
    inline void AnswerVideo::set_result(const ::std::string& value) {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        result_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerVideo.result)
    }
    inline void AnswerVideo::set_result(const char* value) {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        result_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerVideo.result)
    }
    inline void AnswerVideo::set_result(const char* value, size_t size) {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        result_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerVideo.result)
    }
    inline ::std::string* AnswerVideo::mutable_result() {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerVideo.result)
        return result_;
    }
    inline ::std::string* AnswerVideo::release_result() {
        clear_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = result_;
            result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerVideo::set_allocated_result(::std::string* result) {
        if (result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete result_;
        }
        if (result) {
            set_has_result();
            result_ = result;
        } else {
            clear_has_result();
            result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerVideo.result)
    }
    
    // required bytes video = 2;
    inline bool AnswerVideo::has_video() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void AnswerVideo::set_has_video() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void AnswerVideo::clear_has_video() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void AnswerVideo::clear_video() {
        if (video_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            video_->clear();
        }
        clear_has_video();
    }
    inline const ::std::string& AnswerVideo::video() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerVideo.video)
        return *video_;
    }
    inline void AnswerVideo::set_video(const ::std::string& value) {
        set_has_video();
        if (video_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            video_ = new ::std::string;
        }
        video_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerVideo.video)
    }
    inline void AnswerVideo::set_video(const char* value) {
        set_has_video();
        if (video_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            video_ = new ::std::string;
        }
        video_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerVideo.video)
    }
    inline void AnswerVideo::set_video(const void* value, size_t size) {
        set_has_video();
        if (video_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            video_ = new ::std::string;
        }
        video_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerVideo.video)
    }
    inline ::std::string* AnswerVideo::mutable_video() {
        set_has_video();
        if (video_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            video_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerVideo.video)
        return video_;
    }
    inline ::std::string* AnswerVideo::release_video() {
        clear_has_video();
        if (video_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = video_;
            video_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerVideo::set_allocated_video(::std::string* video) {
        if (video_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete video_;
        }
        if (video) {
            set_has_video();
            video_ = video;
        } else {
            clear_has_video();
            video_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerVideo.video)
    }
    
    // required string msg_id = 3;
    inline bool AnswerVideo::has_msg_id() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void AnswerVideo::set_has_msg_id() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void AnswerVideo::clear_has_msg_id() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void AnswerVideo::clear_msg_id() {
        if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_->clear();
        }
        clear_has_msg_id();
    }
    inline const ::std::string& AnswerVideo::msg_id() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerVideo.msg_id)
        return *msg_id_;
    }
    inline void AnswerVideo::set_msg_id(const ::std::string& value) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerVideo.msg_id)
    }
    inline void AnswerVideo::set_msg_id(const char* value) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerVideo.msg_id)
    }
    inline void AnswerVideo::set_msg_id(const char* value, size_t size) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerVideo.msg_id)
    }
    inline ::std::string* AnswerVideo::mutable_msg_id() {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerVideo.msg_id)
        return msg_id_;
    }
    inline ::std::string* AnswerVideo::release_msg_id() {
        clear_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = msg_id_;
            msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerVideo::set_allocated_msg_id(::std::string* msg_id) {
        if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete msg_id_;
        }
        if (msg_id) {
            set_has_msg_id();
            msg_id_ = msg_id;
        } else {
            clear_has_msg_id();
            msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerVideo.msg_id)
    }
    
    // required string time_stamp = 4;
    inline bool AnswerVideo::has_time_stamp() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void AnswerVideo::set_has_time_stamp() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void AnswerVideo::clear_has_time_stamp() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void AnswerVideo::clear_time_stamp() {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_->clear();
        }
        clear_has_time_stamp();
    }
    inline const ::std::string& AnswerVideo::time_stamp() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerVideo.time_stamp)
        return *time_stamp_;
    }
    inline void AnswerVideo::set_time_stamp(const ::std::string& value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerVideo.time_stamp)
    }
    inline void AnswerVideo::set_time_stamp(const char* value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerVideo.time_stamp)
    }
    inline void AnswerVideo::set_time_stamp(const char* value, size_t size) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerVideo.time_stamp)
    }
    inline ::std::string* AnswerVideo::mutable_time_stamp() {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerVideo.time_stamp)
        return time_stamp_;
    }
    inline ::std::string* AnswerVideo::release_time_stamp() {
        clear_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = time_stamp_;
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerVideo::set_allocated_time_stamp(::std::string* time_stamp) {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete time_stamp_;
        }
        if (time_stamp) {
            set_has_time_stamp();
            time_stamp_ = time_stamp;
        } else {
            clear_has_time_stamp();
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerVideo.time_stamp)
    }
    
    // required int64 fid = 5;
    inline bool AnswerVideo::has_fid() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void AnswerVideo::set_has_fid() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void AnswerVideo::clear_has_fid() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void AnswerVideo::clear_fid() {
        fid_ = GOOGLE_LONGLONG(0);
        clear_has_fid();
    }
    inline ::google::protobuf::int64 AnswerVideo::fid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerVideo.fid)
        return fid_;
    }
    inline void AnswerVideo::set_fid(::google::protobuf::int64 value) {
        set_has_fid();
        fid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.AnswerVideo.fid)
    }
    
    // required string f_avatar = 6;
    inline bool AnswerVideo::has_f_avatar() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void AnswerVideo::set_has_f_avatar() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void AnswerVideo::clear_has_f_avatar() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void AnswerVideo::clear_f_avatar() {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_->clear();
        }
        clear_has_f_avatar();
    }
    inline const ::std::string& AnswerVideo::f_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerVideo.f_avatar)
        return *f_avatar_;
    }
    inline void AnswerVideo::set_f_avatar(const ::std::string& value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerVideo.f_avatar)
    }
    inline void AnswerVideo::set_f_avatar(const char* value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerVideo.f_avatar)
    }
    inline void AnswerVideo::set_f_avatar(const char* value, size_t size) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerVideo.f_avatar)
    }
    inline ::std::string* AnswerVideo::mutable_f_avatar() {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerVideo.f_avatar)
        return f_avatar_;
    }
    inline ::std::string* AnswerVideo::release_f_avatar() {
        clear_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_avatar_;
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerVideo::set_allocated_f_avatar(::std::string* f_avatar) {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_avatar_;
        }
        if (f_avatar) {
            set_has_f_avatar();
            f_avatar_ = f_avatar;
        } else {
            clear_has_f_avatar();
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerVideo.f_avatar)
    }
    
    // required string f_name = 7;
    inline bool AnswerVideo::has_f_name() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void AnswerVideo::set_has_f_name() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void AnswerVideo::clear_has_f_name() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void AnswerVideo::clear_f_name() {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_->clear();
        }
        clear_has_f_name();
    }
    inline const ::std::string& AnswerVideo::f_name() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerVideo.f_name)
        return *f_name_;
    }
    inline void AnswerVideo::set_f_name(const ::std::string& value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerVideo.f_name)
    }
    inline void AnswerVideo::set_f_name(const char* value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerVideo.f_name)
    }
    inline void AnswerVideo::set_f_name(const char* value, size_t size) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerVideo.f_name)
    }
    inline ::std::string* AnswerVideo::mutable_f_name() {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerVideo.f_name)
        return f_name_;
    }
    inline ::std::string* AnswerVideo::release_f_name() {
        clear_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_name_;
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerVideo::set_allocated_f_name(::std::string* f_name) {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_name_;
        }
        if (f_name) {
            set_has_f_name();
            f_name_ = f_name;
        } else {
            clear_has_f_name();
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerVideo.f_name)
    }
    
    // required string f_leve = 8;
    inline bool AnswerVideo::has_f_leve() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void AnswerVideo::set_has_f_leve() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void AnswerVideo::clear_has_f_leve() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void AnswerVideo::clear_f_leve() {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_->clear();
        }
        clear_has_f_leve();
    }
    inline const ::std::string& AnswerVideo::f_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerVideo.f_leve)
        return *f_leve_;
    }
    inline void AnswerVideo::set_f_leve(const ::std::string& value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerVideo.f_leve)
    }
    inline void AnswerVideo::set_f_leve(const char* value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerVideo.f_leve)
    }
    inline void AnswerVideo::set_f_leve(const char* value, size_t size) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerVideo.f_leve)
    }
    inline ::std::string* AnswerVideo::mutable_f_leve() {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerVideo.f_leve)
        return f_leve_;
    }
    inline ::std::string* AnswerVideo::release_f_leve() {
        clear_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_leve_;
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerVideo::set_allocated_f_leve(::std::string* f_leve) {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_leve_;
        }
        if (f_leve) {
            set_has_f_leve();
            f_leve_ = f_leve;
        } else {
            clear_has_f_leve();
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerVideo.f_leve)
    }
    
    // required string f_user_type = 9;
    inline bool AnswerVideo::has_f_user_type() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void AnswerVideo::set_has_f_user_type() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void AnswerVideo::clear_has_f_user_type() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void AnswerVideo::clear_f_user_type() {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_->clear();
        }
        clear_has_f_user_type();
    }
    inline const ::std::string& AnswerVideo::f_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerVideo.f_user_type)
        return *f_user_type_;
    }
    inline void AnswerVideo::set_f_user_type(const ::std::string& value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerVideo.f_user_type)
    }
    inline void AnswerVideo::set_f_user_type(const char* value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerVideo.f_user_type)
    }
    inline void AnswerVideo::set_f_user_type(const char* value, size_t size) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerVideo.f_user_type)
    }
    inline ::std::string* AnswerVideo::mutable_f_user_type() {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerVideo.f_user_type)
        return f_user_type_;
    }
    inline ::std::string* AnswerVideo::release_f_user_type() {
        clear_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_user_type_;
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerVideo::set_allocated_f_user_type(::std::string* f_user_type) {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_user_type_;
        }
        if (f_user_type) {
            set_has_f_user_type();
            f_user_type_ = f_user_type;
        } else {
            clear_has_f_user_type();
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerVideo.f_user_type)
    }
    
    // required string f_unread_count = 10;
    inline bool AnswerVideo::has_f_unread_count() const {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void AnswerVideo::set_has_f_unread_count() {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void AnswerVideo::clear_has_f_unread_count() {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void AnswerVideo::clear_f_unread_count() {
        if (f_unread_count_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_->clear();
        }
        clear_has_f_unread_count();
    }
    inline const ::std::string& AnswerVideo::f_unread_count() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerVideo.f_unread_count)
        return *f_unread_count_;
    }
    inline void AnswerVideo::set_f_unread_count(const ::std::string& value) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerVideo.f_unread_count)
    }
    inline void AnswerVideo::set_f_unread_count(const char* value) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerVideo.f_unread_count)
    }
    inline void AnswerVideo::set_f_unread_count(const char* value, size_t size) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerVideo.f_unread_count)
    }
    inline ::std::string* AnswerVideo::mutable_f_unread_count() {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerVideo.f_unread_count)
        return f_unread_count_;
    }
    inline ::std::string* AnswerVideo::release_f_unread_count() {
        clear_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_unread_count_;
            f_unread_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerVideo::set_allocated_f_unread_count(::std::string* f_unread_count) {
        if (f_unread_count_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_unread_count_;
        }
        if (f_unread_count) {
            set_has_f_unread_count();
            f_unread_count_ = f_unread_count;
        } else {
            clear_has_f_unread_count();
            f_unread_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerVideo.f_unread_count)
    }
    
    // required string device_udid = 11;
    inline bool AnswerVideo::has_device_udid() const {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void AnswerVideo::set_has_device_udid() {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void AnswerVideo::clear_has_device_udid() {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void AnswerVideo::clear_device_udid() {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_->clear();
        }
        clear_has_device_udid();
    }
    inline const ::std::string& AnswerVideo::device_udid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerVideo.device_udid)
        return *device_udid_;
    }
    inline void AnswerVideo::set_device_udid(const ::std::string& value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerVideo.device_udid)
    }
    inline void AnswerVideo::set_device_udid(const char* value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerVideo.device_udid)
    }
    inline void AnswerVideo::set_device_udid(const char* value, size_t size) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerVideo.device_udid)
    }
    inline ::std::string* AnswerVideo::mutable_device_udid() {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerVideo.device_udid)
        return device_udid_;
    }
    inline ::std::string* AnswerVideo::release_device_udid() {
        clear_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_udid_;
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerVideo::set_allocated_device_udid(::std::string* device_udid) {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_udid_;
        }
        if (device_udid) {
            set_has_device_udid();
            device_udid_ = device_udid;
        } else {
            clear_has_device_udid();
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerVideo.device_udid)
    }
    
    // -------------------------------------------------------------------
    
    // AnswerRecommendHouse
    
    // required string result = 1;
    inline bool AnswerRecommendHouse::has_result() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_result() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void AnswerRecommendHouse::clear_has_result() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void AnswerRecommendHouse::clear_result() {
        if (result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_->clear();
        }
        clear_has_result();
    }
    inline const ::std::string& AnswerRecommendHouse::result() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.result)
        return *result_;
    }
    inline void AnswerRecommendHouse::set_result(const ::std::string& value) {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        result_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.result)
    }
    inline void AnswerRecommendHouse::set_result(const char* value) {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        result_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.result)
    }
    inline void AnswerRecommendHouse::set_result(const char* value, size_t size) {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        result_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.result)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_result() {
        set_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            result_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.result)
        return result_;
    }
    inline ::std::string* AnswerRecommendHouse::release_result() {
        clear_has_result();
        if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = result_;
            result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_result(::std::string* result) {
        if (result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete result_;
        }
        if (result) {
            set_has_result();
            result_ = result;
        } else {
            clear_has_result();
            result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.result)
    }
    
    // required string msg_id = 2;
    inline bool AnswerRecommendHouse::has_msg_id() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_msg_id() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void AnswerRecommendHouse::clear_has_msg_id() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void AnswerRecommendHouse::clear_msg_id() {
        if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_->clear();
        }
        clear_has_msg_id();
    }
    inline const ::std::string& AnswerRecommendHouse::msg_id() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.msg_id)
        return *msg_id_;
    }
    inline void AnswerRecommendHouse::set_msg_id(const ::std::string& value) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.msg_id)
    }
    inline void AnswerRecommendHouse::set_msg_id(const char* value) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.msg_id)
    }
    inline void AnswerRecommendHouse::set_msg_id(const char* value, size_t size) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.msg_id)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_msg_id() {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.msg_id)
        return msg_id_;
    }
    inline ::std::string* AnswerRecommendHouse::release_msg_id() {
        clear_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = msg_id_;
            msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_msg_id(::std::string* msg_id) {
        if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete msg_id_;
        }
        if (msg_id) {
            set_has_msg_id();
            msg_id_ = msg_id;
        } else {
            clear_has_msg_id();
            msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.msg_id)
    }
    
    // required string house_id = 3;
    inline bool AnswerRecommendHouse::has_house_id() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_house_id() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void AnswerRecommendHouse::clear_has_house_id() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void AnswerRecommendHouse::clear_house_id() {
        if (house_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_->clear();
        }
        clear_has_house_id();
    }
    inline const ::std::string& AnswerRecommendHouse::house_id() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.house_id)
        return *house_id_;
    }
    inline void AnswerRecommendHouse::set_house_id(const ::std::string& value) {
        set_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_ = new ::std::string;
        }
        house_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.house_id)
    }
    inline void AnswerRecommendHouse::set_house_id(const char* value) {
        set_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_ = new ::std::string;
        }
        house_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.house_id)
    }
    inline void AnswerRecommendHouse::set_house_id(const char* value, size_t size) {
        set_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_ = new ::std::string;
        }
        house_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.house_id)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_house_id() {
        set_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.house_id)
        return house_id_;
    }
    inline ::std::string* AnswerRecommendHouse::release_house_id() {
        clear_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_id_;
            house_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_house_id(::std::string* house_id) {
        if (house_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_id_;
        }
        if (house_id) {
            set_has_house_id();
            house_id_ = house_id;
        } else {
            clear_has_house_id();
            house_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.house_id)
    }
    
    // optional string building_id = 4;
    inline bool AnswerRecommendHouse::has_building_id() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_building_id() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void AnswerRecommendHouse::clear_has_building_id() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void AnswerRecommendHouse::clear_building_id() {
        if (building_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_->clear();
        }
        clear_has_building_id();
    }
    inline const ::std::string& AnswerRecommendHouse::building_id() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.building_id)
        return *building_id_;
    }
    inline void AnswerRecommendHouse::set_building_id(const ::std::string& value) {
        set_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_ = new ::std::string;
        }
        building_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.building_id)
    }
    inline void AnswerRecommendHouse::set_building_id(const char* value) {
        set_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_ = new ::std::string;
        }
        building_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.building_id)
    }
    inline void AnswerRecommendHouse::set_building_id(const char* value, size_t size) {
        set_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_ = new ::std::string;
        }
        building_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.building_id)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_building_id() {
        set_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.building_id)
        return building_id_;
    }
    inline ::std::string* AnswerRecommendHouse::release_building_id() {
        clear_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = building_id_;
            building_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_building_id(::std::string* building_id) {
        if (building_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete building_id_;
        }
        if (building_id) {
            set_has_building_id();
            building_id_ = building_id;
        } else {
            clear_has_building_id();
            building_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.building_id)
    }
    
    // required string house_type = 5;
    inline bool AnswerRecommendHouse::has_house_type() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_house_type() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void AnswerRecommendHouse::clear_has_house_type() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void AnswerRecommendHouse::clear_house_type() {
        if (house_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_->clear();
        }
        clear_has_house_type();
    }
    inline const ::std::string& AnswerRecommendHouse::house_type() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.house_type)
        return *house_type_;
    }
    inline void AnswerRecommendHouse::set_house_type(const ::std::string& value) {
        set_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_ = new ::std::string;
        }
        house_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.house_type)
    }
    inline void AnswerRecommendHouse::set_house_type(const char* value) {
        set_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_ = new ::std::string;
        }
        house_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.house_type)
    }
    inline void AnswerRecommendHouse::set_house_type(const char* value, size_t size) {
        set_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_ = new ::std::string;
        }
        house_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.house_type)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_house_type() {
        set_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.house_type)
        return house_type_;
    }
    inline ::std::string* AnswerRecommendHouse::release_house_type() {
        clear_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_type_;
            house_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_house_type(::std::string* house_type) {
        if (house_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_type_;
        }
        if (house_type) {
            set_has_house_type();
            house_type_ = house_type;
        } else {
            clear_has_house_type();
            house_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.house_type)
    }
    
    // required string attach_file = 6;
    inline bool AnswerRecommendHouse::has_attach_file() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_attach_file() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void AnswerRecommendHouse::clear_has_attach_file() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void AnswerRecommendHouse::clear_attach_file() {
        if (attach_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_->clear();
        }
        clear_has_attach_file();
    }
    inline const ::std::string& AnswerRecommendHouse::attach_file() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.attach_file)
        return *attach_file_;
    }
    inline void AnswerRecommendHouse::set_attach_file(const ::std::string& value) {
        set_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_ = new ::std::string;
        }
        attach_file_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.attach_file)
    }
    inline void AnswerRecommendHouse::set_attach_file(const char* value) {
        set_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_ = new ::std::string;
        }
        attach_file_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.attach_file)
    }
    inline void AnswerRecommendHouse::set_attach_file(const char* value, size_t size) {
        set_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_ = new ::std::string;
        }
        attach_file_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.attach_file)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_attach_file() {
        set_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.attach_file)
        return attach_file_;
    }
    inline ::std::string* AnswerRecommendHouse::release_attach_file() {
        clear_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = attach_file_;
            attach_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_attach_file(::std::string* attach_file) {
        if (attach_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete attach_file_;
        }
        if (attach_file) {
            set_has_attach_file();
            attach_file_ = attach_file;
        } else {
            clear_has_attach_file();
            attach_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.attach_file)
    }
    
    // required string attach_thumb = 7;
    inline bool AnswerRecommendHouse::has_attach_thumb() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_attach_thumb() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void AnswerRecommendHouse::clear_has_attach_thumb() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void AnswerRecommendHouse::clear_attach_thumb() {
        if (attach_thumb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_->clear();
        }
        clear_has_attach_thumb();
    }
    inline const ::std::string& AnswerRecommendHouse::attach_thumb() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.attach_thumb)
        return *attach_thumb_;
    }
    inline void AnswerRecommendHouse::set_attach_thumb(const ::std::string& value) {
        set_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_ = new ::std::string;
        }
        attach_thumb_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.attach_thumb)
    }
    inline void AnswerRecommendHouse::set_attach_thumb(const char* value) {
        set_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_ = new ::std::string;
        }
        attach_thumb_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.attach_thumb)
    }
    inline void AnswerRecommendHouse::set_attach_thumb(const char* value, size_t size) {
        set_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_ = new ::std::string;
        }
        attach_thumb_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.attach_thumb)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_attach_thumb() {
        set_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.attach_thumb)
        return attach_thumb_;
    }
    inline ::std::string* AnswerRecommendHouse::release_attach_thumb() {
        clear_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = attach_thumb_;
            attach_thumb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_attach_thumb(::std::string* attach_thumb) {
        if (attach_thumb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete attach_thumb_;
        }
        if (attach_thumb) {
            set_has_attach_thumb();
            attach_thumb_ = attach_thumb;
        } else {
            clear_has_attach_thumb();
            attach_thumb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.attach_thumb)
    }
    
    // required string areaid = 8;
    inline bool AnswerRecommendHouse::has_areaid() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_areaid() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void AnswerRecommendHouse::clear_has_areaid() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void AnswerRecommendHouse::clear_areaid() {
        if (areaid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_->clear();
        }
        clear_has_areaid();
    }
    inline const ::std::string& AnswerRecommendHouse::areaid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.areaid)
        return *areaid_;
    }
    inline void AnswerRecommendHouse::set_areaid(const ::std::string& value) {
        set_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_ = new ::std::string;
        }
        areaid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.areaid)
    }
    inline void AnswerRecommendHouse::set_areaid(const char* value) {
        set_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_ = new ::std::string;
        }
        areaid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.areaid)
    }
    inline void AnswerRecommendHouse::set_areaid(const char* value, size_t size) {
        set_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_ = new ::std::string;
        }
        areaid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.areaid)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_areaid() {
        set_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.areaid)
        return areaid_;
    }
    inline ::std::string* AnswerRecommendHouse::release_areaid() {
        clear_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = areaid_;
            areaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_areaid(::std::string* areaid) {
        if (areaid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete areaid_;
        }
        if (areaid) {
            set_has_areaid();
            areaid_ = areaid;
        } else {
            clear_has_areaid();
            areaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.areaid)
    }
    
    // required string area_val = 9;
    inline bool AnswerRecommendHouse::has_area_val() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_area_val() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void AnswerRecommendHouse::clear_has_area_val() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void AnswerRecommendHouse::clear_area_val() {
        if (area_val_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_->clear();
        }
        clear_has_area_val();
    }
    inline const ::std::string& AnswerRecommendHouse::area_val() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.area_val)
        return *area_val_;
    }
    inline void AnswerRecommendHouse::set_area_val(const ::std::string& value) {
        set_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_ = new ::std::string;
        }
        area_val_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.area_val)
    }
    inline void AnswerRecommendHouse::set_area_val(const char* value) {
        set_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_ = new ::std::string;
        }
        area_val_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.area_val)
    }
    inline void AnswerRecommendHouse::set_area_val(const char* value, size_t size) {
        set_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_ = new ::std::string;
        }
        area_val_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.area_val)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_area_val() {
        set_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.area_val)
        return area_val_;
    }
    inline ::std::string* AnswerRecommendHouse::release_area_val() {
        clear_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = area_val_;
            area_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_area_val(::std::string* area_val) {
        if (area_val_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete area_val_;
        }
        if (area_val) {
            set_has_area_val();
            area_val_ = area_val;
        } else {
            clear_has_area_val();
            area_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.area_val)
    }
    
    // required string streetid = 10;
    inline bool AnswerRecommendHouse::has_streetid() const {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_streetid() {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void AnswerRecommendHouse::clear_has_streetid() {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void AnswerRecommendHouse::clear_streetid() {
        if (streetid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_->clear();
        }
        clear_has_streetid();
    }
    inline const ::std::string& AnswerRecommendHouse::streetid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.streetid)
        return *streetid_;
    }
    inline void AnswerRecommendHouse::set_streetid(const ::std::string& value) {
        set_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_ = new ::std::string;
        }
        streetid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.streetid)
    }
    inline void AnswerRecommendHouse::set_streetid(const char* value) {
        set_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_ = new ::std::string;
        }
        streetid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.streetid)
    }
    inline void AnswerRecommendHouse::set_streetid(const char* value, size_t size) {
        set_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_ = new ::std::string;
        }
        streetid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.streetid)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_streetid() {
        set_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.streetid)
        return streetid_;
    }
    inline ::std::string* AnswerRecommendHouse::release_streetid() {
        clear_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = streetid_;
            streetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_streetid(::std::string* streetid) {
        if (streetid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete streetid_;
        }
        if (streetid) {
            set_has_streetid();
            streetid_ = streetid;
        } else {
            clear_has_streetid();
            streetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.streetid)
    }
    
    // required string street_val = 11;
    inline bool AnswerRecommendHouse::has_street_val() const {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_street_val() {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void AnswerRecommendHouse::clear_has_street_val() {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void AnswerRecommendHouse::clear_street_val() {
        if (street_val_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_->clear();
        }
        clear_has_street_val();
    }
    inline const ::std::string& AnswerRecommendHouse::street_val() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.street_val)
        return *street_val_;
    }
    inline void AnswerRecommendHouse::set_street_val(const ::std::string& value) {
        set_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_ = new ::std::string;
        }
        street_val_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.street_val)
    }
    inline void AnswerRecommendHouse::set_street_val(const char* value) {
        set_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_ = new ::std::string;
        }
        street_val_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.street_val)
    }
    inline void AnswerRecommendHouse::set_street_val(const char* value, size_t size) {
        set_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_ = new ::std::string;
        }
        street_val_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.street_val)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_street_val() {
        set_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.street_val)
        return street_val_;
    }
    inline ::std::string* AnswerRecommendHouse::release_street_val() {
        clear_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = street_val_;
            street_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_street_val(::std::string* street_val) {
        if (street_val_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete street_val_;
        }
        if (street_val) {
            set_has_street_val();
            street_val_ = street_val;
        } else {
            clear_has_street_val();
            street_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.street_val)
    }
    
    // required string house_shi = 12;
    inline bool AnswerRecommendHouse::has_house_shi() const {
        return (_has_bits_[0] & 0x00000800u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_house_shi() {
        _has_bits_[0] |= 0x00000800u;
    }
    inline void AnswerRecommendHouse::clear_has_house_shi() {
        _has_bits_[0] &= ~0x00000800u;
    }
    inline void AnswerRecommendHouse::clear_house_shi() {
        if (house_shi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_->clear();
        }
        clear_has_house_shi();
    }
    inline const ::std::string& AnswerRecommendHouse::house_shi() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.house_shi)
        return *house_shi_;
    }
    inline void AnswerRecommendHouse::set_house_shi(const ::std::string& value) {
        set_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_ = new ::std::string;
        }
        house_shi_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.house_shi)
    }
    inline void AnswerRecommendHouse::set_house_shi(const char* value) {
        set_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_ = new ::std::string;
        }
        house_shi_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.house_shi)
    }
    inline void AnswerRecommendHouse::set_house_shi(const char* value, size_t size) {
        set_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_ = new ::std::string;
        }
        house_shi_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.house_shi)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_house_shi() {
        set_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.house_shi)
        return house_shi_;
    }
    inline ::std::string* AnswerRecommendHouse::release_house_shi() {
        clear_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_shi_;
            house_shi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_house_shi(::std::string* house_shi) {
        if (house_shi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_shi_;
        }
        if (house_shi) {
            set_has_house_shi();
            house_shi_ = house_shi;
        } else {
            clear_has_house_shi();
            house_shi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.house_shi)
    }
    
    // required string house_ting = 13;
    inline bool AnswerRecommendHouse::has_house_ting() const {
        return (_has_bits_[0] & 0x00001000u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_house_ting() {
        _has_bits_[0] |= 0x00001000u;
    }
    inline void AnswerRecommendHouse::clear_has_house_ting() {
        _has_bits_[0] &= ~0x00001000u;
    }
    inline void AnswerRecommendHouse::clear_house_ting() {
        if (house_ting_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_->clear();
        }
        clear_has_house_ting();
    }
    inline const ::std::string& AnswerRecommendHouse::house_ting() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.house_ting)
        return *house_ting_;
    }
    inline void AnswerRecommendHouse::set_house_ting(const ::std::string& value) {
        set_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_ = new ::std::string;
        }
        house_ting_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.house_ting)
    }
    inline void AnswerRecommendHouse::set_house_ting(const char* value) {
        set_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_ = new ::std::string;
        }
        house_ting_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.house_ting)
    }
    inline void AnswerRecommendHouse::set_house_ting(const char* value, size_t size) {
        set_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_ = new ::std::string;
        }
        house_ting_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.house_ting)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_house_ting() {
        set_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.house_ting)
        return house_ting_;
    }
    inline ::std::string* AnswerRecommendHouse::release_house_ting() {
        clear_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_ting_;
            house_ting_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_house_ting(::std::string* house_ting) {
        if (house_ting_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_ting_;
        }
        if (house_ting) {
            set_has_house_ting();
            house_ting_ = house_ting;
        } else {
            clear_has_house_ting();
            house_ting_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.house_ting)
    }
    
    // required string house_area = 14;
    inline bool AnswerRecommendHouse::has_house_area() const {
        return (_has_bits_[0] & 0x00002000u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_house_area() {
        _has_bits_[0] |= 0x00002000u;
    }
    inline void AnswerRecommendHouse::clear_has_house_area() {
        _has_bits_[0] &= ~0x00002000u;
    }
    inline void AnswerRecommendHouse::clear_house_area() {
        if (house_area_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_->clear();
        }
        clear_has_house_area();
    }
    inline const ::std::string& AnswerRecommendHouse::house_area() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.house_area)
        return *house_area_;
    }
    inline void AnswerRecommendHouse::set_house_area(const ::std::string& value) {
        set_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_ = new ::std::string;
        }
        house_area_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.house_area)
    }
    inline void AnswerRecommendHouse::set_house_area(const char* value) {
        set_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_ = new ::std::string;
        }
        house_area_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.house_area)
    }
    inline void AnswerRecommendHouse::set_house_area(const char* value, size_t size) {
        set_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_ = new ::std::string;
        }
        house_area_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.house_area)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_house_area() {
        set_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.house_area)
        return house_area_;
    }
    inline ::std::string* AnswerRecommendHouse::release_house_area() {
        clear_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_area_;
            house_area_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_house_area(::std::string* house_area) {
        if (house_area_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_area_;
        }
        if (house_area) {
            set_has_house_area();
            house_area_ = house_area;
        } else {
            clear_has_house_area();
            house_area_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.house_area)
    }
    
    // optional string house_price = 15;
    inline bool AnswerRecommendHouse::has_house_price() const {
        return (_has_bits_[0] & 0x00004000u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_house_price() {
        _has_bits_[0] |= 0x00004000u;
    }
    inline void AnswerRecommendHouse::clear_has_house_price() {
        _has_bits_[0] &= ~0x00004000u;
    }
    inline void AnswerRecommendHouse::clear_house_price() {
        if (house_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_->clear();
        }
        clear_has_house_price();
    }
    inline const ::std::string& AnswerRecommendHouse::house_price() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.house_price)
        return *house_price_;
    }
    inline void AnswerRecommendHouse::set_house_price(const ::std::string& value) {
        set_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_ = new ::std::string;
        }
        house_price_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.house_price)
    }
    inline void AnswerRecommendHouse::set_house_price(const char* value) {
        set_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_ = new ::std::string;
        }
        house_price_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.house_price)
    }
    inline void AnswerRecommendHouse::set_house_price(const char* value, size_t size) {
        set_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_ = new ::std::string;
        }
        house_price_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.house_price)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_house_price() {
        set_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.house_price)
        return house_price_;
    }
    inline ::std::string* AnswerRecommendHouse::release_house_price() {
        clear_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_price_;
            house_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_house_price(::std::string* house_price) {
        if (house_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_price_;
        }
        if (house_price) {
            set_has_house_price();
            house_price_ = house_price;
        } else {
            clear_has_house_price();
            house_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.house_price)
    }
    
    // optional string rent_price = 16;
    inline bool AnswerRecommendHouse::has_rent_price() const {
        return (_has_bits_[0] & 0x00008000u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_rent_price() {
        _has_bits_[0] |= 0x00008000u;
    }
    inline void AnswerRecommendHouse::clear_has_rent_price() {
        _has_bits_[0] &= ~0x00008000u;
    }
    inline void AnswerRecommendHouse::clear_rent_price() {
        if (rent_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_->clear();
        }
        clear_has_rent_price();
    }
    inline const ::std::string& AnswerRecommendHouse::rent_price() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.rent_price)
        return *rent_price_;
    }
    inline void AnswerRecommendHouse::set_rent_price(const ::std::string& value) {
        set_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_ = new ::std::string;
        }
        rent_price_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.rent_price)
    }
    inline void AnswerRecommendHouse::set_rent_price(const char* value) {
        set_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_ = new ::std::string;
        }
        rent_price_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.rent_price)
    }
    inline void AnswerRecommendHouse::set_rent_price(const char* value, size_t size) {
        set_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_ = new ::std::string;
        }
        rent_price_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.rent_price)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_rent_price() {
        set_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.rent_price)
        return rent_price_;
    }
    inline ::std::string* AnswerRecommendHouse::release_rent_price() {
        clear_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = rent_price_;
            rent_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_rent_price(::std::string* rent_price) {
        if (rent_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete rent_price_;
        }
        if (rent_price) {
            set_has_rent_price();
            rent_price_ = rent_price;
        } else {
            clear_has_rent_price();
            rent_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.rent_price)
    }
    
    // required string title_ = 17;
    inline bool AnswerRecommendHouse::has_title_() const {
        return (_has_bits_[0] & 0x00010000u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_title_() {
        _has_bits_[0] |= 0x00010000u;
    }
    inline void AnswerRecommendHouse::clear_has_title_() {
        _has_bits_[0] &= ~0x00010000u;
    }
    inline void AnswerRecommendHouse::clear_title_() {
        if (title__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title__->clear();
        }
        clear_has_title_();
    }
    inline const ::std::string& AnswerRecommendHouse::title_() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.title_)
        return *title__;
    }
    inline void AnswerRecommendHouse::set_title_(const ::std::string& value) {
        set_has_title_();
        if (title__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title__ = new ::std::string;
        }
        title__->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.title_)
    }
    inline void AnswerRecommendHouse::set_title_(const char* value) {
        set_has_title_();
        if (title__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title__ = new ::std::string;
        }
        title__->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.title_)
    }
    inline void AnswerRecommendHouse::set_title_(const char* value, size_t size) {
        set_has_title_();
        if (title__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title__ = new ::std::string;
        }
        title__->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.title_)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_title_() {
        set_has_title_();
        if (title__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title__ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.title_)
        return title__;
    }
    inline ::std::string* AnswerRecommendHouse::release_title_() {
        clear_has_title_();
        if (title__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = title__;
            title__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_title_(::std::string* title_) {
        if (title__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete title__;
        }
        if (title_) {
            set_has_title_();
            title__ = title_;
        } else {
            clear_has_title_();
            title__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.title_)
    }
    
    // required int64 fid = 18;
    inline bool AnswerRecommendHouse::has_fid() const {
        return (_has_bits_[0] & 0x00020000u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_fid() {
        _has_bits_[0] |= 0x00020000u;
    }
    inline void AnswerRecommendHouse::clear_has_fid() {
        _has_bits_[0] &= ~0x00020000u;
    }
    inline void AnswerRecommendHouse::clear_fid() {
        fid_ = GOOGLE_LONGLONG(0);
        clear_has_fid();
    }
    inline ::google::protobuf::int64 AnswerRecommendHouse::fid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.fid)
        return fid_;
    }
    inline void AnswerRecommendHouse::set_fid(::google::protobuf::int64 value) {
        set_has_fid();
        fid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.fid)
    }
    
    // required string f_avatar = 19;
    inline bool AnswerRecommendHouse::has_f_avatar() const {
        return (_has_bits_[0] & 0x00040000u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_f_avatar() {
        _has_bits_[0] |= 0x00040000u;
    }
    inline void AnswerRecommendHouse::clear_has_f_avatar() {
        _has_bits_[0] &= ~0x00040000u;
    }
    inline void AnswerRecommendHouse::clear_f_avatar() {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_->clear();
        }
        clear_has_f_avatar();
    }
    inline const ::std::string& AnswerRecommendHouse::f_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.f_avatar)
        return *f_avatar_;
    }
    inline void AnswerRecommendHouse::set_f_avatar(const ::std::string& value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.f_avatar)
    }
    inline void AnswerRecommendHouse::set_f_avatar(const char* value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.f_avatar)
    }
    inline void AnswerRecommendHouse::set_f_avatar(const char* value, size_t size) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.f_avatar)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_f_avatar() {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.f_avatar)
        return f_avatar_;
    }
    inline ::std::string* AnswerRecommendHouse::release_f_avatar() {
        clear_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_avatar_;
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_f_avatar(::std::string* f_avatar) {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_avatar_;
        }
        if (f_avatar) {
            set_has_f_avatar();
            f_avatar_ = f_avatar;
        } else {
            clear_has_f_avatar();
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.f_avatar)
    }
    
    // required string f_name = 20;
    inline bool AnswerRecommendHouse::has_f_name() const {
        return (_has_bits_[0] & 0x00080000u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_f_name() {
        _has_bits_[0] |= 0x00080000u;
    }
    inline void AnswerRecommendHouse::clear_has_f_name() {
        _has_bits_[0] &= ~0x00080000u;
    }
    inline void AnswerRecommendHouse::clear_f_name() {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_->clear();
        }
        clear_has_f_name();
    }
    inline const ::std::string& AnswerRecommendHouse::f_name() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.f_name)
        return *f_name_;
    }
    inline void AnswerRecommendHouse::set_f_name(const ::std::string& value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.f_name)
    }
    inline void AnswerRecommendHouse::set_f_name(const char* value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.f_name)
    }
    inline void AnswerRecommendHouse::set_f_name(const char* value, size_t size) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.f_name)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_f_name() {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.f_name)
        return f_name_;
    }
    inline ::std::string* AnswerRecommendHouse::release_f_name() {
        clear_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_name_;
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_f_name(::std::string* f_name) {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_name_;
        }
        if (f_name) {
            set_has_f_name();
            f_name_ = f_name;
        } else {
            clear_has_f_name();
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.f_name)
    }
    
    // required string f_leve = 21;
    inline bool AnswerRecommendHouse::has_f_leve() const {
        return (_has_bits_[0] & 0x00100000u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_f_leve() {
        _has_bits_[0] |= 0x00100000u;
    }
    inline void AnswerRecommendHouse::clear_has_f_leve() {
        _has_bits_[0] &= ~0x00100000u;
    }
    inline void AnswerRecommendHouse::clear_f_leve() {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_->clear();
        }
        clear_has_f_leve();
    }
    inline const ::std::string& AnswerRecommendHouse::f_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.f_leve)
        return *f_leve_;
    }
    inline void AnswerRecommendHouse::set_f_leve(const ::std::string& value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.f_leve)
    }
    inline void AnswerRecommendHouse::set_f_leve(const char* value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.f_leve)
    }
    inline void AnswerRecommendHouse::set_f_leve(const char* value, size_t size) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.f_leve)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_f_leve() {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.f_leve)
        return f_leve_;
    }
    inline ::std::string* AnswerRecommendHouse::release_f_leve() {
        clear_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_leve_;
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_f_leve(::std::string* f_leve) {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_leve_;
        }
        if (f_leve) {
            set_has_f_leve();
            f_leve_ = f_leve;
        } else {
            clear_has_f_leve();
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.f_leve)
    }
    
    // required string f_user_type = 22;
    inline bool AnswerRecommendHouse::has_f_user_type() const {
        return (_has_bits_[0] & 0x00200000u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_f_user_type() {
        _has_bits_[0] |= 0x00200000u;
    }
    inline void AnswerRecommendHouse::clear_has_f_user_type() {
        _has_bits_[0] &= ~0x00200000u;
    }
    inline void AnswerRecommendHouse::clear_f_user_type() {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_->clear();
        }
        clear_has_f_user_type();
    }
    inline const ::std::string& AnswerRecommendHouse::f_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.f_user_type)
        return *f_user_type_;
    }
    inline void AnswerRecommendHouse::set_f_user_type(const ::std::string& value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.f_user_type)
    }
    inline void AnswerRecommendHouse::set_f_user_type(const char* value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.f_user_type)
    }
    inline void AnswerRecommendHouse::set_f_user_type(const char* value, size_t size) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.f_user_type)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_f_user_type() {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.f_user_type)
        return f_user_type_;
    }
    inline ::std::string* AnswerRecommendHouse::release_f_user_type() {
        clear_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_user_type_;
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_f_user_type(::std::string* f_user_type) {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_user_type_;
        }
        if (f_user_type) {
            set_has_f_user_type();
            f_user_type_ = f_user_type;
        } else {
            clear_has_f_user_type();
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.f_user_type)
    }
    
    // required string f_unread_count = 23;
    inline bool AnswerRecommendHouse::has_f_unread_count() const {
        return (_has_bits_[0] & 0x00400000u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_f_unread_count() {
        _has_bits_[0] |= 0x00400000u;
    }
    inline void AnswerRecommendHouse::clear_has_f_unread_count() {
        _has_bits_[0] &= ~0x00400000u;
    }
    inline void AnswerRecommendHouse::clear_f_unread_count() {
        if (f_unread_count_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_->clear();
        }
        clear_has_f_unread_count();
    }
    inline const ::std::string& AnswerRecommendHouse::f_unread_count() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.f_unread_count)
        return *f_unread_count_;
    }
    inline void AnswerRecommendHouse::set_f_unread_count(const ::std::string& value) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.f_unread_count)
    }
    inline void AnswerRecommendHouse::set_f_unread_count(const char* value) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.f_unread_count)
    }
    inline void AnswerRecommendHouse::set_f_unread_count(const char* value, size_t size) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.f_unread_count)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_f_unread_count() {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.f_unread_count)
        return f_unread_count_;
    }
    inline ::std::string* AnswerRecommendHouse::release_f_unread_count() {
        clear_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_unread_count_;
            f_unread_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_f_unread_count(::std::string* f_unread_count) {
        if (f_unread_count_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_unread_count_;
        }
        if (f_unread_count) {
            set_has_f_unread_count();
            f_unread_count_ = f_unread_count;
        } else {
            clear_has_f_unread_count();
            f_unread_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.f_unread_count)
    }
    
    // required string device_udid = 24;
    inline bool AnswerRecommendHouse::has_device_udid() const {
        return (_has_bits_[0] & 0x00800000u) != 0;
    }
    inline void AnswerRecommendHouse::set_has_device_udid() {
        _has_bits_[0] |= 0x00800000u;
    }
    inline void AnswerRecommendHouse::clear_has_device_udid() {
        _has_bits_[0] &= ~0x00800000u;
    }
    inline void AnswerRecommendHouse::clear_device_udid() {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_->clear();
        }
        clear_has_device_udid();
    }
    inline const ::std::string& AnswerRecommendHouse::device_udid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecommendHouse.device_udid)
        return *device_udid_;
    }
    inline void AnswerRecommendHouse::set_device_udid(const ::std::string& value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecommendHouse.device_udid)
    }
    inline void AnswerRecommendHouse::set_device_udid(const char* value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecommendHouse.device_udid)
    }
    inline void AnswerRecommendHouse::set_device_udid(const char* value, size_t size) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecommendHouse.device_udid)
    }
    inline ::std::string* AnswerRecommendHouse::mutable_device_udid() {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecommendHouse.device_udid)
        return device_udid_;
    }
    inline ::std::string* AnswerRecommendHouse::release_device_udid() {
        clear_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_udid_;
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecommendHouse::set_allocated_device_udid(::std::string* device_udid) {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_udid_;
        }
        if (device_udid) {
            set_has_device_udid();
            device_udid_ = device_udid;
        } else {
            clear_has_device_udid();
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecommendHouse.device_udid)
    }
    
    // -------------------------------------------------------------------
    
    // AnswerRecHouse
    
    // required string msg_id_ = 1;
    inline bool AnswerRecHouse::has_msg_id_() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void AnswerRecHouse::set_has_msg_id_() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void AnswerRecHouse::clear_has_msg_id_() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void AnswerRecHouse::clear_msg_id_() {
        if (msg_id__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id__->clear();
        }
        clear_has_msg_id_();
    }
    inline const ::std::string& AnswerRecHouse::msg_id_() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.msg_id_)
        return *msg_id__;
    }
    inline void AnswerRecHouse::set_msg_id_(const ::std::string& value) {
        set_has_msg_id_();
        if (msg_id__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id__ = new ::std::string;
        }
        msg_id__->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.msg_id_)
    }
    inline void AnswerRecHouse::set_msg_id_(const char* value) {
        set_has_msg_id_();
        if (msg_id__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id__ = new ::std::string;
        }
        msg_id__->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.msg_id_)
    }
    inline void AnswerRecHouse::set_msg_id_(const char* value, size_t size) {
        set_has_msg_id_();
        if (msg_id__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id__ = new ::std::string;
        }
        msg_id__->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.msg_id_)
    }
    inline ::std::string* AnswerRecHouse::mutable_msg_id_() {
        set_has_msg_id_();
        if (msg_id__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id__ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.msg_id_)
        return msg_id__;
    }
    inline ::std::string* AnswerRecHouse::release_msg_id_() {
        clear_has_msg_id_();
        if (msg_id__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = msg_id__;
            msg_id__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_msg_id_(::std::string* msg_id_) {
        if (msg_id__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete msg_id__;
        }
        if (msg_id_) {
            set_has_msg_id_();
            msg_id__ = msg_id_;
        } else {
            clear_has_msg_id_();
            msg_id__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.msg_id_)
    }
    
    // required .QSChat.Finfo finfo = 2;
    inline bool AnswerRecHouse::has_finfo() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void AnswerRecHouse::set_has_finfo() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void AnswerRecHouse::clear_has_finfo() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void AnswerRecHouse::clear_finfo() {
        if (finfo_ != NULL) finfo_->::QSChat::Finfo::Clear();
        clear_has_finfo();
    }
    inline const ::QSChat::Finfo& AnswerRecHouse::finfo() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.finfo)
        return finfo_ != NULL ? *finfo_ : *default_instance_->finfo_;
    }
    inline ::QSChat::Finfo* AnswerRecHouse::mutable_finfo() {
        set_has_finfo();
        if (finfo_ == NULL) finfo_ = new ::QSChat::Finfo;
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.finfo)
        return finfo_;
    }
    inline ::QSChat::Finfo* AnswerRecHouse::release_finfo() {
        clear_has_finfo();
        ::QSChat::Finfo* temp = finfo_;
        finfo_ = NULL;
        return temp;
    }
    inline void AnswerRecHouse::set_allocated_finfo(::QSChat::Finfo* finfo) {
        delete finfo_;
        finfo_ = finfo;
        if (finfo) {
            set_has_finfo();
        } else {
            clear_has_finfo();
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.finfo)
    }
    
    // optional string attach_file = 3;
    inline bool AnswerRecHouse::has_attach_file() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void AnswerRecHouse::set_has_attach_file() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void AnswerRecHouse::clear_has_attach_file() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void AnswerRecHouse::clear_attach_file() {
        if (attach_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_->clear();
        }
        clear_has_attach_file();
    }
    inline const ::std::string& AnswerRecHouse::attach_file() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.attach_file)
        return *attach_file_;
    }
    inline void AnswerRecHouse::set_attach_file(const ::std::string& value) {
        set_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_ = new ::std::string;
        }
        attach_file_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.attach_file)
    }
    inline void AnswerRecHouse::set_attach_file(const char* value) {
        set_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_ = new ::std::string;
        }
        attach_file_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.attach_file)
    }
    inline void AnswerRecHouse::set_attach_file(const char* value, size_t size) {
        set_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_ = new ::std::string;
        }
        attach_file_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.attach_file)
    }
    inline ::std::string* AnswerRecHouse::mutable_attach_file() {
        set_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_file_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.attach_file)
        return attach_file_;
    }
    inline ::std::string* AnswerRecHouse::release_attach_file() {
        clear_has_attach_file();
        if (attach_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = attach_file_;
            attach_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_attach_file(::std::string* attach_file) {
        if (attach_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete attach_file_;
        }
        if (attach_file) {
            set_has_attach_file();
            attach_file_ = attach_file;
        } else {
            clear_has_attach_file();
            attach_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.attach_file)
    }
    
    // optional string attach_thumb = 4;
    inline bool AnswerRecHouse::has_attach_thumb() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void AnswerRecHouse::set_has_attach_thumb() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void AnswerRecHouse::clear_has_attach_thumb() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void AnswerRecHouse::clear_attach_thumb() {
        if (attach_thumb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_->clear();
        }
        clear_has_attach_thumb();
    }
    inline const ::std::string& AnswerRecHouse::attach_thumb() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.attach_thumb)
        return *attach_thumb_;
    }
    inline void AnswerRecHouse::set_attach_thumb(const ::std::string& value) {
        set_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_ = new ::std::string;
        }
        attach_thumb_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.attach_thumb)
    }
    inline void AnswerRecHouse::set_attach_thumb(const char* value) {
        set_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_ = new ::std::string;
        }
        attach_thumb_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.attach_thumb)
    }
    inline void AnswerRecHouse::set_attach_thumb(const char* value, size_t size) {
        set_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_ = new ::std::string;
        }
        attach_thumb_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.attach_thumb)
    }
    inline ::std::string* AnswerRecHouse::mutable_attach_thumb() {
        set_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            attach_thumb_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.attach_thumb)
        return attach_thumb_;
    }
    inline ::std::string* AnswerRecHouse::release_attach_thumb() {
        clear_has_attach_thumb();
        if (attach_thumb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = attach_thumb_;
            attach_thumb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_attach_thumb(::std::string* attach_thumb) {
        if (attach_thumb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete attach_thumb_;
        }
        if (attach_thumb) {
            set_has_attach_thumb();
            attach_thumb_ = attach_thumb;
        } else {
            clear_has_attach_thumb();
            attach_thumb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.attach_thumb)
    }
    
    // optional string areaid = 5;
    inline bool AnswerRecHouse::has_areaid() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void AnswerRecHouse::set_has_areaid() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void AnswerRecHouse::clear_has_areaid() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void AnswerRecHouse::clear_areaid() {
        if (areaid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_->clear();
        }
        clear_has_areaid();
    }
    inline const ::std::string& AnswerRecHouse::areaid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.areaid)
        return *areaid_;
    }
    inline void AnswerRecHouse::set_areaid(const ::std::string& value) {
        set_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_ = new ::std::string;
        }
        areaid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.areaid)
    }
    inline void AnswerRecHouse::set_areaid(const char* value) {
        set_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_ = new ::std::string;
        }
        areaid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.areaid)
    }
    inline void AnswerRecHouse::set_areaid(const char* value, size_t size) {
        set_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_ = new ::std::string;
        }
        areaid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.areaid)
    }
    inline ::std::string* AnswerRecHouse::mutable_areaid() {
        set_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            areaid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.areaid)
        return areaid_;
    }
    inline ::std::string* AnswerRecHouse::release_areaid() {
        clear_has_areaid();
        if (areaid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = areaid_;
            areaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_areaid(::std::string* areaid) {
        if (areaid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete areaid_;
        }
        if (areaid) {
            set_has_areaid();
            areaid_ = areaid;
        } else {
            clear_has_areaid();
            areaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.areaid)
    }
    
    // optional string area_val = 6;
    inline bool AnswerRecHouse::has_area_val() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void AnswerRecHouse::set_has_area_val() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void AnswerRecHouse::clear_has_area_val() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void AnswerRecHouse::clear_area_val() {
        if (area_val_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_->clear();
        }
        clear_has_area_val();
    }
    inline const ::std::string& AnswerRecHouse::area_val() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.area_val)
        return *area_val_;
    }
    inline void AnswerRecHouse::set_area_val(const ::std::string& value) {
        set_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_ = new ::std::string;
        }
        area_val_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.area_val)
    }
    inline void AnswerRecHouse::set_area_val(const char* value) {
        set_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_ = new ::std::string;
        }
        area_val_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.area_val)
    }
    inline void AnswerRecHouse::set_area_val(const char* value, size_t size) {
        set_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_ = new ::std::string;
        }
        area_val_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.area_val)
    }
    inline ::std::string* AnswerRecHouse::mutable_area_val() {
        set_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            area_val_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.area_val)
        return area_val_;
    }
    inline ::std::string* AnswerRecHouse::release_area_val() {
        clear_has_area_val();
        if (area_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = area_val_;
            area_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_area_val(::std::string* area_val) {
        if (area_val_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete area_val_;
        }
        if (area_val) {
            set_has_area_val();
            area_val_ = area_val;
        } else {
            clear_has_area_val();
            area_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.area_val)
    }
    
    // optional string streetid = 7;
    inline bool AnswerRecHouse::has_streetid() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void AnswerRecHouse::set_has_streetid() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void AnswerRecHouse::clear_has_streetid() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void AnswerRecHouse::clear_streetid() {
        if (streetid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_->clear();
        }
        clear_has_streetid();
    }
    inline const ::std::string& AnswerRecHouse::streetid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.streetid)
        return *streetid_;
    }
    inline void AnswerRecHouse::set_streetid(const ::std::string& value) {
        set_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_ = new ::std::string;
        }
        streetid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.streetid)
    }
    inline void AnswerRecHouse::set_streetid(const char* value) {
        set_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_ = new ::std::string;
        }
        streetid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.streetid)
    }
    inline void AnswerRecHouse::set_streetid(const char* value, size_t size) {
        set_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_ = new ::std::string;
        }
        streetid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.streetid)
    }
    inline ::std::string* AnswerRecHouse::mutable_streetid() {
        set_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            streetid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.streetid)
        return streetid_;
    }
    inline ::std::string* AnswerRecHouse::release_streetid() {
        clear_has_streetid();
        if (streetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = streetid_;
            streetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_streetid(::std::string* streetid) {
        if (streetid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete streetid_;
        }
        if (streetid) {
            set_has_streetid();
            streetid_ = streetid;
        } else {
            clear_has_streetid();
            streetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.streetid)
    }
    
    // optional string street_val = 8;
    inline bool AnswerRecHouse::has_street_val() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void AnswerRecHouse::set_has_street_val() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void AnswerRecHouse::clear_has_street_val() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void AnswerRecHouse::clear_street_val() {
        if (street_val_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_->clear();
        }
        clear_has_street_val();
    }
    inline const ::std::string& AnswerRecHouse::street_val() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.street_val)
        return *street_val_;
    }
    inline void AnswerRecHouse::set_street_val(const ::std::string& value) {
        set_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_ = new ::std::string;
        }
        street_val_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.street_val)
    }
    inline void AnswerRecHouse::set_street_val(const char* value) {
        set_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_ = new ::std::string;
        }
        street_val_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.street_val)
    }
    inline void AnswerRecHouse::set_street_val(const char* value, size_t size) {
        set_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_ = new ::std::string;
        }
        street_val_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.street_val)
    }
    inline ::std::string* AnswerRecHouse::mutable_street_val() {
        set_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            street_val_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.street_val)
        return street_val_;
    }
    inline ::std::string* AnswerRecHouse::release_street_val() {
        clear_has_street_val();
        if (street_val_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = street_val_;
            street_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_street_val(::std::string* street_val) {
        if (street_val_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete street_val_;
        }
        if (street_val) {
            set_has_street_val();
            street_val_ = street_val;
        } else {
            clear_has_street_val();
            street_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.street_val)
    }
    
    // optional string house_shi = 9;
    inline bool AnswerRecHouse::has_house_shi() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void AnswerRecHouse::set_has_house_shi() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void AnswerRecHouse::clear_has_house_shi() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void AnswerRecHouse::clear_house_shi() {
        if (house_shi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_->clear();
        }
        clear_has_house_shi();
    }
    inline const ::std::string& AnswerRecHouse::house_shi() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.house_shi)
        return *house_shi_;
    }
    inline void AnswerRecHouse::set_house_shi(const ::std::string& value) {
        set_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_ = new ::std::string;
        }
        house_shi_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.house_shi)
    }
    inline void AnswerRecHouse::set_house_shi(const char* value) {
        set_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_ = new ::std::string;
        }
        house_shi_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.house_shi)
    }
    inline void AnswerRecHouse::set_house_shi(const char* value, size_t size) {
        set_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_ = new ::std::string;
        }
        house_shi_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.house_shi)
    }
    inline ::std::string* AnswerRecHouse::mutable_house_shi() {
        set_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_shi_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.house_shi)
        return house_shi_;
    }
    inline ::std::string* AnswerRecHouse::release_house_shi() {
        clear_has_house_shi();
        if (house_shi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_shi_;
            house_shi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_house_shi(::std::string* house_shi) {
        if (house_shi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_shi_;
        }
        if (house_shi) {
            set_has_house_shi();
            house_shi_ = house_shi;
        } else {
            clear_has_house_shi();
            house_shi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.house_shi)
    }
    
    // optional string house_ting = 10;
    inline bool AnswerRecHouse::has_house_ting() const {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void AnswerRecHouse::set_has_house_ting() {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void AnswerRecHouse::clear_has_house_ting() {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void AnswerRecHouse::clear_house_ting() {
        if (house_ting_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_->clear();
        }
        clear_has_house_ting();
    }
    inline const ::std::string& AnswerRecHouse::house_ting() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.house_ting)
        return *house_ting_;
    }
    inline void AnswerRecHouse::set_house_ting(const ::std::string& value) {
        set_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_ = new ::std::string;
        }
        house_ting_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.house_ting)
    }
    inline void AnswerRecHouse::set_house_ting(const char* value) {
        set_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_ = new ::std::string;
        }
        house_ting_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.house_ting)
    }
    inline void AnswerRecHouse::set_house_ting(const char* value, size_t size) {
        set_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_ = new ::std::string;
        }
        house_ting_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.house_ting)
    }
    inline ::std::string* AnswerRecHouse::mutable_house_ting() {
        set_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_ting_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.house_ting)
        return house_ting_;
    }
    inline ::std::string* AnswerRecHouse::release_house_ting() {
        clear_has_house_ting();
        if (house_ting_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_ting_;
            house_ting_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_house_ting(::std::string* house_ting) {
        if (house_ting_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_ting_;
        }
        if (house_ting) {
            set_has_house_ting();
            house_ting_ = house_ting;
        } else {
            clear_has_house_ting();
            house_ting_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.house_ting)
    }
    
    // optional string house_area = 11;
    inline bool AnswerRecHouse::has_house_area() const {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void AnswerRecHouse::set_has_house_area() {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void AnswerRecHouse::clear_has_house_area() {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void AnswerRecHouse::clear_house_area() {
        if (house_area_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_->clear();
        }
        clear_has_house_area();
    }
    inline const ::std::string& AnswerRecHouse::house_area() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.house_area)
        return *house_area_;
    }
    inline void AnswerRecHouse::set_house_area(const ::std::string& value) {
        set_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_ = new ::std::string;
        }
        house_area_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.house_area)
    }
    inline void AnswerRecHouse::set_house_area(const char* value) {
        set_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_ = new ::std::string;
        }
        house_area_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.house_area)
    }
    inline void AnswerRecHouse::set_house_area(const char* value, size_t size) {
        set_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_ = new ::std::string;
        }
        house_area_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.house_area)
    }
    inline ::std::string* AnswerRecHouse::mutable_house_area() {
        set_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_area_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.house_area)
        return house_area_;
    }
    inline ::std::string* AnswerRecHouse::release_house_area() {
        clear_has_house_area();
        if (house_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_area_;
            house_area_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_house_area(::std::string* house_area) {
        if (house_area_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_area_;
        }
        if (house_area) {
            set_has_house_area();
            house_area_ = house_area;
        } else {
            clear_has_house_area();
            house_area_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.house_area)
    }
    
    // optional string house_price = 12;
    inline bool AnswerRecHouse::has_house_price() const {
        return (_has_bits_[0] & 0x00000800u) != 0;
    }
    inline void AnswerRecHouse::set_has_house_price() {
        _has_bits_[0] |= 0x00000800u;
    }
    inline void AnswerRecHouse::clear_has_house_price() {
        _has_bits_[0] &= ~0x00000800u;
    }
    inline void AnswerRecHouse::clear_house_price() {
        if (house_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_->clear();
        }
        clear_has_house_price();
    }
    inline const ::std::string& AnswerRecHouse::house_price() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.house_price)
        return *house_price_;
    }
    inline void AnswerRecHouse::set_house_price(const ::std::string& value) {
        set_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_ = new ::std::string;
        }
        house_price_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.house_price)
    }
    inline void AnswerRecHouse::set_house_price(const char* value) {
        set_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_ = new ::std::string;
        }
        house_price_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.house_price)
    }
    inline void AnswerRecHouse::set_house_price(const char* value, size_t size) {
        set_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_ = new ::std::string;
        }
        house_price_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.house_price)
    }
    inline ::std::string* AnswerRecHouse::mutable_house_price() {
        set_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_price_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.house_price)
        return house_price_;
    }
    inline ::std::string* AnswerRecHouse::release_house_price() {
        clear_has_house_price();
        if (house_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_price_;
            house_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_house_price(::std::string* house_price) {
        if (house_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_price_;
        }
        if (house_price) {
            set_has_house_price();
            house_price_ = house_price;
        } else {
            clear_has_house_price();
            house_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.house_price)
    }
    
    // optional string rent_price = 13;
    inline bool AnswerRecHouse::has_rent_price() const {
        return (_has_bits_[0] & 0x00001000u) != 0;
    }
    inline void AnswerRecHouse::set_has_rent_price() {
        _has_bits_[0] |= 0x00001000u;
    }
    inline void AnswerRecHouse::clear_has_rent_price() {
        _has_bits_[0] &= ~0x00001000u;
    }
    inline void AnswerRecHouse::clear_rent_price() {
        if (rent_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_->clear();
        }
        clear_has_rent_price();
    }
    inline const ::std::string& AnswerRecHouse::rent_price() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.rent_price)
        return *rent_price_;
    }
    inline void AnswerRecHouse::set_rent_price(const ::std::string& value) {
        set_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_ = new ::std::string;
        }
        rent_price_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.rent_price)
    }
    inline void AnswerRecHouse::set_rent_price(const char* value) {
        set_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_ = new ::std::string;
        }
        rent_price_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.rent_price)
    }
    inline void AnswerRecHouse::set_rent_price(const char* value, size_t size) {
        set_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_ = new ::std::string;
        }
        rent_price_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.rent_price)
    }
    inline ::std::string* AnswerRecHouse::mutable_rent_price() {
        set_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            rent_price_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.rent_price)
        return rent_price_;
    }
    inline ::std::string* AnswerRecHouse::release_rent_price() {
        clear_has_rent_price();
        if (rent_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = rent_price_;
            rent_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_rent_price(::std::string* rent_price) {
        if (rent_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete rent_price_;
        }
        if (rent_price) {
            set_has_rent_price();
            rent_price_ = rent_price;
        } else {
            clear_has_rent_price();
            rent_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.rent_price)
    }
    
    // optional string title_ = 14;
    inline bool AnswerRecHouse::has_title_() const {
        return (_has_bits_[0] & 0x00002000u) != 0;
    }
    inline void AnswerRecHouse::set_has_title_() {
        _has_bits_[0] |= 0x00002000u;
    }
    inline void AnswerRecHouse::clear_has_title_() {
        _has_bits_[0] &= ~0x00002000u;
    }
    inline void AnswerRecHouse::clear_title_() {
        if (title__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title__->clear();
        }
        clear_has_title_();
    }
    inline const ::std::string& AnswerRecHouse::title_() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerRecHouse.title_)
        return *title__;
    }
    inline void AnswerRecHouse::set_title_(const ::std::string& value) {
        set_has_title_();
        if (title__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title__ = new ::std::string;
        }
        title__->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerRecHouse.title_)
    }
    inline void AnswerRecHouse::set_title_(const char* value) {
        set_has_title_();
        if (title__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title__ = new ::std::string;
        }
        title__->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerRecHouse.title_)
    }
    inline void AnswerRecHouse::set_title_(const char* value, size_t size) {
        set_has_title_();
        if (title__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title__ = new ::std::string;
        }
        title__->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerRecHouse.title_)
    }
    inline ::std::string* AnswerRecHouse::mutable_title_() {
        set_has_title_();
        if (title__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title__ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerRecHouse.title_)
        return title__;
    }
    inline ::std::string* AnswerRecHouse::release_title_() {
        clear_has_title_();
        if (title__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = title__;
            title__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerRecHouse::set_allocated_title_(::std::string* title_) {
        if (title__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete title__;
        }
        if (title_) {
            set_has_title_();
            title__ = title_;
        } else {
            clear_has_title_();
            title__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerRecHouse.title_)
    }
    
    // -------------------------------------------------------------------
    
    // Finfo
    
    // required int64 fid = 1;
    inline bool Finfo::has_fid() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Finfo::set_has_fid() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Finfo::clear_has_fid() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Finfo::clear_fid() {
        fid_ = GOOGLE_LONGLONG(0);
        clear_has_fid();
    }
    inline ::google::protobuf::int64 Finfo::fid() const {
        // @@protoc_insertion_point(field_get:QSChat.Finfo.fid)
        return fid_;
    }
    inline void Finfo::set_fid(::google::protobuf::int64 value) {
        set_has_fid();
        fid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.Finfo.fid)
    }
    
    // required string f_avatar = 2;
    inline bool Finfo::has_f_avatar() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Finfo::set_has_f_avatar() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Finfo::clear_has_f_avatar() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Finfo::clear_f_avatar() {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_->clear();
        }
        clear_has_f_avatar();
    }
    inline const ::std::string& Finfo::f_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.Finfo.f_avatar)
        return *f_avatar_;
    }
    inline void Finfo::set_f_avatar(const ::std::string& value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.Finfo.f_avatar)
    }
    inline void Finfo::set_f_avatar(const char* value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.Finfo.f_avatar)
    }
    inline void Finfo::set_f_avatar(const char* value, size_t size) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.Finfo.f_avatar)
    }
    inline ::std::string* Finfo::mutable_f_avatar() {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.Finfo.f_avatar)
        return f_avatar_;
    }
    inline ::std::string* Finfo::release_f_avatar() {
        clear_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_avatar_;
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void Finfo::set_allocated_f_avatar(::std::string* f_avatar) {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_avatar_;
        }
        if (f_avatar) {
            set_has_f_avatar();
            f_avatar_ = f_avatar;
        } else {
            clear_has_f_avatar();
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.Finfo.f_avatar)
    }
    
    // required string f_name = 3;
    inline bool Finfo::has_f_name() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void Finfo::set_has_f_name() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void Finfo::clear_has_f_name() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void Finfo::clear_f_name() {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_->clear();
        }
        clear_has_f_name();
    }
    inline const ::std::string& Finfo::f_name() const {
        // @@protoc_insertion_point(field_get:QSChat.Finfo.f_name)
        return *f_name_;
    }
    inline void Finfo::set_f_name(const ::std::string& value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.Finfo.f_name)
    }
    inline void Finfo::set_f_name(const char* value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.Finfo.f_name)
    }
    inline void Finfo::set_f_name(const char* value, size_t size) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.Finfo.f_name)
    }
    inline ::std::string* Finfo::mutable_f_name() {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.Finfo.f_name)
        return f_name_;
    }
    inline ::std::string* Finfo::release_f_name() {
        clear_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_name_;
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void Finfo::set_allocated_f_name(::std::string* f_name) {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_name_;
        }
        if (f_name) {
            set_has_f_name();
            f_name_ = f_name;
        } else {
            clear_has_f_name();
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.Finfo.f_name)
    }
    
    // required string f_leve = 4;
    inline bool Finfo::has_f_leve() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void Finfo::set_has_f_leve() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void Finfo::clear_has_f_leve() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void Finfo::clear_f_leve() {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_->clear();
        }
        clear_has_f_leve();
    }
    inline const ::std::string& Finfo::f_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.Finfo.f_leve)
        return *f_leve_;
    }
    inline void Finfo::set_f_leve(const ::std::string& value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.Finfo.f_leve)
    }
    inline void Finfo::set_f_leve(const char* value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.Finfo.f_leve)
    }
    inline void Finfo::set_f_leve(const char* value, size_t size) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.Finfo.f_leve)
    }
    inline ::std::string* Finfo::mutable_f_leve() {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.Finfo.f_leve)
        return f_leve_;
    }
    inline ::std::string* Finfo::release_f_leve() {
        clear_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_leve_;
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void Finfo::set_allocated_f_leve(::std::string* f_leve) {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_leve_;
        }
        if (f_leve) {
            set_has_f_leve();
            f_leve_ = f_leve;
        } else {
            clear_has_f_leve();
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.Finfo.f_leve)
    }
    
    // required string f_user_type = 5;
    inline bool Finfo::has_f_user_type() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void Finfo::set_has_f_user_type() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void Finfo::clear_has_f_user_type() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void Finfo::clear_f_user_type() {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_->clear();
        }
        clear_has_f_user_type();
    }
    inline const ::std::string& Finfo::f_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.Finfo.f_user_type)
        return *f_user_type_;
    }
    inline void Finfo::set_f_user_type(const ::std::string& value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.Finfo.f_user_type)
    }
    inline void Finfo::set_f_user_type(const char* value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.Finfo.f_user_type)
    }
    inline void Finfo::set_f_user_type(const char* value, size_t size) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.Finfo.f_user_type)
    }
    inline ::std::string* Finfo::mutable_f_user_type() {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.Finfo.f_user_type)
        return f_user_type_;
    }
    inline ::std::string* Finfo::release_f_user_type() {
        clear_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_user_type_;
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void Finfo::set_allocated_f_user_type(::std::string* f_user_type) {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_user_type_;
        }
        if (f_user_type) {
            set_has_f_user_type();
            f_user_type_ = f_user_type;
        } else {
            clear_has_f_user_type();
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.Finfo.f_user_type)
    }
    
    // required string f_unread_count = 6;
    inline bool Finfo::has_f_unread_count() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void Finfo::set_has_f_unread_count() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void Finfo::clear_has_f_unread_count() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void Finfo::clear_f_unread_count() {
        if (f_unread_count_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_->clear();
        }
        clear_has_f_unread_count();
    }
    inline const ::std::string& Finfo::f_unread_count() const {
        // @@protoc_insertion_point(field_get:QSChat.Finfo.f_unread_count)
        return *f_unread_count_;
    }
    inline void Finfo::set_f_unread_count(const ::std::string& value) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.Finfo.f_unread_count)
    }
    inline void Finfo::set_f_unread_count(const char* value) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.Finfo.f_unread_count)
    }
    inline void Finfo::set_f_unread_count(const char* value, size_t size) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.Finfo.f_unread_count)
    }
    inline ::std::string* Finfo::mutable_f_unread_count() {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.Finfo.f_unread_count)
        return f_unread_count_;
    }
    inline ::std::string* Finfo::release_f_unread_count() {
        clear_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_unread_count_;
            f_unread_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void Finfo::set_allocated_f_unread_count(::std::string* f_unread_count) {
        if (f_unread_count_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_unread_count_;
        }
        if (f_unread_count) {
            set_has_f_unread_count();
            f_unread_count_ = f_unread_count;
        } else {
            clear_has_f_unread_count();
            f_unread_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.Finfo.f_unread_count)
    }
    
    // required string house_id = 7;
    inline bool Finfo::has_house_id() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void Finfo::set_has_house_id() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void Finfo::clear_has_house_id() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void Finfo::clear_house_id() {
        if (house_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_->clear();
        }
        clear_has_house_id();
    }
    inline const ::std::string& Finfo::house_id() const {
        // @@protoc_insertion_point(field_get:QSChat.Finfo.house_id)
        return *house_id_;
    }
    inline void Finfo::set_house_id(const ::std::string& value) {
        set_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_ = new ::std::string;
        }
        house_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.Finfo.house_id)
    }
    inline void Finfo::set_house_id(const char* value) {
        set_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_ = new ::std::string;
        }
        house_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.Finfo.house_id)
    }
    inline void Finfo::set_house_id(const char* value, size_t size) {
        set_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_ = new ::std::string;
        }
        house_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.Finfo.house_id)
    }
    inline ::std::string* Finfo::mutable_house_id() {
        set_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.Finfo.house_id)
        return house_id_;
    }
    inline ::std::string* Finfo::release_house_id() {
        clear_has_house_id();
        if (house_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_id_;
            house_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void Finfo::set_allocated_house_id(::std::string* house_id) {
        if (house_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_id_;
        }
        if (house_id) {
            set_has_house_id();
            house_id_ = house_id;
        } else {
            clear_has_house_id();
            house_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.Finfo.house_id)
    }
    
    // required string building_id = 8;
    inline bool Finfo::has_building_id() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void Finfo::set_has_building_id() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void Finfo::clear_has_building_id() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void Finfo::clear_building_id() {
        if (building_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_->clear();
        }
        clear_has_building_id();
    }
    inline const ::std::string& Finfo::building_id() const {
        // @@protoc_insertion_point(field_get:QSChat.Finfo.building_id)
        return *building_id_;
    }
    inline void Finfo::set_building_id(const ::std::string& value) {
        set_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_ = new ::std::string;
        }
        building_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.Finfo.building_id)
    }
    inline void Finfo::set_building_id(const char* value) {
        set_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_ = new ::std::string;
        }
        building_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.Finfo.building_id)
    }
    inline void Finfo::set_building_id(const char* value, size_t size) {
        set_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_ = new ::std::string;
        }
        building_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.Finfo.building_id)
    }
    inline ::std::string* Finfo::mutable_building_id() {
        set_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            building_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.Finfo.building_id)
        return building_id_;
    }
    inline ::std::string* Finfo::release_building_id() {
        clear_has_building_id();
        if (building_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = building_id_;
            building_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void Finfo::set_allocated_building_id(::std::string* building_id) {
        if (building_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete building_id_;
        }
        if (building_id) {
            set_has_building_id();
            building_id_ = building_id;
        } else {
            clear_has_building_id();
            building_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.Finfo.building_id)
    }
    
    // required string house_type = 9;
    inline bool Finfo::has_house_type() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void Finfo::set_has_house_type() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void Finfo::clear_has_house_type() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void Finfo::clear_house_type() {
        if (house_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_->clear();
        }
        clear_has_house_type();
    }
    inline const ::std::string& Finfo::house_type() const {
        // @@protoc_insertion_point(field_get:QSChat.Finfo.house_type)
        return *house_type_;
    }
    inline void Finfo::set_house_type(const ::std::string& value) {
        set_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_ = new ::std::string;
        }
        house_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.Finfo.house_type)
    }
    inline void Finfo::set_house_type(const char* value) {
        set_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_ = new ::std::string;
        }
        house_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.Finfo.house_type)
    }
    inline void Finfo::set_house_type(const char* value, size_t size) {
        set_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_ = new ::std::string;
        }
        house_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.Finfo.house_type)
    }
    inline ::std::string* Finfo::mutable_house_type() {
        set_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            house_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.Finfo.house_type)
        return house_type_;
    }
    inline ::std::string* Finfo::release_house_type() {
        clear_has_house_type();
        if (house_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = house_type_;
            house_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void Finfo::set_allocated_house_type(::std::string* house_type) {
        if (house_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete house_type_;
        }
        if (house_type) {
            set_has_house_type();
            house_type_ = house_type;
        } else {
            clear_has_house_type();
            house_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.Finfo.house_type)
    }
    
    // -------------------------------------------------------------------
    
    // AnswerOffline
    
    // required int32 result = 1;
    inline bool AnswerOffline::has_result() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void AnswerOffline::set_has_result() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void AnswerOffline::clear_has_result() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void AnswerOffline::clear_result() {
        result_ = 0;
        clear_has_result();
    }
    inline ::google::protobuf::int32 AnswerOffline::result() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerOffline.result)
        return result_;
    }
    inline void AnswerOffline::set_result(::google::protobuf::int32 value) {
        set_has_result();
        result_ = value;
        // @@protoc_insertion_point(field_set:QSChat.AnswerOffline.result)
    }
    
    // required string msg = 2;
    inline bool AnswerOffline::has_msg() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void AnswerOffline::set_has_msg() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void AnswerOffline::clear_has_msg() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void AnswerOffline::clear_msg() {
        if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_->clear();
        }
        clear_has_msg();
    }
    inline const ::std::string& AnswerOffline::msg() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerOffline.msg)
        return *msg_;
    }
    inline void AnswerOffline::set_msg(const ::std::string& value) {
        set_has_msg();
        if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_ = new ::std::string;
        }
        msg_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerOffline.msg)
    }
    inline void AnswerOffline::set_msg(const char* value) {
        set_has_msg();
        if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_ = new ::std::string;
        }
        msg_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerOffline.msg)
    }
    inline void AnswerOffline::set_msg(const char* value, size_t size) {
        set_has_msg();
        if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_ = new ::std::string;
        }
        msg_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerOffline.msg)
    }
    inline ::std::string* AnswerOffline::mutable_msg() {
        set_has_msg();
        if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerOffline.msg)
        return msg_;
    }
    inline ::std::string* AnswerOffline::release_msg() {
        clear_has_msg();
        if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = msg_;
            msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerOffline::set_allocated_msg(::std::string* msg) {
        if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete msg_;
        }
        if (msg) {
            set_has_msg();
            msg_ = msg;
        } else {
            clear_has_msg();
            msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerOffline.msg)
    }
    
    // required string msg_id = 3;
    inline bool AnswerOffline::has_msg_id() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void AnswerOffline::set_has_msg_id() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void AnswerOffline::clear_has_msg_id() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void AnswerOffline::clear_msg_id() {
        if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_->clear();
        }
        clear_has_msg_id();
    }
    inline const ::std::string& AnswerOffline::msg_id() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerOffline.msg_id)
        return *msg_id_;
    }
    inline void AnswerOffline::set_msg_id(const ::std::string& value) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerOffline.msg_id)
    }
    inline void AnswerOffline::set_msg_id(const char* value) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerOffline.msg_id)
    }
    inline void AnswerOffline::set_msg_id(const char* value, size_t size) {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        msg_id_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerOffline.msg_id)
    }
    inline ::std::string* AnswerOffline::mutable_msg_id() {
        set_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            msg_id_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerOffline.msg_id)
        return msg_id_;
    }
    inline ::std::string* AnswerOffline::release_msg_id() {
        clear_has_msg_id();
        if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = msg_id_;
            msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerOffline::set_allocated_msg_id(::std::string* msg_id) {
        if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete msg_id_;
        }
        if (msg_id) {
            set_has_msg_id();
            msg_id_ = msg_id;
        } else {
            clear_has_msg_id();
            msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerOffline.msg_id)
    }
    
    // required string time_stamp = 4;
    inline bool AnswerOffline::has_time_stamp() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void AnswerOffline::set_has_time_stamp() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void AnswerOffline::clear_has_time_stamp() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void AnswerOffline::clear_time_stamp() {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_->clear();
        }
        clear_has_time_stamp();
    }
    inline const ::std::string& AnswerOffline::time_stamp() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerOffline.time_stamp)
        return *time_stamp_;
    }
    inline void AnswerOffline::set_time_stamp(const ::std::string& value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerOffline.time_stamp)
    }
    inline void AnswerOffline::set_time_stamp(const char* value) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerOffline.time_stamp)
    }
    inline void AnswerOffline::set_time_stamp(const char* value, size_t size) {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        time_stamp_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerOffline.time_stamp)
    }
    inline ::std::string* AnswerOffline::mutable_time_stamp() {
        set_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_stamp_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerOffline.time_stamp)
        return time_stamp_;
    }
    inline ::std::string* AnswerOffline::release_time_stamp() {
        clear_has_time_stamp();
        if (time_stamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = time_stamp_;
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerOffline::set_allocated_time_stamp(::std::string* time_stamp) {
        if (time_stamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete time_stamp_;
        }
        if (time_stamp) {
            set_has_time_stamp();
            time_stamp_ = time_stamp;
        } else {
            clear_has_time_stamp();
            time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerOffline.time_stamp)
    }
    
    // required int64 fid = 5;
    inline bool AnswerOffline::has_fid() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void AnswerOffline::set_has_fid() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void AnswerOffline::clear_has_fid() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void AnswerOffline::clear_fid() {
        fid_ = GOOGLE_LONGLONG(0);
        clear_has_fid();
    }
    inline ::google::protobuf::int64 AnswerOffline::fid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerOffline.fid)
        return fid_;
    }
    inline void AnswerOffline::set_fid(::google::protobuf::int64 value) {
        set_has_fid();
        fid_ = value;
        // @@protoc_insertion_point(field_set:QSChat.AnswerOffline.fid)
    }
    
    // required string f_avatar = 6;
    inline bool AnswerOffline::has_f_avatar() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void AnswerOffline::set_has_f_avatar() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void AnswerOffline::clear_has_f_avatar() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void AnswerOffline::clear_f_avatar() {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_->clear();
        }
        clear_has_f_avatar();
    }
    inline const ::std::string& AnswerOffline::f_avatar() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerOffline.f_avatar)
        return *f_avatar_;
    }
    inline void AnswerOffline::set_f_avatar(const ::std::string& value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerOffline.f_avatar)
    }
    inline void AnswerOffline::set_f_avatar(const char* value) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerOffline.f_avatar)
    }
    inline void AnswerOffline::set_f_avatar(const char* value, size_t size) {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        f_avatar_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerOffline.f_avatar)
    }
    inline ::std::string* AnswerOffline::mutable_f_avatar() {
        set_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_avatar_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerOffline.f_avatar)
        return f_avatar_;
    }
    inline ::std::string* AnswerOffline::release_f_avatar() {
        clear_has_f_avatar();
        if (f_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_avatar_;
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerOffline::set_allocated_f_avatar(::std::string* f_avatar) {
        if (f_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_avatar_;
        }
        if (f_avatar) {
            set_has_f_avatar();
            f_avatar_ = f_avatar;
        } else {
            clear_has_f_avatar();
            f_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerOffline.f_avatar)
    }
    
    // required string f_name = 7;
    inline bool AnswerOffline::has_f_name() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void AnswerOffline::set_has_f_name() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void AnswerOffline::clear_has_f_name() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void AnswerOffline::clear_f_name() {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_->clear();
        }
        clear_has_f_name();
    }
    inline const ::std::string& AnswerOffline::f_name() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerOffline.f_name)
        return *f_name_;
    }
    inline void AnswerOffline::set_f_name(const ::std::string& value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerOffline.f_name)
    }
    inline void AnswerOffline::set_f_name(const char* value) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerOffline.f_name)
    }
    inline void AnswerOffline::set_f_name(const char* value, size_t size) {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        f_name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerOffline.f_name)
    }
    inline ::std::string* AnswerOffline::mutable_f_name() {
        set_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerOffline.f_name)
        return f_name_;
    }
    inline ::std::string* AnswerOffline::release_f_name() {
        clear_has_f_name();
        if (f_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_name_;
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerOffline::set_allocated_f_name(::std::string* f_name) {
        if (f_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_name_;
        }
        if (f_name) {
            set_has_f_name();
            f_name_ = f_name;
        } else {
            clear_has_f_name();
            f_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerOffline.f_name)
    }
    
    // required string f_leve = 8;
    inline bool AnswerOffline::has_f_leve() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void AnswerOffline::set_has_f_leve() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void AnswerOffline::clear_has_f_leve() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void AnswerOffline::clear_f_leve() {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_->clear();
        }
        clear_has_f_leve();
    }
    inline const ::std::string& AnswerOffline::f_leve() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerOffline.f_leve)
        return *f_leve_;
    }
    inline void AnswerOffline::set_f_leve(const ::std::string& value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerOffline.f_leve)
    }
    inline void AnswerOffline::set_f_leve(const char* value) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerOffline.f_leve)
    }
    inline void AnswerOffline::set_f_leve(const char* value, size_t size) {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        f_leve_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerOffline.f_leve)
    }
    inline ::std::string* AnswerOffline::mutable_f_leve() {
        set_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_leve_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerOffline.f_leve)
        return f_leve_;
    }
    inline ::std::string* AnswerOffline::release_f_leve() {
        clear_has_f_leve();
        if (f_leve_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_leve_;
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerOffline::set_allocated_f_leve(::std::string* f_leve) {
        if (f_leve_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_leve_;
        }
        if (f_leve) {
            set_has_f_leve();
            f_leve_ = f_leve;
        } else {
            clear_has_f_leve();
            f_leve_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerOffline.f_leve)
    }
    
    // required string f_user_type = 9;
    inline bool AnswerOffline::has_f_user_type() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void AnswerOffline::set_has_f_user_type() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void AnswerOffline::clear_has_f_user_type() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void AnswerOffline::clear_f_user_type() {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_->clear();
        }
        clear_has_f_user_type();
    }
    inline const ::std::string& AnswerOffline::f_user_type() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerOffline.f_user_type)
        return *f_user_type_;
    }
    inline void AnswerOffline::set_f_user_type(const ::std::string& value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerOffline.f_user_type)
    }
    inline void AnswerOffline::set_f_user_type(const char* value) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerOffline.f_user_type)
    }
    inline void AnswerOffline::set_f_user_type(const char* value, size_t size) {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        f_user_type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerOffline.f_user_type)
    }
    inline ::std::string* AnswerOffline::mutable_f_user_type() {
        set_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_user_type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerOffline.f_user_type)
        return f_user_type_;
    }
    inline ::std::string* AnswerOffline::release_f_user_type() {
        clear_has_f_user_type();
        if (f_user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_user_type_;
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerOffline::set_allocated_f_user_type(::std::string* f_user_type) {
        if (f_user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_user_type_;
        }
        if (f_user_type) {
            set_has_f_user_type();
            f_user_type_ = f_user_type;
        } else {
            clear_has_f_user_type();
            f_user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerOffline.f_user_type)
    }
    
    // required string f_unread_count = 10;
    inline bool AnswerOffline::has_f_unread_count() const {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void AnswerOffline::set_has_f_unread_count() {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void AnswerOffline::clear_has_f_unread_count() {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void AnswerOffline::clear_f_unread_count() {
        if (f_unread_count_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_->clear();
        }
        clear_has_f_unread_count();
    }
    inline const ::std::string& AnswerOffline::f_unread_count() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerOffline.f_unread_count)
        return *f_unread_count_;
    }
    inline void AnswerOffline::set_f_unread_count(const ::std::string& value) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerOffline.f_unread_count)
    }
    inline void AnswerOffline::set_f_unread_count(const char* value) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerOffline.f_unread_count)
    }
    inline void AnswerOffline::set_f_unread_count(const char* value, size_t size) {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        f_unread_count_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerOffline.f_unread_count)
    }
    inline ::std::string* AnswerOffline::mutable_f_unread_count() {
        set_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            f_unread_count_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerOffline.f_unread_count)
        return f_unread_count_;
    }
    inline ::std::string* AnswerOffline::release_f_unread_count() {
        clear_has_f_unread_count();
        if (f_unread_count_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = f_unread_count_;
            f_unread_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerOffline::set_allocated_f_unread_count(::std::string* f_unread_count) {
        if (f_unread_count_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete f_unread_count_;
        }
        if (f_unread_count) {
            set_has_f_unread_count();
            f_unread_count_ = f_unread_count;
        } else {
            clear_has_f_unread_count();
            f_unread_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerOffline.f_unread_count)
    }
    
    // required string device_udid = 11;
    inline bool AnswerOffline::has_device_udid() const {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void AnswerOffline::set_has_device_udid() {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void AnswerOffline::clear_has_device_udid() {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void AnswerOffline::clear_device_udid() {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_->clear();
        }
        clear_has_device_udid();
    }
    inline const ::std::string& AnswerOffline::device_udid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerOffline.device_udid)
        return *device_udid_;
    }
    inline void AnswerOffline::set_device_udid(const ::std::string& value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerOffline.device_udid)
    }
    inline void AnswerOffline::set_device_udid(const char* value) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerOffline.device_udid)
    }
    inline void AnswerOffline::set_device_udid(const char* value, size_t size) {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        device_udid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerOffline.device_udid)
    }
    inline ::std::string* AnswerOffline::mutable_device_udid() {
        set_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            device_udid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerOffline.device_udid)
        return device_udid_;
    }
    inline ::std::string* AnswerOffline::release_device_udid() {
        clear_has_device_udid();
        if (device_udid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = device_udid_;
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerOffline::set_allocated_device_udid(::std::string* device_udid) {
        if (device_udid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete device_udid_;
        }
        if (device_udid) {
            set_has_device_udid();
            device_udid_ = device_udid;
        } else {
            clear_has_device_udid();
            device_udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerOffline.device_udid)
    }
    
    // -------------------------------------------------------------------
    
    // AnswerSpecial
    
    // required string name = 1;
    inline bool AnswerSpecial::has_name() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void AnswerSpecial::set_has_name() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void AnswerSpecial::clear_has_name() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void AnswerSpecial::clear_name() {
        if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            name_->clear();
        }
        clear_has_name();
    }
    inline const ::std::string& AnswerSpecial::name() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSpecial.name)
        return *name_;
    }
    inline void AnswerSpecial::set_name(const ::std::string& value) {
        set_has_name();
        if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            name_ = new ::std::string;
        }
        name_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSpecial.name)
    }
    inline void AnswerSpecial::set_name(const char* value) {
        set_has_name();
        if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            name_ = new ::std::string;
        }
        name_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSpecial.name)
    }
    inline void AnswerSpecial::set_name(const char* value, size_t size) {
        set_has_name();
        if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            name_ = new ::std::string;
        }
        name_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSpecial.name)
    }
    inline ::std::string* AnswerSpecial::mutable_name() {
        set_has_name();
        if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            name_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSpecial.name)
        return name_;
    }
    inline ::std::string* AnswerSpecial::release_name() {
        clear_has_name();
        if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = name_;
            name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSpecial::set_allocated_name(::std::string* name) {
        if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete name_;
        }
        if (name) {
            set_has_name();
            name_ = name;
        } else {
            clear_has_name();
            name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSpecial.name)
    }
    
    // required string pic = 2;
    inline bool AnswerSpecial::has_pic() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void AnswerSpecial::set_has_pic() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void AnswerSpecial::clear_has_pic() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void AnswerSpecial::clear_pic() {
        if (pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_->clear();
        }
        clear_has_pic();
    }
    inline const ::std::string& AnswerSpecial::pic() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSpecial.pic)
        return *pic_;
    }
    inline void AnswerSpecial::set_pic(const ::std::string& value) {
        set_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_ = new ::std::string;
        }
        pic_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSpecial.pic)
    }
    inline void AnswerSpecial::set_pic(const char* value) {
        set_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_ = new ::std::string;
        }
        pic_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSpecial.pic)
    }
    inline void AnswerSpecial::set_pic(const char* value, size_t size) {
        set_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_ = new ::std::string;
        }
        pic_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSpecial.pic)
    }
    inline ::std::string* AnswerSpecial::mutable_pic() {
        set_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            pic_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSpecial.pic)
        return pic_;
    }
    inline ::std::string* AnswerSpecial::release_pic() {
        clear_has_pic();
        if (pic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = pic_;
            pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSpecial::set_allocated_pic(::std::string* pic) {
        if (pic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete pic_;
        }
        if (pic) {
            set_has_pic();
            pic_ = pic;
        } else {
            clear_has_pic();
            pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSpecial.pic)
    }
    
    // required string desc = 3;
    inline bool AnswerSpecial::has_desc() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void AnswerSpecial::set_has_desc() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void AnswerSpecial::clear_has_desc() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void AnswerSpecial::clear_desc() {
        if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            desc_->clear();
        }
        clear_has_desc();
    }
    inline const ::std::string& AnswerSpecial::desc() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSpecial.desc)
        return *desc_;
    }
    inline void AnswerSpecial::set_desc(const ::std::string& value) {
        set_has_desc();
        if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            desc_ = new ::std::string;
        }
        desc_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSpecial.desc)
    }
    inline void AnswerSpecial::set_desc(const char* value) {
        set_has_desc();
        if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            desc_ = new ::std::string;
        }
        desc_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSpecial.desc)
    }
    inline void AnswerSpecial::set_desc(const char* value, size_t size) {
        set_has_desc();
        if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            desc_ = new ::std::string;
        }
        desc_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSpecial.desc)
    }
    inline ::std::string* AnswerSpecial::mutable_desc() {
        set_has_desc();
        if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            desc_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSpecial.desc)
        return desc_;
    }
    inline ::std::string* AnswerSpecial::release_desc() {
        clear_has_desc();
        if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = desc_;
            desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSpecial::set_allocated_desc(::std::string* desc) {
        if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete desc_;
        }
        if (desc) {
            set_has_desc();
            desc_ = desc;
        } else {
            clear_has_desc();
            desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSpecial.desc)
    }
    
    // required string fid = 4;
    inline bool AnswerSpecial::has_fid() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void AnswerSpecial::set_has_fid() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void AnswerSpecial::clear_has_fid() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void AnswerSpecial::clear_fid() {
        if (fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            fid_->clear();
        }
        clear_has_fid();
    }
    inline const ::std::string& AnswerSpecial::fid() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSpecial.fid)
        return *fid_;
    }
    inline void AnswerSpecial::set_fid(const ::std::string& value) {
        set_has_fid();
        if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            fid_ = new ::std::string;
        }
        fid_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSpecial.fid)
    }
    inline void AnswerSpecial::set_fid(const char* value) {
        set_has_fid();
        if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            fid_ = new ::std::string;
        }
        fid_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSpecial.fid)
    }
    inline void AnswerSpecial::set_fid(const char* value, size_t size) {
        set_has_fid();
        if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            fid_ = new ::std::string;
        }
        fid_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSpecial.fid)
    }
    inline ::std::string* AnswerSpecial::mutable_fid() {
        set_has_fid();
        if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            fid_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSpecial.fid)
        return fid_;
    }
    inline ::std::string* AnswerSpecial::release_fid() {
        clear_has_fid();
        if (fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = fid_;
            fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSpecial::set_allocated_fid(::std::string* fid) {
        if (fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete fid_;
        }
        if (fid) {
            set_has_fid();
            fid_ = fid;
        } else {
            clear_has_fid();
            fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSpecial.fid)
    }
    
    // required string type = 5;
    inline bool AnswerSpecial::has_type() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void AnswerSpecial::set_has_type() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void AnswerSpecial::clear_has_type() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void AnswerSpecial::clear_type() {
        if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            type_->clear();
        }
        clear_has_type();
    }
    inline const ::std::string& AnswerSpecial::type() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSpecial.type)
        return *type_;
    }
    inline void AnswerSpecial::set_type(const ::std::string& value) {
        set_has_type();
        if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            type_ = new ::std::string;
        }
        type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSpecial.type)
    }
    inline void AnswerSpecial::set_type(const char* value) {
        set_has_type();
        if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            type_ = new ::std::string;
        }
        type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSpecial.type)
    }
    inline void AnswerSpecial::set_type(const char* value, size_t size) {
        set_has_type();
        if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            type_ = new ::std::string;
        }
        type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSpecial.type)
    }
    inline ::std::string* AnswerSpecial::mutable_type() {
        set_has_type();
        if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSpecial.type)
        return type_;
    }
    inline ::std::string* AnswerSpecial::release_type() {
        clear_has_type();
        if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = type_;
            type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSpecial::set_allocated_type(::std::string* type) {
        if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete type_;
        }
        if (type) {
            set_has_type();
            type_ = type;
        } else {
            clear_has_type();
            type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSpecial.type)
    }
    
    // -------------------------------------------------------------------
    
    // AnswerSystem
    
    // required string title = 1;
    inline bool AnswerSystem::has_title() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void AnswerSystem::set_has_title() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void AnswerSystem::clear_has_title() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void AnswerSystem::clear_title() {
        if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title_->clear();
        }
        clear_has_title();
    }
    inline const ::std::string& AnswerSystem::title() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSystem.title)
        return *title_;
    }
    inline void AnswerSystem::set_title(const ::std::string& value) {
        set_has_title();
        if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title_ = new ::std::string;
        }
        title_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSystem.title)
    }
    inline void AnswerSystem::set_title(const char* value) {
        set_has_title();
        if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title_ = new ::std::string;
        }
        title_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSystem.title)
    }
    inline void AnswerSystem::set_title(const char* value, size_t size) {
        set_has_title();
        if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title_ = new ::std::string;
        }
        title_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSystem.title)
    }
    inline ::std::string* AnswerSystem::mutable_title() {
        set_has_title();
        if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            title_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSystem.title)
        return title_;
    }
    inline ::std::string* AnswerSystem::release_title() {
        clear_has_title();
        if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = title_;
            title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSystem::set_allocated_title(::std::string* title) {
        if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete title_;
        }
        if (title) {
            set_has_title();
            title_ = title;
        } else {
            clear_has_title();
            title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSystem.title)
    }
    
    // required string desc = 2;
    inline bool AnswerSystem::has_desc() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void AnswerSystem::set_has_desc() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void AnswerSystem::clear_has_desc() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void AnswerSystem::clear_desc() {
        if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            desc_->clear();
        }
        clear_has_desc();
    }
    inline const ::std::string& AnswerSystem::desc() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSystem.desc)
        return *desc_;
    }
    inline void AnswerSystem::set_desc(const ::std::string& value) {
        set_has_desc();
        if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            desc_ = new ::std::string;
        }
        desc_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSystem.desc)
    }
    inline void AnswerSystem::set_desc(const char* value) {
        set_has_desc();
        if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            desc_ = new ::std::string;
        }
        desc_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSystem.desc)
    }
    inline void AnswerSystem::set_desc(const char* value, size_t size) {
        set_has_desc();
        if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            desc_ = new ::std::string;
        }
        desc_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSystem.desc)
    }
    inline ::std::string* AnswerSystem::mutable_desc() {
        set_has_desc();
        if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            desc_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSystem.desc)
        return desc_;
    }
    inline ::std::string* AnswerSystem::release_desc() {
        clear_has_desc();
        if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = desc_;
            desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSystem::set_allocated_desc(::std::string* desc) {
        if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete desc_;
        }
        if (desc) {
            set_has_desc();
            desc_ = desc;
        } else {
            clear_has_desc();
            desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSystem.desc)
    }
    
    // required string time = 3;
    inline bool AnswerSystem::has_time() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void AnswerSystem::set_has_time() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void AnswerSystem::clear_has_time() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void AnswerSystem::clear_time() {
        if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_->clear();
        }
        clear_has_time();
    }
    inline const ::std::string& AnswerSystem::time() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSystem.time)
        return *time_;
    }
    inline void AnswerSystem::set_time(const ::std::string& value) {
        set_has_time();
        if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_ = new ::std::string;
        }
        time_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSystem.time)
    }
    inline void AnswerSystem::set_time(const char* value) {
        set_has_time();
        if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_ = new ::std::string;
        }
        time_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSystem.time)
    }
    inline void AnswerSystem::set_time(const char* value, size_t size) {
        set_has_time();
        if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_ = new ::std::string;
        }
        time_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSystem.time)
    }
    inline ::std::string* AnswerSystem::mutable_time() {
        set_has_time();
        if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            time_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSystem.time)
        return time_;
    }
    inline ::std::string* AnswerSystem::release_time() {
        clear_has_time();
        if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = time_;
            time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSystem::set_allocated_time(::std::string* time) {
        if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete time_;
        }
        if (time) {
            set_has_time();
            time_ = time;
        } else {
            clear_has_time();
            time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSystem.time)
    }
    
    // required string type = 4;
    inline bool AnswerSystem::has_type() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void AnswerSystem::set_has_type() {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void AnswerSystem::clear_has_type() {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void AnswerSystem::clear_type() {
        if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            type_->clear();
        }
        clear_has_type();
    }
    inline const ::std::string& AnswerSystem::type() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSystem.type)
        return *type_;
    }
    inline void AnswerSystem::set_type(const ::std::string& value) {
        set_has_type();
        if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            type_ = new ::std::string;
        }
        type_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSystem.type)
    }
    inline void AnswerSystem::set_type(const char* value) {
        set_has_type();
        if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            type_ = new ::std::string;
        }
        type_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSystem.type)
    }
    inline void AnswerSystem::set_type(const char* value, size_t size) {
        set_has_type();
        if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            type_ = new ::std::string;
        }
        type_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSystem.type)
    }
    inline ::std::string* AnswerSystem::mutable_type() {
        set_has_type();
        if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            type_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSystem.type)
        return type_;
    }
    inline ::std::string* AnswerSystem::release_type() {
        clear_has_type();
        if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = type_;
            type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSystem::set_allocated_type(::std::string* type) {
        if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete type_;
        }
        if (type) {
            set_has_type();
            type_ = type;
        } else {
            clear_has_type();
            type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSystem.type)
    }
    
    // required string url = 5;
    inline bool AnswerSystem::has_url() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void AnswerSystem::set_has_url() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void AnswerSystem::clear_has_url() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void AnswerSystem::clear_url() {
        if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            url_->clear();
        }
        clear_has_url();
    }
    inline const ::std::string& AnswerSystem::url() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSystem.url)
        return *url_;
    }
    inline void AnswerSystem::set_url(const ::std::string& value) {
        set_has_url();
        if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            url_ = new ::std::string;
        }
        url_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSystem.url)
    }
    inline void AnswerSystem::set_url(const char* value) {
        set_has_url();
        if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            url_ = new ::std::string;
        }
        url_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSystem.url)
    }
    inline void AnswerSystem::set_url(const char* value, size_t size) {
        set_has_url();
        if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            url_ = new ::std::string;
        }
        url_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSystem.url)
    }
    inline ::std::string* AnswerSystem::mutable_url() {
        set_has_url();
        if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            url_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSystem.url)
        return url_;
    }
    inline ::std::string* AnswerSystem::release_url() {
        clear_has_url();
        if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = url_;
            url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSystem::set_allocated_url(::std::string* url) {
        if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete url_;
        }
        if (url) {
            set_has_url();
            url_ = url;
        } else {
            clear_has_url();
            url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSystem.url)
    }
    
    // optional string exp_1 = 6;
    inline bool AnswerSystem::has_exp_1() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void AnswerSystem::set_has_exp_1() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void AnswerSystem::clear_has_exp_1() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void AnswerSystem::clear_exp_1() {
        if (exp_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_1_->clear();
        }
        clear_has_exp_1();
    }
    inline const ::std::string& AnswerSystem::exp_1() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSystem.exp_1)
        return *exp_1_;
    }
    inline void AnswerSystem::set_exp_1(const ::std::string& value) {
        set_has_exp_1();
        if (exp_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_1_ = new ::std::string;
        }
        exp_1_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSystem.exp_1)
    }
    inline void AnswerSystem::set_exp_1(const char* value) {
        set_has_exp_1();
        if (exp_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_1_ = new ::std::string;
        }
        exp_1_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSystem.exp_1)
    }
    inline void AnswerSystem::set_exp_1(const char* value, size_t size) {
        set_has_exp_1();
        if (exp_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_1_ = new ::std::string;
        }
        exp_1_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSystem.exp_1)
    }
    inline ::std::string* AnswerSystem::mutable_exp_1() {
        set_has_exp_1();
        if (exp_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_1_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSystem.exp_1)
        return exp_1_;
    }
    inline ::std::string* AnswerSystem::release_exp_1() {
        clear_has_exp_1();
        if (exp_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = exp_1_;
            exp_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSystem::set_allocated_exp_1(::std::string* exp_1) {
        if (exp_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete exp_1_;
        }
        if (exp_1) {
            set_has_exp_1();
            exp_1_ = exp_1;
        } else {
            clear_has_exp_1();
            exp_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSystem.exp_1)
    }
    
    // optional string exp_2 = 7;
    inline bool AnswerSystem::has_exp_2() const {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void AnswerSystem::set_has_exp_2() {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void AnswerSystem::clear_has_exp_2() {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void AnswerSystem::clear_exp_2() {
        if (exp_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_2_->clear();
        }
        clear_has_exp_2();
    }
    inline const ::std::string& AnswerSystem::exp_2() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSystem.exp_2)
        return *exp_2_;
    }
    inline void AnswerSystem::set_exp_2(const ::std::string& value) {
        set_has_exp_2();
        if (exp_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_2_ = new ::std::string;
        }
        exp_2_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSystem.exp_2)
    }
    inline void AnswerSystem::set_exp_2(const char* value) {
        set_has_exp_2();
        if (exp_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_2_ = new ::std::string;
        }
        exp_2_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSystem.exp_2)
    }
    inline void AnswerSystem::set_exp_2(const char* value, size_t size) {
        set_has_exp_2();
        if (exp_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_2_ = new ::std::string;
        }
        exp_2_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSystem.exp_2)
    }
    inline ::std::string* AnswerSystem::mutable_exp_2() {
        set_has_exp_2();
        if (exp_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_2_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSystem.exp_2)
        return exp_2_;
    }
    inline ::std::string* AnswerSystem::release_exp_2() {
        clear_has_exp_2();
        if (exp_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = exp_2_;
            exp_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSystem::set_allocated_exp_2(::std::string* exp_2) {
        if (exp_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete exp_2_;
        }
        if (exp_2) {
            set_has_exp_2();
            exp_2_ = exp_2;
        } else {
            clear_has_exp_2();
            exp_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSystem.exp_2)
    }
    
    // optional string exp_3 = 8;
    inline bool AnswerSystem::has_exp_3() const {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void AnswerSystem::set_has_exp_3() {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void AnswerSystem::clear_has_exp_3() {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void AnswerSystem::clear_exp_3() {
        if (exp_3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_3_->clear();
        }
        clear_has_exp_3();
    }
    inline const ::std::string& AnswerSystem::exp_3() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSystem.exp_3)
        return *exp_3_;
    }
    inline void AnswerSystem::set_exp_3(const ::std::string& value) {
        set_has_exp_3();
        if (exp_3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_3_ = new ::std::string;
        }
        exp_3_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSystem.exp_3)
    }
    inline void AnswerSystem::set_exp_3(const char* value) {
        set_has_exp_3();
        if (exp_3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_3_ = new ::std::string;
        }
        exp_3_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSystem.exp_3)
    }
    inline void AnswerSystem::set_exp_3(const char* value, size_t size) {
        set_has_exp_3();
        if (exp_3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_3_ = new ::std::string;
        }
        exp_3_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSystem.exp_3)
    }
    inline ::std::string* AnswerSystem::mutable_exp_3() {
        set_has_exp_3();
        if (exp_3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_3_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSystem.exp_3)
        return exp_3_;
    }
    inline ::std::string* AnswerSystem::release_exp_3() {
        clear_has_exp_3();
        if (exp_3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = exp_3_;
            exp_3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSystem::set_allocated_exp_3(::std::string* exp_3) {
        if (exp_3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete exp_3_;
        }
        if (exp_3) {
            set_has_exp_3();
            exp_3_ = exp_3;
        } else {
            clear_has_exp_3();
            exp_3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSystem.exp_3)
    }
    
    // optional string exp_4 = 9;
    inline bool AnswerSystem::has_exp_4() const {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void AnswerSystem::set_has_exp_4() {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void AnswerSystem::clear_has_exp_4() {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void AnswerSystem::clear_exp_4() {
        if (exp_4_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_4_->clear();
        }
        clear_has_exp_4();
    }
    inline const ::std::string& AnswerSystem::exp_4() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSystem.exp_4)
        return *exp_4_;
    }
    inline void AnswerSystem::set_exp_4(const ::std::string& value) {
        set_has_exp_4();
        if (exp_4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_4_ = new ::std::string;
        }
        exp_4_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSystem.exp_4)
    }
    inline void AnswerSystem::set_exp_4(const char* value) {
        set_has_exp_4();
        if (exp_4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_4_ = new ::std::string;
        }
        exp_4_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSystem.exp_4)
    }
    inline void AnswerSystem::set_exp_4(const char* value, size_t size) {
        set_has_exp_4();
        if (exp_4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_4_ = new ::std::string;
        }
        exp_4_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSystem.exp_4)
    }
    inline ::std::string* AnswerSystem::mutable_exp_4() {
        set_has_exp_4();
        if (exp_4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_4_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSystem.exp_4)
        return exp_4_;
    }
    inline ::std::string* AnswerSystem::release_exp_4() {
        clear_has_exp_4();
        if (exp_4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = exp_4_;
            exp_4_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSystem::set_allocated_exp_4(::std::string* exp_4) {
        if (exp_4_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete exp_4_;
        }
        if (exp_4) {
            set_has_exp_4();
            exp_4_ = exp_4;
        } else {
            clear_has_exp_4();
            exp_4_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSystem.exp_4)
    }
    
    // optional string exp_5 = 10;
    inline bool AnswerSystem::has_exp_5() const {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void AnswerSystem::set_has_exp_5() {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void AnswerSystem::clear_has_exp_5() {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void AnswerSystem::clear_exp_5() {
        if (exp_5_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_5_->clear();
        }
        clear_has_exp_5();
    }
    inline const ::std::string& AnswerSystem::exp_5() const {
        // @@protoc_insertion_point(field_get:QSChat.AnswerSystem.exp_5)
        return *exp_5_;
    }
    inline void AnswerSystem::set_exp_5(const ::std::string& value) {
        set_has_exp_5();
        if (exp_5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_5_ = new ::std::string;
        }
        exp_5_->assign(value);
        // @@protoc_insertion_point(field_set:QSChat.AnswerSystem.exp_5)
    }
    inline void AnswerSystem::set_exp_5(const char* value) {
        set_has_exp_5();
        if (exp_5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_5_ = new ::std::string;
        }
        exp_5_->assign(value);
        // @@protoc_insertion_point(field_set_char:QSChat.AnswerSystem.exp_5)
    }
    inline void AnswerSystem::set_exp_5(const char* value, size_t size) {
        set_has_exp_5();
        if (exp_5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_5_ = new ::std::string;
        }
        exp_5_->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:QSChat.AnswerSystem.exp_5)
    }
    inline ::std::string* AnswerSystem::mutable_exp_5() {
        set_has_exp_5();
        if (exp_5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            exp_5_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:QSChat.AnswerSystem.exp_5)
        return exp_5_;
    }
    inline ::std::string* AnswerSystem::release_exp_5() {
        clear_has_exp_5();
        if (exp_5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string* temp = exp_5_;
            exp_5_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }
    inline void AnswerSystem::set_allocated_exp_5(::std::string* exp_5) {
        if (exp_5_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete exp_5_;
        }
        if (exp_5) {
            set_has_exp_5();
            exp_5_ = exp_5;
        } else {
            clear_has_exp_5();
            exp_5_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:QSChat.AnswerSystem.exp_5)
    }
    
    
    // @@protoc_insertion_point(namespace_scope)
    
}  // namespace QSChat

#ifndef SWIG
namespace google {
    namespace protobuf {
        
        template <> struct is_proto_enum< ::QSChat::QSChatMessageType> : ::google::protobuf::internal::true_type {};
        template <>
        inline const EnumDescriptor* GetEnumDescriptor< ::QSChat::QSChatMessageType>() {
            return ::QSChat::QSChatMessageType_descriptor();
        }
        template <> struct is_proto_enum< ::QSChat::ChatRequestType> : ::google::protobuf::internal::true_type {};
        template <>
        inline const EnumDescriptor* GetEnumDescriptor< ::QSChat::ChatRequestType>() {
            return ::QSChat::ChatRequestType_descriptor();
        }
        
    }  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_qschat_2eproto__INCLUDED
